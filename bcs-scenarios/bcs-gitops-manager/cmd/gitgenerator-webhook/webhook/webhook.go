/*
 * Tencent is pleased to support the open source community by making Blueking Container Service available.
 * Copyright (C) 2019 THL A29 Limited, a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package webhook xxx
package webhook

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/Tencent/bk-bcs/bcs-common/common/blog"
	clusterclient "github.com/argoproj/argo-cd/v2/pkg/apiclient/cluster"
	"github.com/argoproj/argo-cd/v2/pkg/apis/application"
	"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1"
	synccommon "github.com/argoproj/gitops-engine/pkg/sync/common"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	v1 "k8s.io/api/admission/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/utils/strings/slices"

	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/cmd/gitgenerator-webhook/options"
	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/internal/dao"
	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/pkg/store"
)

// AdmissionWebhookServer defines the webhook server to check application
// generated by git-generator
type AdmissionWebhookServer struct {
	HttpHandler *gin.Engine
	cfg         *options.Config
	argoStore   store.Store
	db          dao.Interface
}

// NewAdmissionWebhookServer create the webhook-server instance
func NewAdmissionWebhookServer(cfg *options.Config) *AdmissionWebhookServer {
	gin.SetMode(gin.ReleaseMode)
	r := gin.New()
	r.Use(gin.Recovery())
	server := &AdmissionWebhookServer{
		cfg:         cfg,
		HttpHandler: r,
	}
	server.registerRouter()
	return server
}

// Init will init the argocd client
func (s *AdmissionWebhookServer) Init() error {
	s.argoStore = store.NewStore(&store.Options{
		Service:       s.cfg.ArgoService,
		User:          s.cfg.ArgoUser,
		Pass:          s.cfg.ArgoPass,
		Cache:         false,
		CacheHistory:  false,
		RepoServerUrl: s.cfg.ArgoRepoUrl,
	})
	var err error
	s.db, err = dao.NewDriver(&s.cfg.DBConfig)
	if err != nil {
		return errors.Wrapf(err, "init database failed")
	}
	if err = s.argoStore.Init(); err != nil {
		return errors.Wrapf(err, "init argocd stroe failed")
	}
	if err = s.argoStore.InitArgoDB(context.Background()); err != nil {
		return errors.Wrapf(err, "init argocd db failed")
	}
	return nil
}

// Run the webhook server with http export
func (s *AdmissionWebhookServer) Run() error {
	pair, err := tls.LoadX509KeyPair(s.cfg.TlsCert, s.cfg.TlsKey)
	if err != nil {
		return err
	}
	srv := &http.Server{
		Addr:    fmt.Sprintf("%s:%d", s.cfg.ListenAddr, s.cfg.ListenPort),
		Handler: s.HttpHandler,
		TLSConfig: &tls.Config{ // nolint
			Certificates: []tls.Certificate{pair},
		},
	}
	go func() {
		for {
			time.Sleep(3 * time.Second)
			if recoverErr := s.recoverApplicationOperation(); recoverErr != nil {
				blog.Errorf("[recover] recover app operation failed: %s", recoverErr.Error())
			}
		}
	}()
	blog.Infof("Server serving on: %s:%d", s.cfg.ListenAddr, s.cfg.ListenPort)
	if err := srv.ListenAndServeTLS("", ""); err != nil {
		return err
	}
	return nil
}

func (s *AdmissionWebhookServer) webhookAllow(ctx *gin.Context, allowed bool, reqUID types.UID, errMsg string) {
	ctx.JSON(http.StatusOK, &v1.AdmissionReview{
		Response: &v1.AdmissionResponse{
			UID:     reqUID,
			Allowed: allowed,
			Result: &metav1.Status{
				Message: errMsg,
			},
		},
	})
}

func (s *AdmissionWebhookServer) registerRouter() {
	s.HttpHandler.Any("/check", s.check)
}

func (s *AdmissionWebhookServer) check(ctx *gin.Context) {
	ar := new(v1.AdmissionReview)
	if err := ctx.BindJSON(ar); err != nil {
		blog.Errorf("marshal request body failed, err: %s", err.Error())
		s.webhookAllow(ctx, true, "", "")
		return
	}
	// Check request whether is nil.
	req := ar.Request
	if req == nil {
		blog.Errorf("request is nil")
		s.webhookAllow(ctx, true, "", "")
		return
	}

	if req.Kind.Kind != application.ApplicationKind {
		s.webhookAllow(ctx, true, req.UID, "")
		return
	}
	switch req.Operation {
	case v1.Create:
		blog.Infof("Received request. UID: %s, Name: %s, Operation: %s, Kind: %v.", req.UID, req.Name,
			req.Operation, req.Kind)
		// check application-create which belong to appset
		if err := s.checkApplication(ctx, req.Object.Raw); err != nil {
			blog.Errorf("UID: %s, check application failed: %s", req.UID, err.Error())
			s.webhookAllow(ctx, false, req.UID, err.Error())
			return
		}
	case v1.Update:
		if err := s.interceptApplicationSync(ctx, req); err != nil {
			blog.Errorf("UID: %s, intercept application sync failed: %s", req.UID, err.Error())
			s.webhookAllow(ctx, false, req.UID, err.Error())
			return
		}
	}
	s.webhookAllow(ctx, true, req.UID, "")
}

var (
	defaultTimeout = 15 * time.Second
)

// checkApplication the application which belong-to appset
// nolint funlen
func (s *AdmissionWebhookServer) checkApplication(ctx context.Context, bs []byte) error {
	app := new(v1alpha1.Application)
	if err := json.Unmarshal(bs, app); err != nil {
		return errors.Wrapf(err, "unmarshal failed with '%s'", string(bs))
	}
	belongApplicationSet := false
	var appsetName string
	for i := range app.ObjectMeta.OwnerReferences {
		owner := app.ObjectMeta.OwnerReferences[i]
		if owner.Kind == "ApplicationSet" {
			belongApplicationSet = true
			appsetName = owner.Name
			break
		}
	}
	if !belongApplicationSet {
		blog.Infof("application '%s' not belong to applicationset, ignore it", app.Name)
		return nil
	}
	if appsetName == "" {
		return errors.Errorf("application '%s' belong to appset, but appset name is empty", app.Name)
	}
	proj := app.Spec.Project
	cxt, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()
	argoProj, err := s.argoStore.GetProject(cxt, proj)
	if err != nil {
		return errors.Wrapf(err, "get project '%s' failed", proj)
	}
	if argoProj == nil {
		return errors.Errorf("project '%s' not exist", proj)
	}

	// check app whether belong to appset
	var repoBelong bool
	var repoProj string
	if app.Spec.HasMultipleSources() {
		for i := range app.Spec.Sources {
			appSource := app.Spec.Sources[i]
			repoUrl := appSource.RepoURL
			repoProj, repoBelong, err = s.checkRepositoryBelongProject(ctx, repoUrl, proj)
			if err != nil {
				return errors.Wrapf(err, "check repo '%s' belong to project '%s' failed", repoUrl, repoProj)
			}
			if !repoBelong {
				return errors.Errorf("repo '%s' project is '%s', not same as '%s'", repoUrl, repoProj, proj)
			}
		}
	} else {
		repoUrl := app.Spec.Source.RepoURL
		repoProj, repoBelong, err = s.checkRepositoryBelongProject(ctx, repoUrl, proj)
		if err != nil {
			return errors.Wrapf(err, "check repo '%s' belong to project '%s' failed", repoUrl, repoProj)
		}
		if !repoBelong {
			return errors.Errorf("repo '%s' project is '%s', not same as '%s'", repoUrl, repoProj, proj)
		}
	}

	// check dest server is legal
	cls := app.Spec.Destination.Server
	var argoCls *v1alpha1.Cluster
	argoCls, err = s.argoStore.GetCluster(ctx, &clusterclient.ClusterQuery{
		Server: cls,
	})
	if err != nil {
		return errors.Wrapf(err, "get cluster '%s' failed", cls)
	}
	if argoCls == nil {
		return errors.Errorf("cluster '%s' not exist", cls)
	}
	if argoCls.Project != proj {
		return errors.Errorf("cluster '%s' project is '%s', not same as '%s'", cls, argoCls.Project, proj)
	}

	// check dest server belong to appset's cluster-scope
	appSetScope, err := s.db.GetAppSetClusterScope(appsetName)
	if err != nil {
		return errors.Wrapf(err, "get appset '%s' cluster-scope from db failed", appsetName)
	}
	if appSetScope != nil && appSetScope.Clusters != "" {
		clusters := strings.Split(appSetScope.Clusters, ",")
		if !slices.Contains(clusters, argoCls.Name) {
			return errors.Errorf("application '%s' dest server '%s' not belong appset's cluster-scope [%s]",
				app.Name, argoCls.Name, appSetScope.Clusters)
		}
	}
	blog.Infof("check application '%s' success", app.Name)
	return nil
}

func (s *AdmissionWebhookServer) checkRepositoryBelongProject(ctx context.Context, repoUrl,
	project string) (string, bool, error) {
	repo, err := s.argoStore.GetRepository(ctx, repoUrl)
	if err != nil {
		return "", false, errors.Wrapf(err, "get repo '%s' failed", repoUrl)
	}
	if repo == nil {
		return "", false, fmt.Errorf("repo '%s' not found", repoUrl)
	}
	belong := repo.Project == project
	if !belong {
		belong = slices.Contains(s.cfg.PublicProjects, repo.Project)
	}
	return repo.Project, belong, nil
}

func (s *AdmissionWebhookServer) needInterceptAppSync(req *v1.AdmissionRequest) *v1alpha1.Application {
	app := new(v1alpha1.Application)
	if err := json.Unmarshal(req.Object.Raw, app); err != nil {
		blog.Errorf("unmarshal application failed: %s", err.Error())
		return nil
	}
	if len(s.cfg.InterceptSyncProjects) == 0 {
		return nil
	}
	if !slices.Contains(s.cfg.InterceptSyncProjects, app.Spec.Project) {
		return nil
	}
	blog.Infof("Received request. UID: %s, Name: %s, Operation: %s, Kind: %v.", req.UID, req.Name,
		req.Operation, req.Kind)
	state := app.Status.OperationState
	// 如果应用状态非 Running, 则表示不在 Sync 进程中，直接返回
	if state == nil || state.Phase != synccommon.OperationRunning {
		return nil
	}
	return app
}

func (s *AdmissionWebhookServer) checkApplicationBelongAppSet(ctx context.Context,
	app *v1alpha1.Application) *v1alpha1.ApplicationSet {
	var belongAppSet bool
	var appSetName string
	for i := range app.ObjectMeta.OwnerReferences {
		owner := app.ObjectMeta.OwnerReferences[i]
		if owner.Kind == "ApplicationSet" {
			belongAppSet = true
			appSetName = owner.Name
			break
		}
	}
	if !belongAppSet || appSetName == "" {
		return nil
	}
	appSet, err := s.argoStore.GetApplicationSet(ctx, appSetName)
	if err != nil {
		blog.Errorf("get application '%s' owner appset '%s' failed: %s", app.Name, appSetName, err.Error())
		return nil
	}
	if appSet == nil {
		blog.Errorf("get application '%s' owner appset '%s' is empty", app.Name, appSetName)
		return nil
	}
	return appSet
}

func (s *AdmissionWebhookServer) interceptApplicationSync(ctx context.Context, req *v1.AdmissionRequest) error {
	app := s.needInterceptAppSync(req)
	if app == nil {
		return nil
	}
	appSet := s.checkApplicationBelongAppSet(ctx, app)
	if appSet == nil {
		return nil
	}
	appSetTemplate := appSet.Spec.Template
	hasDynamicRevision := false
	// 如果 AppSet 的 Template 中 revision 不是动态的，则我们不进行处理
	if appSetTemplate.Spec.HasMultipleSources() {
		for i := range appSetTemplate.Spec.Sources {
			if strings.Contains(appSetTemplate.Spec.Sources[i].TargetRevision, "{") {
				hasDynamicRevision = true
				break
			}
		}
	} else if strings.Contains(appSetTemplate.Spec.Source.TargetRevision, "{") {
		hasDynamicRevision = true
	}
	if !hasDynamicRevision {
		blog.Infof("intercept application '%s' sync, it's appset '%s' not have dynamic revision",
			app.Name, appSet.Name)
		return nil
	}
	apps, err := s.argoStore.ApplicationSetDryRun(appSet)
	if err != nil {
		blog.Errorf("intercept application '%s' sync, it's appset '%s' dry-run failed: %s",
			app.Name, appSet.Name, err.Error())
		return nil
	}
	var foundApp *v1alpha1.Application
	for i := range apps {
		if apps[i].Name != app.Name {
			continue
		}
		foundApp = apps[i]
		break
	}
	if foundApp == nil {
		blog.Warnf("intercept application '%s' sync, it's appset '%s' dry-run not have app", app.Name, appSet.Name)
		return nil
	}

	// 对比 AppSet dry-run 出来的应用和当前应用的 revision 是否一致
	if foundApp.Spec.HasMultipleSources() {
		for i := range foundApp.Spec.Sources {
			newSource := foundApp.Spec.Sources[i]
			appSource := foundApp.Spec.Sources[i]
			if newSource.TargetRevision == appSource.TargetRevision {
				continue
			}
			return errors.Errorf("reject the app_sync, because currrent application sources[%d].targetRevision=%s, "+
				"not same as the app generated by appset '%s'", i, appSource.TargetRevision, newSource.TargetRevision)
		}
	} else {
		appRevision := app.Spec.Source.TargetRevision
		newRevision := foundApp.Spec.Source.TargetRevision
		if appRevision != newRevision {
			return errors.Errorf("reject the app_sync, because current application source.targetRevision=%s, "+
				"not same as the app generated by appset '%s'", app.Spec.Source.TargetRevision,
				foundApp.Spec.Source.TargetRevision)
		}
	}
	blog.Infof("intercept application '%s' sync, the revision generate by appset is same", app.Name)
	return nil
}

// recoverApplicationOperation 补偿 application.operation 被 argocd 未知删除问题
// 通过检查应用是否仍在同步进程中（status.operationState.Phase == Running），如果应用在同步进程中
// 但是 application.operation 是空的，通过 Patch 的方式恢复 application.operation
// refer to: https://github.com/argoproj/argo-cd/issues/17155
func (s *AdmissionWebhookServer) recoverApplicationOperation() error {
	argoK8SClient := s.argoStore.ReturnArgoK8SClient()
	watchInter, err := argoK8SClient.Applications(s.cfg.AdminNamespace).Watch(context.Background(), metav1.ListOptions{})
	if err != nil {
		return errors.Wrapf(err, "create application watch failed")
	}
	defer watchInter.Stop()
	var recoverProjects []string
	if s.cfg.RecoverProjects != "" {
		recoverProjects = strings.Split(s.cfg.RecoverProjects, ",")
	}
	blog.Infof("[recover] create application watch success")
	defer blog.Errorf("[recover] application watch channel closed")
	for e := range watchInter.ResultChan() {
		if e.Type != watch.Modified {
			continue
		}
		if e.Object == nil {
			continue
		}
		obj := e.Object.DeepCopyObject()
		argoApp, ok := obj.(*v1alpha1.Application)
		if !ok {
			continue
		}
		if len(recoverProjects) != 0 && !slices.Contains(recoverProjects, argoApp.Spec.Project) {
			continue
		}
		if argoApp.Operation != nil {
			continue
		}
		if argoApp.Status.OperationState == nil {
			continue
		}
		opState := argoApp.Status.OperationState
		if opState.Phase != synccommon.OperationRunning {
			continue
		}
		var patchJSON []byte
		patchJSON, err = json.Marshal(opState.Operation)
		if err != nil {
			blog.Errorf("[recover] app '%s' operation marshal failed: %s", argoApp.Name, err.Error())
			continue
		}
		resultPatch := fmt.Sprintf(`{"operation":%s}`, string(patchJSON))
		blog.Infof("[recover] app '%s' patch app.operation: %s", argoApp.Name, resultPatch)
		_, err = argoK8SClient.Applications(s.cfg.AdminNamespace).Patch(context.Background(), argoApp.Name,
			types.MergePatchType, []byte(resultPatch), metav1.PatchOptions{})
		if err != nil {
			blog.Errorf("[recover] app '%s' patch app.operation failed: %s", argoApp.Name, err.Error())
		} else {
			blog.Infof("[recover] app '%s' patch app.operation success", argoApp.Name)
		}
	}
	return nil
}
