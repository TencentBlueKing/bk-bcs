/*
 * Tencent is pleased to support the open source community by making Blueking Container Service available.
 * Copyright (C) 2019 THL A29 Limited, a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package webhook xxx
package webhook

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/Tencent/bk-bcs/bcs-common/common/blog"
	clusterclient "github.com/argoproj/argo-cd/v2/pkg/apiclient/cluster"
	"github.com/argoproj/argo-cd/v2/pkg/apis/application"
	"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1"
	synccommon "github.com/argoproj/gitops-engine/pkg/sync/common"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	v1 "k8s.io/api/admission/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/utils/strings/slices"

	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/cmd/gitgenerator-webhook/options"
	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/internal/dao"
	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/pkg/store"
)

// AdmissionWebhookServer defines the webhook server to check application
// generated by git-generator
type AdmissionWebhookServer struct {
	HttpHandler *gin.Engine
	cfg         *options.Config
	argoStore   store.Store
	db          dao.Interface
}

// NewAdmissionWebhookServer create the webhook-server instance
func NewAdmissionWebhookServer(cfg *options.Config) *AdmissionWebhookServer {
	gin.SetMode(gin.ReleaseMode)
	r := gin.New()
	r.Use(gin.Recovery())
	server := &AdmissionWebhookServer{
		cfg:         cfg,
		HttpHandler: r,
	}
	server.registerRouter()
	return server
}

// Init will init the argocd client
func (s *AdmissionWebhookServer) Init() error {
	s.argoStore = store.NewStore(&store.Options{
		Service:      s.cfg.ArgoService,
		User:         s.cfg.ArgoUser,
		Pass:         s.cfg.ArgoPass,
		Cache:        false,
		CacheHistory: false,
	})
	var err error
	s.db, err = dao.NewDriver(&s.cfg.DBConfig)
	if err != nil {
		return errors.Wrapf(err, "init database failed")
	}
	if err = s.argoStore.Init(); err != nil {
		return errors.Wrapf(err, "init argocd stroe failed")
	}
	return nil
}

// Run the webhook server with http export
func (s *AdmissionWebhookServer) Run() error {
	pair, err := tls.LoadX509KeyPair(s.cfg.TlsCert, s.cfg.TlsKey)
	if err != nil {
		return err
	}
	srv := &http.Server{
		Addr:    fmt.Sprintf("%s:%d", s.cfg.ListenAddr, s.cfg.ListenPort),
		Handler: s.HttpHandler,
		TLSConfig: &tls.Config{ // nolint
			Certificates: []tls.Certificate{pair},
		},
	}
	go func() {
		for {
			time.Sleep(3 * time.Second)
			if recoverErr := s.recoverApplicationOperation(); recoverErr != nil {
				blog.Errorf("[recover] recover app operation failed: %s", recoverErr.Error())
			}
		}
	}()
	blog.Infof("Server serving on: %s:%d", s.cfg.ListenAddr, s.cfg.ListenPort)
	if err := srv.ListenAndServeTLS("", ""); err != nil {
		return err
	}
	return nil
}

func (s *AdmissionWebhookServer) webhookAllow(ctx *gin.Context, allowed bool, reqUID types.UID, errMsg string) {
	ctx.JSON(http.StatusOK, &v1.AdmissionReview{
		Response: &v1.AdmissionResponse{
			UID:     reqUID,
			Allowed: allowed,
			Result: &metav1.Status{
				Message: errMsg,
			},
		},
	})
}

func (s *AdmissionWebhookServer) registerRouter() {
	s.HttpHandler.Any("/check", s.check)
}

func (s *AdmissionWebhookServer) check(ctx *gin.Context) {
	ar := new(v1.AdmissionReview)
	if err := ctx.BindJSON(ar); err != nil {
		blog.Errorf("marshal request body failed, err: %s", err.Error())
		s.webhookAllow(ctx, true, "", "")
		return
	}
	// Check request whether is nil.
	req := ar.Request
	if req == nil {
		blog.Errorf("request is nil")
		s.webhookAllow(ctx, true, "", "")
		return
	}
	blog.Infof("Received request. UID: %s, Name: %s, Operation: %s, Kind: %v.", req.UID, req.Name,
		req.Operation, req.Kind)

	if req.Kind.Kind != application.ApplicationKind {
		s.webhookAllow(ctx, true, req.UID, "")
		return
	}
	if req.Operation == v1.Create {
		// check application-create which belong to appset
		if err := s.checkApplication(ctx, req.Object.Raw); err != nil {
			blog.Errorf("UID: %s, check application failed: %s", req.UID, err.Error())
			s.webhookAllow(ctx, false, req.UID, err.Error())
			return
		}
	}
	s.webhookAllow(ctx, true, req.UID, "")
}

var (
	defaultTimeout = 15 * time.Second
)

// checkApplication the application which belong-to appset
// nolint funlen
func (s *AdmissionWebhookServer) checkApplication(ctx context.Context, bs []byte) error {
	app := new(v1alpha1.Application)
	if err := json.Unmarshal(bs, app); err != nil {
		return errors.Wrapf(err, "unmarshal failed with '%s'", string(bs))
	}
	belongApplicationSet := false
	var appsetName string
	for i := range app.ObjectMeta.OwnerReferences {
		owner := app.ObjectMeta.OwnerReferences[i]
		if owner.Kind == "ApplicationSet" {
			belongApplicationSet = true
			appsetName = owner.Name
			break
		}
	}
	if !belongApplicationSet {
		blog.Infof("application '%s' not belong to applicationset, ignore it", app.Name)
		return nil
	}
	if appsetName == "" {
		return errors.Errorf("application '%s' belong to appset, but appset name is empty", app.Name)
	}
	proj := app.Spec.Project
	cxt, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()
	argoProj, err := s.argoStore.GetProject(cxt, proj)
	if err != nil {
		return errors.Wrapf(err, "get project '%s' failed", proj)
	}
	if argoProj == nil {
		return errors.Errorf("project '%s' not exist", proj)
	}

	// check app whether belong to appset
	var repoBelong bool
	var repoProj string
	if app.Spec.HasMultipleSources() {
		for i := range app.Spec.Sources {
			appSource := app.Spec.Sources[i]
			repoUrl := appSource.RepoURL
			repoProj, repoBelong, err = s.checkRepositoryBelongProject(ctx, repoUrl, proj)
			if err != nil {
				return errors.Wrapf(err, "check repo '%s' belong to project '%s' failed", repoUrl, repoProj)
			}
			if !repoBelong {
				return errors.Errorf("repo '%s' project is '%s', not same as '%s'", repoUrl, repoProj, proj)
			}
		}
	} else {
		repoUrl := app.Spec.Source.RepoURL
		repoProj, repoBelong, err = s.checkRepositoryBelongProject(ctx, repoUrl, proj)
		if err != nil {
			return errors.Wrapf(err, "check repo '%s' belong to project '%s' failed", repoUrl, repoProj)
		}
		if !repoBelong {
			return errors.Errorf("repo '%s' project is '%s', not same as '%s'", repoUrl, repoProj, proj)
		}
	}

	// check dest server is legal
	cls := app.Spec.Destination.Server
	var argoCls *v1alpha1.Cluster
	argoCls, err = s.argoStore.GetCluster(ctx, &clusterclient.ClusterQuery{
		Server: cls,
	})
	if err != nil {
		return errors.Wrapf(err, "get cluster '%s' failed", cls)
	}
	if argoCls == nil {
		return errors.Errorf("cluster '%s' not exist", cls)
	}
	if argoCls.Project != proj {
		return errors.Errorf("cluster '%s' project is '%s', not same as '%s'", cls, argoCls.Project, proj)
	}

	// check dest server belong to appset's cluster-scope
	appSetScope, err := s.db.GetAppSetClusterScope(appsetName)
	if err != nil {
		return errors.Wrapf(err, "get appset '%s' cluster-scope from db failed", appsetName)
	}
	if appSetScope != nil && appSetScope.Clusters != "" {
		clusters := strings.Split(appSetScope.Clusters, ",")
		if !slices.Contains(clusters, argoCls.Name) {
			return errors.Errorf("application '%s' dest server '%s' not belong appset's cluster-scope [%s]",
				app.Name, argoCls.Name, appSetScope.Clusters)
		}
	}
	blog.Infof("check application '%s' success", app.Name)
	return nil
}

func (s *AdmissionWebhookServer) checkRepositoryBelongProject(ctx context.Context, repoUrl,
	project string) (string, bool, error) {
	repo, err := s.argoStore.GetRepository(ctx, repoUrl)
	if err != nil {
		return "", false, errors.Wrapf(err, "get repo '%s' failed", repoUrl)
	}
	if repo == nil {
		return "", false, fmt.Errorf("repo '%s' not found", repoUrl)
	}
	belong := repo.Project == project
	if !belong {
		belong = slices.Contains(s.cfg.PublicProjects, repo.Project)
	}
	return repo.Project, belong, nil
}

// recoverApplicationOperation 补偿 application.operation 被 argocd 未知删除问题
// 通过检查应用是否仍在同步进程中（status.operationState.Phase == Running），如果应用在同步进程中
// 但是 application.operation 是空的，通过 Patch 的方式恢复 application.operation
// refer to: https://github.com/argoproj/argo-cd/issues/17155
func (s *AdmissionWebhookServer) recoverApplicationOperation() error {
	argoK8SClient := s.argoStore.ReturnArgoK8SClient()
	watchInter, err := argoK8SClient.Applications(s.cfg.AdminNamespace).Watch(context.Background(), metav1.ListOptions{})
	if err != nil {
		return errors.Wrapf(err, "create application watch failed")
	}
	defer watchInter.Stop()
	var recoverProjects []string
	if s.cfg.RecoverProjects != "" {
		recoverProjects = strings.Split(s.cfg.RecoverProjects, ",")
	}
	blog.Infof("[recover] create application watch success")
	defer blog.Errorf("[recover] application watch channel closed")
	for e := range watchInter.ResultChan() {
		if e.Type != watch.Modified {
			continue
		}
		if e.Object == nil {
			continue
		}
		obj := e.Object.DeepCopyObject()
		argoApp, ok := obj.(*v1alpha1.Application)
		if !ok {
			continue
		}
		if len(recoverProjects) != 0 && !slices.Contains(recoverProjects, argoApp.Spec.Project) {
			continue
		}
		if argoApp.Operation != nil {
			continue
		}
		if argoApp.Status.OperationState == nil {
			continue
		}
		opState := argoApp.Status.OperationState
		if opState.Phase != synccommon.OperationRunning {
			continue
		}
		var patchJSON []byte
		patchJSON, err = json.Marshal(opState.Operation)
		if err != nil {
			blog.Errorf("[recover] app '%s' operation marshal failed: %s", argoApp.Name, err.Error())
			continue
		}
		resultPatch := fmt.Sprintf(`{"operation":%s}`, string(patchJSON))
		blog.Infof("[recover] app '%s' patch app.operation: %s", argoApp.Name, resultPatch)
		_, err = argoK8SClient.Applications(s.cfg.AdminNamespace).Patch(context.Background(), argoApp.Name,
			types.MergePatchType, []byte(resultPatch), metav1.PatchOptions{})
		if err != nil {
			blog.Errorf("[recover] app '%s' patch app.operation failed: %s", argoApp.Name, err.Error())
		} else {
			blog.Infof("[recover] app '%s' patch app.operation success", argoApp.Name)
		}
	}
	return nil
}
