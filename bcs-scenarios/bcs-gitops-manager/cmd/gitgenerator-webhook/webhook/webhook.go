/*
 * Tencent is pleased to support the open source community by making Blueking Container Service available.
 * Copyright (C) 2019 THL A29 Limited, a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package webhook xxx
package webhook

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/Tencent/bk-bcs/bcs-common/common/blog"
	applicationpkg "github.com/argoproj/argo-cd/v2/pkg/apiclient/application"
	clusterclient "github.com/argoproj/argo-cd/v2/pkg/apiclient/cluster"
	"github.com/argoproj/argo-cd/v2/pkg/apis/application"
	"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1"
	synccommon "github.com/argoproj/gitops-engine/pkg/sync/common"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	v1 "k8s.io/api/admission/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/utils/strings/slices"

	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/cmd/gitgenerator-webhook/options"
	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/internal/dao"
	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/pkg/common"
	"github.com/Tencent/bk-bcs/bcs-scenarios/bcs-gitops-manager/pkg/store"
)

// AdmissionWebhookServer defines the webhook server to check application
// generated by git-generator
type AdmissionWebhookServer struct {
	HttpHandler *gin.Engine
	cfg         *options.Config
	argoStore   store.Store
	db          dao.Interface
}

// NewAdmissionWebhookServer create the webhook-server instance
func NewAdmissionWebhookServer(cfg *options.Config) *AdmissionWebhookServer {
	gin.SetMode(gin.ReleaseMode)
	r := gin.New()
	r.Use(gin.Recovery())
	server := &AdmissionWebhookServer{
		cfg:         cfg,
		HttpHandler: r,
	}
	server.registerRouter()
	return server
}

// Init will init the argocd client
func (s *AdmissionWebhookServer) Init() error {
	s.argoStore = store.NewStore(&store.Options{
		Service:       s.cfg.ArgoService,
		User:          s.cfg.ArgoUser,
		Pass:          s.cfg.ArgoPass,
		Cache:         true,
		CacheHistory:  false,
		RepoServerUrl: s.cfg.ArgoRepoUrl,
	})
	var err error
	s.db, err = dao.NewDriver(&s.cfg.DBConfig)
	if err != nil {
		return errors.Wrapf(err, "init database failed")
	}
	if err = s.argoStore.Init(); err != nil {
		return errors.Wrapf(err, "init argocd stroe failed")
	}
	if err = s.argoStore.InitArgoDB(context.Background()); err != nil {
		return errors.Wrapf(err, "init argocd db failed")
	}
	return nil
}

// Run the webhook server with http export
func (s *AdmissionWebhookServer) Run() error {
	pair, err := tls.LoadX509KeyPair(s.cfg.TlsCert, s.cfg.TlsKey)
	if err != nil {
		return err
	}
	srv := &http.Server{
		Addr:    fmt.Sprintf("%s:%d", s.cfg.ListenAddr, s.cfg.ListenPort),
		Handler: s.HttpHandler,
		TLSConfig: &tls.Config{ // nolint
			Certificates: []tls.Certificate{pair},
		},
	}
	go s.recoverApplicationOperation()
	blog.Infof("Server serving on: %s:%d", s.cfg.ListenAddr, s.cfg.ListenPort)
	if err := srv.ListenAndServeTLS("", ""); err != nil {
		return err
	}
	return nil
}

func (s *AdmissionWebhookServer) webhookAllow(ctx *gin.Context, allowed bool, reqUID types.UID, errMsg string) {
	ctx.JSON(http.StatusOK, &v1.AdmissionReview{
		Response: &v1.AdmissionResponse{
			UID:     reqUID,
			Allowed: allowed,
			Result: &metav1.Status{
				Message: errMsg,
			},
		},
	})
}

func (s *AdmissionWebhookServer) registerRouter() {
	s.HttpHandler.Any("/check", s.check)
}

func (s *AdmissionWebhookServer) check(ctx *gin.Context) {
	ar := new(v1.AdmissionReview)
	if err := ctx.BindJSON(ar); err != nil {
		blog.Errorf("marshal request body failed, err: %s", err.Error())
		s.webhookAllow(ctx, true, "", "")
		return
	}
	// Check request whether is nil.
	req := ar.Request
	if req == nil {
		blog.Errorf("request is nil")
		s.webhookAllow(ctx, true, "", "")
		return
	}

	if req.Kind.Kind != application.ApplicationKind {
		s.webhookAllow(ctx, true, req.UID, "")
		return
	}
	switch req.Operation {
	case v1.Create:
		blog.Infof("Received request. UID: %s, Name: %s, Operation: %s, Kind: %v.", req.UID, req.Name,
			req.Operation, req.Kind)
		// check application-create which belong to appset
		if err := s.checkApplication(ctx, req.Object.Raw); err != nil {
			blog.Errorf("UID: %s, check application failed: %s", req.UID, err.Error())
			s.webhookAllow(ctx, false, req.UID, err.Error())
			return
		}
	case v1.Update:
		if err := s.interceptAppSyncWithForbid(ctx, req); err != nil {
			blog.Errorf("UID: %s, intercept application sync with forbidden flag failed: %s",
				req.UID, err.Error())
			s.webhookAllow(ctx, false, req.UID, err.Error())
			return
		}
		if err := s.interceptApplicationSync(ctx, req); err != nil {
			blog.Errorf("UID: %s, intercept application sync: %s", req.UID, err.Error())
			s.webhookAllow(ctx, false, req.UID, err.Error())
			return
		}
	}
	s.webhookAllow(ctx, true, req.UID, "")
}

var (
	defaultTimeout = 15 * time.Second
)

// checkApplication the application which belong-to appset
// nolint funlen
func (s *AdmissionWebhookServer) checkApplication(ctx context.Context, bs []byte) error {
	app := new(v1alpha1.Application)
	if err := json.Unmarshal(bs, app); err != nil {
		return errors.Wrapf(err, "unmarshal failed with '%s'", string(bs))
	}
	belongApplicationSet := false
	var appsetName string
	for i := range app.ObjectMeta.OwnerReferences {
		owner := app.ObjectMeta.OwnerReferences[i]
		if owner.Kind == "ApplicationSet" {
			belongApplicationSet = true
			appsetName = owner.Name
			break
		}
	}
	if !belongApplicationSet {
		blog.Infof("application '%s' not belong to applicationset, ignore it", app.Name)
		return nil
	}
	if appsetName == "" {
		return errors.Errorf("application '%s' belong to appset, but appset name is empty", app.Name)
	}
	proj := app.Spec.Project
	cxt, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()
	argoProj, err := s.argoStore.GetProject(cxt, proj)
	if err != nil {
		return errors.Wrapf(err, "get project '%s' failed", proj)
	}
	if argoProj == nil {
		return errors.Errorf("project '%s' not exist", proj)
	}
	if err = s.checkAppRepoBelongProject(ctx, proj, app); err != nil {
		return err
	}

	// check dest server is legal
	cls := app.Spec.Destination.Server
	var argoCls *v1alpha1.Cluster
	argoCls, err = s.argoStore.GetCluster(ctx, &clusterclient.ClusterQuery{
		Server: cls,
	})
	if err != nil {
		return errors.Wrapf(err, "get cluster '%s' failed", cls)
	}
	if argoCls == nil {
		return errors.Errorf("cluster '%s' not exist", cls)
	}
	if argoCls.Project != proj {
		return errors.Errorf("cluster '%s' project is '%s', not same as '%s'", cls, argoCls.Project, proj)
	}

	// check dest server belong to appset's cluster-scope
	appSetScope, err := s.db.GetAppSetClusterScope(appsetName)
	if err != nil {
		return errors.Wrapf(err, "get appset '%s' cluster-scope from db failed", appsetName)
	}
	if appSetScope != nil && appSetScope.Clusters != "" {
		clusters := strings.Split(appSetScope.Clusters, ",")
		if !slices.Contains(clusters, argoCls.Name) {
			return errors.Errorf("application '%s' dest server '%s' not belong appset's cluster-scope [%s]",
				app.Name, argoCls.Name, appSetScope.Clusters)
		}
	}
	blog.Infof("check application '%s' success", app.Name)
	return nil
}

func (s *AdmissionWebhookServer) checkAppRepoBelongProject(ctx context.Context, proj string,
	app *v1alpha1.Application) error {
	if !app.Spec.HasMultipleSources() {
		repoUrl := app.Spec.Source.RepoURL
		repoProj, repoBelong, err := s.checkRepositoryBelongProject(ctx, repoUrl, proj)
		if err != nil {
			return errors.Wrapf(err, "check repo '%s' belong to project '%s' failed", repoUrl, repoProj)
		}
		if !repoBelong {
			return errors.Errorf("repo '%s' project is '%s', not same as '%s'", repoUrl, repoProj, proj)
		}
	}
	for i := range app.Spec.Sources {
		appSource := app.Spec.Sources[i]
		repoUrl := appSource.RepoURL
		repoProj, repoBelong, err := s.checkRepositoryBelongProject(ctx, repoUrl, proj)
		if err != nil {
			return errors.Wrapf(err, "check repo '%s' belong to project '%s' failed", repoUrl, repoProj)
		}
		if !repoBelong {
			return errors.Errorf("repo '%s' project is '%s', not same as '%s'", repoUrl, repoProj, proj)
		}
	}
	return nil
}

func (s *AdmissionWebhookServer) checkRepositoryBelongProject(ctx context.Context, repoUrl,
	project string) (string, bool, error) {
	repo, err := s.argoStore.GetRepository(ctx, repoUrl)
	if err != nil {
		return "", false, errors.Wrapf(err, "get repo '%s' failed", repoUrl)
	}
	if repo == nil {
		return "", false, fmt.Errorf("repo '%s' not found", repoUrl)
	}
	belong := repo.Project == project
	if !belong {
		belong = slices.Contains(s.cfg.PublicProjects, repo.Project)
	}
	return repo.Project, belong, nil
}

func (s *AdmissionWebhookServer) unmarshalAppFromReq(req *v1.AdmissionRequest) (*v1alpha1.Application, error) {
	app := new(v1alpha1.Application)
	if err := json.Unmarshal(req.Object.Raw, app); err != nil {
		return nil, errors.Wrap(err, "unmarshal application failed")
	}
	return app, nil
}

func (s *AdmissionWebhookServer) needInterceptAppSync(req *v1.AdmissionRequest) *v1alpha1.Application {
	app, err := s.unmarshalAppFromReq(req)
	if err != nil {
		blog.Errorf("not need intercept because unmarshal app error")
		return nil
	}
	if len(s.cfg.InterceptSyncProjects) == 0 {
		return nil
	}
	if !slices.Contains(s.cfg.InterceptSyncProjects, app.Spec.Project) {
		return nil
	}
	state := app.Status.OperationState
	// 如果应用状态非 Running, 则表示不在 Sync 进程中，直接返回
	if state == nil || state.Phase != synccommon.OperationRunning {
		return nil
	}
	if app.Status.Sync.Revision == "" && len(app.Status.Sync.Revisions) == 0 {
		return nil
	}
	if app.Operation == nil {
		return nil
	}
	blog.Infof("Received request(intercept sync). UID: %s, Name: %s, Operation: %s, Kind: %v. Sync revisions: %s, %v",
		req.UID, req.Name, req.Operation, req.Kind, app.Status.Sync.Revision, app.Status.Sync.Revisions)
	return app
}

func (s *AdmissionWebhookServer) checkApplicationBelongAppSet(ctx context.Context,
	app *v1alpha1.Application) *v1alpha1.ApplicationSet {
	var belongAppSet bool
	var appSetName string
	for i := range app.ObjectMeta.OwnerReferences {
		owner := app.ObjectMeta.OwnerReferences[i]
		if owner.Kind == "ApplicationSet" {
			belongAppSet = true
			appSetName = owner.Name
			break
		}
	}
	if !belongAppSet || appSetName == "" {
		return nil
	}
	appSet, err := s.argoStore.GetApplicationSet(ctx, appSetName)
	if err != nil {
		blog.Errorf("get application '%s' owner appset '%s' failed: %s", app.Name, appSetName, err.Error())
		return nil
	}
	if appSet == nil {
		blog.Errorf("get application '%s' owner appset '%s' is empty", app.Name, appSetName)
		return nil
	}
	return appSet
}

func (s *AdmissionWebhookServer) interceptAppSyncWithForbid(ctx context.Context,
	req *v1.AdmissionRequest) error {
	// 如果设置了禁止同步标记，就直接拒绝同步
	reqApp, err := s.unmarshalAppFromReq(req)
	if err != nil {
		blog.Errorf("not need intercept with forbidden flag because unmarshal application request error")
		return nil
	}
	// 如果没有设置app的operation,就忽略
	if reqApp.Operation == nil {
		return nil
	}
	app, err := s.argoStore.GetApplication(ctx, req.Name)
	if err != nil {
		blog.Errorf("not need intercept with forbidden flag because get application error")
		return nil
	}
	// 如果要更新common.ApplicationSyncForbidden就不拒绝
	if _, reqExistForbidden := reqApp.Annotations[common.ApplicationSyncForbidden]; !reqExistForbidden {
		return nil
	}
	_, existForbidden := app.Annotations[common.ApplicationSyncForbidden]
	if existForbidden {
		return errors.Errorf(
			`reject the app_sync, because current application.metadata.annotations has %s,
			 req annotations is '%v'`,
			common.ApplicationSyncForbidden, reqApp.Annotations)
	}
	return nil
}

// interceptApplicationSync 用于处理 appset 使用动态 TargetRevision 引发应用出现 2 次同步的问题
func (s *AdmissionWebhookServer) interceptApplicationSync(ctx context.Context, req *v1.AdmissionRequest) error {
	app := s.needInterceptAppSync(req)
	if app == nil {
		return nil
	}
	appSet := s.checkApplicationBelongAppSet(ctx, app)
	if appSet == nil {
		return nil
	}
	// 如果 AppSet 的 Template 中 revision 不是动态的，则我们不进行处理
	if !s.checkAppSetHasDynamicRevision(ctx, appSet, app.Name) {
		return nil
	}

	apps, err := s.argoStore.ApplicationSetDryRun(appSet)
	if err != nil {
		blog.Errorf("skip intercept application '%s' sync, it's appset '%s' dry-run failed: %s",
			app.Name, appSet.Name, err.Error())
		return nil
	}
	var generatedApp *v1alpha1.Application
	for i := range apps {
		if apps[i].Name != app.Name {
			continue
		}
		generatedApp = apps[i]
		break
	}
	if generatedApp == nil {
		blog.Warnf("skip intercept application '%s' sync, it's appset '%s' dry-run not have app",
			app.Name, appSet.Name)
		return nil
	}
	blog.Infof("intercept application '%s' sync, found the application after appset dry-run", app.Name)

	// 对比 AppSet dry-run 出来的应用和当前应用的 revision 是否一致
	originalSources := app.Spec.GetSources()
	generatedSources := generatedApp.Spec.GetSources()
	if len(originalSources) != len(generatedSources) {
		return nil
	}
	if app.Operation == nil {
		return nil
	}
	for i := range generatedSources {
		appSrc := &generatedSources[i]
		var originalRevision string
		var operationRevision string
		if app.Spec.HasMultipleSources() {
			originalRevision = app.Status.Sync.Revisions[i]
			operationRevision = app.Operation.Sync.Revisions[i]
		} else {
			originalRevision = app.Status.Sync.Revision
			operationRevision = app.Operation.Sync.Revision
		}
		if err = s.handleCompareApplicationSource(ctx, app.Name, originalRevision, operationRevision,
			appSrc); err != nil {
			if terminateErr := s.argoStore.TerminateAppOperation(ctx, &applicationpkg.OperationTerminateRequest{
				Name:         &app.Name,
				AppNamespace: &app.Namespace,
				Project:      &app.Spec.Project,
			}); terminateErr != nil {
				blog.Errorf("intercept application '%s' sync, terminate operation failed: %s", app.Name,
					terminateErr.Error())
			} else {
				blog.Infof("intercept application '%s' sync, terminate operation success", app.Name)
			}
			if patchErr := s.patchDeleteOperation(app); patchErr != nil {
				blog.Errorf("intercept application '%s' sync, patch delete operation failed: %s",
					app.Name, patchErr.Error())
			} else {
				blog.Infof("intercept application '%s' sync, patch delete operation success", app.Name)
			}
			return errors.Wrapf(err, "reject app-sync for '%s'", app.Name)
		}
	}
	blog.Infof("skip intercept application '%s' sync, the revision generate by appset is same. "+
		"revisions: %v, %v", app.Name, app.Status.Sync.Revision, app.Status.Sync.Revisions)
	return nil
}

func (s *AdmissionWebhookServer) patchDeleteOperation(app *v1alpha1.Application) error {
	if app.Operation == nil {
		return nil
	}
	argoK8SClient := s.argoStore.ReturnArgoK8SClient()
	_, err := argoK8SClient.Applications(s.cfg.AdminNamespace).Patch(context.Background(), app.Name,
		types.JSONPatchType, []byte(`[{"op":"remove","path":"/operation"}]`), metav1.PatchOptions{})
	if err != nil {
		return errors.Wrapf(err, "patch remove operation failed")
	}
	if _, err = argoK8SClient.Applications(s.cfg.AdminNamespace).Patch(context.Background(), app.Name,
		types.JSONPatchType, []byte(`[{"op":"replace","path":"/status/operationState/phase","value":"Succeeded"}]`),
		metav1.PatchOptions{}); err != nil {
		return errors.Wrapf(err, "patch change status.operationState.phase failed")
	}
	return nil
}

func (s *AdmissionWebhookServer) handleCompareApplicationSource(ctx context.Context, appName, originalRevision,
	operationRevision string, generateSource *v1alpha1.ApplicationSource) error {
	// generate-source perhaps not an actual commit-id
	generateSourceRevision, err := s.argoStore.GetRepoLastCommitID(ctx, generateSource.RepoURL,
		generateSource.TargetRevision)
	if err != nil {
		blog.Errorf("skip intercept application '%s' sync, get git revision failed for '%s, %s'",
			appName, generateSource.RepoURL, generateSource.TargetRevision)
		return nil
	}
	// sync-revision is an actual commit-id
	if !strings.HasPrefix(generateSourceRevision, originalRevision) {
		return errors.Errorf("original revision '%s' not same to generated-by-appset revision '%s'",
			originalRevision, generateSourceRevision)
	}
	if !strings.HasPrefix(generateSourceRevision, operationRevision) {
		return errors.Errorf("operation revision '%s' not same to generated-by-appset revision '%s'",
			originalRevision, generateSourceRevision)
	}
	return nil
}

func (s *AdmissionWebhookServer) checkAppSetHasDynamicRevision(ctx context.Context, appSet *v1alpha1.ApplicationSet,
	appName string) bool {
	appSetTemplate := appSet.Spec.Template
	hasDynamicRevision := false
	// 如果 AppSet 的 Template 中 revision 不是动态的，则我们不进行处理
	var staticSource *v1alpha1.ApplicationSource
	var staticIndex int
	if appSetTemplate.Spec.HasMultipleSources() {
		for i := range appSetTemplate.Spec.Sources {
			if strings.Contains(appSetTemplate.Spec.Sources[i].TargetRevision, "{") {
				hasDynamicRevision = true
				continue
			}
			staticSource = &appSetTemplate.Spec.Sources[i]
			staticIndex = i
		}
	} else if strings.Contains(appSetTemplate.Spec.Source.TargetRevision, "{") {
		hasDynamicRevision = true
	}
	if !hasDynamicRevision {
		blog.Infof("skip intercept application '%s' sync, it's appset '%s' not have dynamic revision",
			appName, appSet.Name)
		return false
	}
	blog.Infof("intercept application '%s' sync, it's appset '%s' has dynamic revision", appName, appSet.Name)
	if staticSource != nil {
		repo := staticSource.RepoURL
		revision := staticSource.TargetRevision
		lastCommitID, err := s.argoStore.GetRepoLastCommitID(ctx, repo, revision)
		if err != nil {
			hasDynamicRevision = false
			blog.Errorf("intercept application '%s' sync, get appset '%s' repo '%s/%s' last-commit failed: %s",
				appName, appSet.Name, repo, revision, err.Error())
		} else {
			blog.Infof("intercept application '%s' sync, get appset '%s' repo '%s/%s' last-commit success: %s",
				appName, appSet.Name, repo, revision, lastCommitID)
			appSet.Spec.Template.Spec.Sources[staticIndex].TargetRevision = lastCommitID
		}
	}
	return hasDynamicRevision
}

// recoverApplicationOperation 补偿 application.operation 被 argocd 未知删除问题
// 通过检查应用是否仍在同步进程中（status.operationState.Phase == Running），如果应用在同步进程中
// 但是 application.operation 是空的，通过触发同步的方式恢复 application.operation
// refer to: https://github.com/argoproj/argo-cd/issues/17155
func (s *AdmissionWebhookServer) recoverApplicationOperation() {
	var recoverProjects []string
	if s.cfg.RecoverProjects == "" {
		return
	}
	recoverProjects = strings.Split(s.cfg.RecoverProjects, ",")

	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()
	for range ticker.C {
		apps, err := s.argoStore.ListApplications(context.Background(), &applicationpkg.ApplicationQuery{
			Projects: recoverProjects,
		})
		blog.Infof("[recover] recover is running, got applications: %d", len(apps.Items))
		if err != nil {
			blog.Errorf("[recover] list applications failed: %s", err.Error())
			continue
		}
		for i := range apps.Items {
			app := apps.Items[i]
			if app.Operation != nil {
				continue
			}
			if app.Status.OperationState == nil {
				continue
			}
			opState := app.Status.OperationState
			if opState.Phase != synccommon.OperationRunning {
				continue
			}
			blog.Infof("[recover] app '%s' lost options, need re-sync it", app.Name)
			go func() {
				if syncErr := s.argoStore.SyncApplication(context.Background(), app.Name); syncErr != nil {
					blog.Errorf("[recover] app '%s' sync failed: %s", app.Name, syncErr.Error())
				} else {
					blog.Infof("[recover] app '%s' sync success", app.Name)
				}
			}()
		}
	}
}
