/*
 * Tencent is pleased to support the open source community by making Blueking Container Service available.
 * Copyright (C) 2019 THL A29 Limited, a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Code generated by protoc-gen-go.
// source: mesos/slave/containerizer.proto
// DO NOT EDIT!

/*
Package mesos_slave is a generated protocol buffer package.

It is generated from these files:
	mesos/slave/containerizer.proto
	mesos/slave/oversubscription.proto

It has these top-level messages:
	ContainerLimitation
	ContainerState
	ContainerRecoverInfo
	ContainerConfig
	ContainerLaunchInfo
	ContainerTermination
	QoSCorrection
*/
package slave

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import mesos "mesos"
import appc_spec "mesos/appc"
import docker_spec_v1 "mesos/docker"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// *
// Information when an executor is impacted by a resource limitation
// and should be terminated. Intended to support resources like memory
// where the Linux kernel may invoke the OOM killer, killing some/all
// of a container's processes.
type ContainerLimitation struct {
	// Resources that triggered the limitation.
	// NOTE: 'Resources' is used here because the resource may span
	// multiple roles (e.g. `"mem(*):1;mem(role):2"`).
	Resources []*mesos.Resource `protobuf:"bytes,1,rep,name=resources" json:"resources,omitempty"`
	// Description of the limitation.
	Message *string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	// The container will be terminated when a resource limitation is
	// reached. This field specifies the 'reason' that will be sent in
	// the status update for any remaining non-terminal tasks when the
	// container is terminated.
	Reason           *mesos.TaskStatus_Reason `protobuf:"varint,3,opt,name=reason,enum=mesos.TaskStatus_Reason" json:"reason,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *ContainerLimitation) Reset()                    { *m = ContainerLimitation{} }
func (m *ContainerLimitation) String() string            { return proto.CompactTextString(m) }
func (*ContainerLimitation) ProtoMessage()               {}
func (*ContainerLimitation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ContainerLimitation) GetResources() []*mesos.Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ContainerLimitation) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *ContainerLimitation) GetReason() mesos.TaskStatus_Reason {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return mesos.TaskStatus_REASON_COMMAND_EXECUTOR_FAILED
}

// *
// This message is derived from slave::state::RunState. It contains
// only those fields that are needed by Isolators for recovering the
// containers. The reason for not using RunState instead is to avoid
// any dependency on RunState and in turn on internal protobufs.
type ContainerState struct {
	// This field only exists for top level containers.
	ExecutorInfo *mesos.ExecutorInfo `protobuf:"bytes,1,opt,name=executor_info,json=executorInfo" json:"executor_info,omitempty"`
	// The container Id.
	ContainerId *mesos.ContainerID `protobuf:"bytes,2,req,name=container_id,json=containerId" json:"container_id,omitempty"`
	// The pid of the init process in the container.
	Pid *uint64 `protobuf:"varint,3,req,name=pid" json:"pid,omitempty"`
	// The sandbox directory.
	Directory        *string `protobuf:"bytes,4,req,name=directory" json:"directory,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContainerState) Reset()                    { *m = ContainerState{} }
func (m *ContainerState) String() string            { return proto.CompactTextString(m) }
func (*ContainerState) ProtoMessage()               {}
func (*ContainerState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ContainerState) GetExecutorInfo() *mesos.ExecutorInfo {
	if m != nil {
		return m.ExecutorInfo
	}
	return nil
}

func (m *ContainerState) GetContainerId() *mesos.ContainerID {
	if m != nil {
		return m.ContainerId
	}
	return nil
}

func (m *ContainerState) GetPid() uint64 {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return 0
}

func (m *ContainerState) GetDirectory() string {
	if m != nil && m.Directory != nil {
		return *m.Directory
	}
	return ""
}

// *
// The container recovery information that will be passed to each
// isolator during 'recover'.
type ContainerRecoverInfo struct {
	// The agent-checkpointed containers.
	CheckpointedContainerStates []*ContainerState `protobuf:"bytes,1,rep,name=checkpointed_container_states,json=checkpointedContainerStates" json:"checkpointed_container_states,omitempty"`
	// This field is deprecated. It represents the top level orphans.
	// Orphans are those containers that are known to the Launcher but
	// are not checkpointed by the agent.
	OrphanContainerIds []*mesos.ContainerID `protobuf:"bytes,2,rep,name=orphan_container_ids,json=orphanContainerIds" json:"orphan_container_ids,omitempty"`
	// All containers that are known to the Launcher. This also includes
	// child containers.
	KnownContainerIds []*mesos.ContainerID `protobuf:"bytes,3,rep,name=known_container_ids,json=knownContainerIds" json:"known_container_ids,omitempty"`
	XXX_unrecognized  []byte               `json:"-"`
}

func (m *ContainerRecoverInfo) Reset()                    { *m = ContainerRecoverInfo{} }
func (m *ContainerRecoverInfo) String() string            { return proto.CompactTextString(m) }
func (*ContainerRecoverInfo) ProtoMessage()               {}
func (*ContainerRecoverInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ContainerRecoverInfo) GetCheckpointedContainerStates() []*ContainerState {
	if m != nil {
		return m.CheckpointedContainerStates
	}
	return nil
}

func (m *ContainerRecoverInfo) GetOrphanContainerIds() []*mesos.ContainerID {
	if m != nil {
		return m.OrphanContainerIds
	}
	return nil
}

func (m *ContainerRecoverInfo) GetKnownContainerIds() []*mesos.ContainerID {
	if m != nil {
		return m.KnownContainerIds
	}
	return nil
}

// *
// The container configuration that will be passed to each isolator
// during `prepare`.
type ContainerConfig struct {
	// The executor associated with this container.
	ExecutorInfo *mesos.ExecutorInfo `protobuf:"bytes,8,opt,name=executor_info,json=executorInfo" json:"executor_info,omitempty"`
	// The task (optional) associated with this container.
	TaskInfo *mesos.TaskInfo `protobuf:"bytes,9,opt,name=task_info,json=taskInfo" json:"task_info,omitempty"`
	// The command used to launch the container.
	CommandInfo *mesos.CommandInfo `protobuf:"bytes,11,req,name=command_info,json=commandInfo" json:"command_info,omitempty"`
	// The information about the container.
	ContainerInfo *mesos.ContainerInfo `protobuf:"bytes,12,opt,name=container_info,json=containerInfo" json:"container_info,omitempty"`
	// Resources associated with the container during launch.
	Resources []*mesos.Resource `protobuf:"bytes,13,rep,name=resources" json:"resources,omitempty"`
	// The work directory for the container in the host filesystem.
	Directory *string `protobuf:"bytes,3,req,name=directory" json:"directory,omitempty"`
	// The user the task will be run as.
	User *string `protobuf:"bytes,4,opt,name=user" json:"user,omitempty"`
	// The root filesystem for the container.
	Rootfs           *string                 `protobuf:"bytes,5,opt,name=rootfs" json:"rootfs,omitempty"`
	Docker           *ContainerConfig_Docker `protobuf:"bytes,7,opt,name=docker" json:"docker,omitempty"`
	Appc             *ContainerConfig_Appc   `protobuf:"bytes,10,opt,name=appc" json:"appc,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *ContainerConfig) Reset()                    { *m = ContainerConfig{} }
func (m *ContainerConfig) String() string            { return proto.CompactTextString(m) }
func (*ContainerConfig) ProtoMessage()               {}
func (*ContainerConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ContainerConfig) GetExecutorInfo() *mesos.ExecutorInfo {
	if m != nil {
		return m.ExecutorInfo
	}
	return nil
}

func (m *ContainerConfig) GetTaskInfo() *mesos.TaskInfo {
	if m != nil {
		return m.TaskInfo
	}
	return nil
}

func (m *ContainerConfig) GetCommandInfo() *mesos.CommandInfo {
	if m != nil {
		return m.CommandInfo
	}
	return nil
}

func (m *ContainerConfig) GetContainerInfo() *mesos.ContainerInfo {
	if m != nil {
		return m.ContainerInfo
	}
	return nil
}

func (m *ContainerConfig) GetResources() []*mesos.Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ContainerConfig) GetDirectory() string {
	if m != nil && m.Directory != nil {
		return *m.Directory
	}
	return ""
}

func (m *ContainerConfig) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

func (m *ContainerConfig) GetRootfs() string {
	if m != nil && m.Rootfs != nil {
		return *m.Rootfs
	}
	return ""
}

func (m *ContainerConfig) GetDocker() *ContainerConfig_Docker {
	if m != nil {
		return m.Docker
	}
	return nil
}

func (m *ContainerConfig) GetAppc() *ContainerConfig_Appc {
	if m != nil {
		return m.Appc
	}
	return nil
}

// Docker v1 image manifest.
type ContainerConfig_Docker struct {
	Manifest         *docker_spec_v1.ImageManifest `protobuf:"bytes,1,opt,name=manifest" json:"manifest,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *ContainerConfig_Docker) Reset()                    { *m = ContainerConfig_Docker{} }
func (m *ContainerConfig_Docker) String() string            { return proto.CompactTextString(m) }
func (*ContainerConfig_Docker) ProtoMessage()               {}
func (*ContainerConfig_Docker) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

func (m *ContainerConfig_Docker) GetManifest() *docker_spec_v1.ImageManifest {
	if m != nil {
		return m.Manifest
	}
	return nil
}

type ContainerConfig_Appc struct {
	Manifest         *appc_spec.ImageManifest `protobuf:"bytes,1,opt,name=manifest" json:"manifest,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *ContainerConfig_Appc) Reset()                    { *m = ContainerConfig_Appc{} }
func (m *ContainerConfig_Appc) String() string            { return proto.CompactTextString(m) }
func (*ContainerConfig_Appc) ProtoMessage()               {}
func (*ContainerConfig_Appc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 1} }

func (m *ContainerConfig_Appc) GetManifest() *appc_spec.ImageManifest {
	if m != nil {
		return m.Manifest
	}
	return nil
}

// *
// Protobuf returned by Isolator::prepare(). The command is executed
// by the Launcher in the containerized context.
// Note: Currently, any URIs or Environment in the CommandInfo will be
// ignored; only the command value is used. Further, we only accept
// shell commands for the preparation commands.
type ContainerLaunchInfo struct {
	// The additional preparation commands to execute before
	// executing the command.
	PreExecCommands []*mesos.CommandInfo `protobuf:"bytes,1,rep,name=pre_exec_commands,json=preExecCommands" json:"pre_exec_commands,omitempty"`
	Environment     *mesos.Environment   `protobuf:"bytes,2,opt,name=environment" json:"environment,omitempty"`
	// The root filesystem for the container.
	//
	// This field is not used since 0.28, and it is deprecated
	// since 1.0.1.
	Rootfs *string `protobuf:"bytes,3,opt,name=rootfs" json:"rootfs,omitempty"`
	// (Linux only) The namespaces required for the container.
	// The namespaces are created while launching the executor.
	Namespaces *uint32 `protobuf:"varint,4,opt,name=namespaces,def=0" json:"namespaces,omitempty"`
	// If specified, it'll become the launch command for the custom
	// executor, or the launch command for the user task in the case of
	// a command task.
	Command *mesos.CommandInfo `protobuf:"bytes,5,opt,name=command" json:"command,omitempty"`
	// The working directory for the container.
	// NOTE: This is different than Mesos sandbox.
	WorkingDirectory *string `protobuf:"bytes,6,opt,name=working_directory,json=workingDirectory" json:"working_directory,omitempty"`
	// (Linux only) The capabilities requested for the container.
	// The capabilities are set while launching the container.
	Capabilities     *mesos.CapabilityInfo `protobuf:"bytes,7,opt,name=capabilities" json:"capabilities,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *ContainerLaunchInfo) Reset()                    { *m = ContainerLaunchInfo{} }
func (m *ContainerLaunchInfo) String() string            { return proto.CompactTextString(m) }
func (*ContainerLaunchInfo) ProtoMessage()               {}
func (*ContainerLaunchInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

const Default_ContainerLaunchInfo_Namespaces uint32 = 0

func (m *ContainerLaunchInfo) GetPreExecCommands() []*mesos.CommandInfo {
	if m != nil {
		return m.PreExecCommands
	}
	return nil
}

func (m *ContainerLaunchInfo) GetEnvironment() *mesos.Environment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *ContainerLaunchInfo) GetRootfs() string {
	if m != nil && m.Rootfs != nil {
		return *m.Rootfs
	}
	return ""
}

func (m *ContainerLaunchInfo) GetNamespaces() uint32 {
	if m != nil && m.Namespaces != nil {
		return *m.Namespaces
	}
	return Default_ContainerLaunchInfo_Namespaces
}

func (m *ContainerLaunchInfo) GetCommand() *mesos.CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerLaunchInfo) GetWorkingDirectory() string {
	if m != nil && m.WorkingDirectory != nil {
		return *m.WorkingDirectory
	}
	return ""
}

func (m *ContainerLaunchInfo) GetCapabilities() *mesos.CapabilityInfo {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// *
// Information about a container termination, returned by the
// containerizer to the slave.
type ContainerTermination struct {
	// Exit status of the process.
	Status *int32 `protobuf:"varint,3,opt,name=status" json:"status,omitempty"`
	// The 'state', 'reasons' and 'message' of a status update for
	// non-terminal tasks when the executor is terminated.
	State            *mesos.TaskState          `protobuf:"varint,4,opt,name=state,enum=mesos.TaskState" json:"state,omitempty"`
	Reasons          []mesos.TaskStatus_Reason `protobuf:"varint,5,rep,name=reasons,enum=mesos.TaskStatus_Reason" json:"reasons,omitempty"`
	Message          *string                   `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *ContainerTermination) Reset()                    { *m = ContainerTermination{} }
func (m *ContainerTermination) String() string            { return proto.CompactTextString(m) }
func (*ContainerTermination) ProtoMessage()               {}
func (*ContainerTermination) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ContainerTermination) GetStatus() int32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return 0
}

func (m *ContainerTermination) GetState() mesos.TaskState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return mesos.TaskState_TASK_STAGING
}

func (m *ContainerTermination) GetReasons() []mesos.TaskStatus_Reason {
	if m != nil {
		return m.Reasons
	}
	return nil
}

func (m *ContainerTermination) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*ContainerLimitation)(nil), "mesos.slave.ContainerLimitation")
	proto.RegisterType((*ContainerState)(nil), "mesos.slave.ContainerState")
	proto.RegisterType((*ContainerRecoverInfo)(nil), "mesos.slave.ContainerRecoverInfo")
	proto.RegisterType((*ContainerConfig)(nil), "mesos.slave.ContainerConfig")
	proto.RegisterType((*ContainerConfig_Docker)(nil), "mesos.slave.ContainerConfig.Docker")
	proto.RegisterType((*ContainerConfig_Appc)(nil), "mesos.slave.ContainerConfig.Appc")
	proto.RegisterType((*ContainerLaunchInfo)(nil), "mesos.slave.ContainerLaunchInfo")
	proto.RegisterType((*ContainerTermination)(nil), "mesos.slave.ContainerTermination")
}

func init() { proto.RegisterFile("mesos/slave/containerizer.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 792 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x55, 0xdd, 0x8e, 0x1b, 0x35,
	0x14, 0xd6, 0x4c, 0xb2, 0xd9, 0xcd, 0x99, 0xfd, 0x8b, 0x77, 0x5b, 0x59, 0x29, 0x15, 0x69, 0x90,
	0x50, 0x24, 0xca, 0xa4, 0x8d, 0x5a, 0x89, 0x52, 0x84, 0x44, 0x37, 0xbd, 0x88, 0x04, 0x37, 0xa6,
	0xf7, 0x23, 0x33, 0xe3, 0x64, 0xad, 0x74, 0xec, 0x91, 0x3d, 0x49, 0x29, 0x77, 0xbc, 0x01, 0x0f,
	0xc1, 0x0b, 0xf0, 0x40, 0x48, 0x3c, 0x0a, 0xf2, 0xcf, 0xfc, 0x24, 0x9b, 0x2d, 0xdc, 0x8d, 0xcf,
	0xf9, 0xbe, 0xcf, 0x3e, 0x73, 0x3e, 0x1f, 0xc3, 0xe7, 0x39, 0xd3, 0x52, 0x4f, 0xf5, 0x7b, 0xba,
	0x65, 0xd3, 0x54, 0x8a, 0x92, 0x72, 0xc1, 0x14, 0xff, 0x8d, 0xa9, 0xb8, 0x50, 0xb2, 0x94, 0x28,
	0xb2, 0x80, 0xd8, 0x02, 0x86, 0x03, 0x87, 0x76, 0x21, 0x9b, 0x1f, 0x3e, 0x70, 0x21, 0x5a, 0x14,
	0xe9, 0x54, 0x17, 0x2c, 0xdd, 0x0d, 0x67, 0x32, 0x5d, 0x33, 0x35, 0xdd, 0x3e, 0x77, 0xe1, 0xf1,
	0x1f, 0x01, 0x5c, 0xdd, 0x54, 0xbb, 0xfc, 0xc8, 0x73, 0x5e, 0xd2, 0x92, 0x4b, 0x81, 0xbe, 0x86,
	0xbe, 0x62, 0x5a, 0x6e, 0x54, 0xca, 0x34, 0x0e, 0x46, 0x9d, 0x49, 0x34, 0xbb, 0x88, 0xdd, 0x36,
	0xc4, 0xc7, 0x49, 0x83, 0x40, 0x18, 0x8e, 0x73, 0xa6, 0x35, 0x5d, 0x31, 0x1c, 0x8e, 0x82, 0x49,
	0x9f, 0x54, 0x4b, 0xf4, 0x0c, 0x7a, 0x8a, 0x51, 0x2d, 0x05, 0xee, 0x8c, 0x82, 0xc9, 0xf9, 0x0c,
	0x7b, 0x95, 0x77, 0x54, 0xaf, 0x7f, 0x2e, 0x69, 0xb9, 0x31, 0x82, 0x26, 0x4f, 0x3c, 0x6e, 0xfc,
	0x57, 0x00, 0xe7, 0xf5, 0x91, 0x0c, 0x84, 0xa1, 0x6f, 0xe0, 0x8c, 0xfd, 0xca, 0xd2, 0x4d, 0x29,
	0x55, 0xc2, 0xc5, 0x52, 0xe2, 0x60, 0x14, 0x4c, 0xa2, 0xd9, 0x95, 0xd7, 0x7a, 0xeb, 0x73, 0x0b,
	0xb1, 0x94, 0xe4, 0x94, 0xb5, 0x56, 0xe8, 0x25, 0x9c, 0xd6, 0x3f, 0x31, 0xe1, 0x19, 0x0e, 0x47,
	0xe1, 0x24, 0x9a, 0x21, 0x4f, 0xac, 0xb7, 0x59, 0xcc, 0x49, 0x54, 0xe3, 0x16, 0x19, 0xba, 0x84,
	0x4e, 0xc1, 0x33, 0xdc, 0x19, 0x85, 0x93, 0x2e, 0x31, 0x9f, 0xe8, 0x33, 0xe8, 0x67, 0x5c, 0xb1,
	0xb4, 0x94, 0xea, 0x23, 0xee, 0x8e, 0xc2, 0x49, 0x9f, 0x34, 0x81, 0xf1, 0xef, 0x21, 0x5c, 0xd7,
	0x62, 0x84, 0xa5, 0x72, 0xcb, 0xdc, 0xfe, 0x09, 0x3c, 0x4e, 0x6f, 0x59, 0xba, 0x2e, 0x24, 0x17,
	0x25, 0xcb, 0x92, 0xe6, 0x30, 0xda, 0x54, 0x56, 0xfd, 0xdb, 0x47, 0x71, 0xab, 0xab, 0xf1, 0x6e,
	0xf5, 0xe4, 0x51, 0x5b, 0x61, 0x37, 0xa7, 0xd1, 0x1c, 0xae, 0xa5, 0x2a, 0x6e, 0xa9, 0x48, 0xda,
	0x75, 0x6a, 0x1c, 0x5a, 0xdd, 0x43, 0x85, 0x22, 0x87, 0x6f, 0x42, 0x99, 0x46, 0x6f, 0xe0, 0x6a,
	0x2d, 0xe4, 0x87, 0x7d, 0x91, 0xce, 0xbd, 0x22, 0x03, 0x0b, 0x6f, 0x6b, 0x8c, 0xff, 0xee, 0xc2,
	0x45, 0x1d, 0xb8, 0x91, 0x62, 0xc9, 0x57, 0x77, 0x1b, 0x77, 0xf2, 0x7f, 0x1b, 0xf7, 0x14, 0xfa,
	0x25, 0xd5, 0x6b, 0xc7, 0xea, 0x5b, 0xd6, 0x45, 0xcb, 0x3a, 0x96, 0x71, 0x52, 0xfa, 0x2f, 0xd7,
	0xe6, 0x3c, 0xa7, 0x22, 0x73, 0x84, 0x68, 0xaf, 0xcd, 0x36, 0x65, 0x39, 0x51, 0xda, 0x2c, 0xd0,
	0x6b, 0x38, 0x6f, 0x15, 0x6c, 0x88, 0xa7, 0x76, 0xa7, 0xeb, 0x3b, 0x15, 0x1b, 0xea, 0x59, 0xda,
	0x5e, 0xee, 0x5e, 0x91, 0xb3, 0xff, 0xbc, 0x22, 0x3b, 0x06, 0xea, 0xec, 0x19, 0x08, 0x21, 0xe8,
	0x6e, 0x34, 0x53, 0xb8, 0x6b, 0x6f, 0x8f, 0xfd, 0x46, 0x0f, 0xa1, 0xa7, 0xa4, 0x2c, 0x97, 0x1a,
	0x1f, 0xd9, 0xa8, 0x5f, 0xa1, 0xd7, 0xd0, 0x73, 0xd7, 0x18, 0x1f, 0xdb, 0xd3, 0x7e, 0x71, 0xd8,
	0x3c, 0xae, 0x05, 0xf1, 0xdc, 0x42, 0x89, 0xa7, 0xa0, 0x97, 0xd0, 0x35, 0xa3, 0x01, 0x83, 0xa5,
	0x3e, 0xf9, 0x24, 0xf5, 0x87, 0xa2, 0x48, 0x89, 0x85, 0x0f, 0x6f, 0xa0, 0xe7, 0x84, 0xd0, 0x2b,
	0x38, 0xc9, 0xa9, 0xe0, 0x4b, 0xa6, 0x4b, 0x7f, 0x0d, 0x1f, 0xc7, 0x4e, 0x3b, 0xb6, 0xe3, 0x66,
	0xfb, 0x3c, 0x5e, 0xe4, 0x74, 0xc5, 0x7e, 0xf2, 0x20, 0x52, 0xc3, 0x87, 0xdf, 0x41, 0xd7, 0x48,
	0xa2, 0x17, 0x77, 0x24, 0x70, 0x6c, 0x76, 0x71, 0x02, 0xf7, 0xb0, 0xc7, 0xff, 0x84, 0xed, 0x51,
	0x45, 0x37, 0x22, 0xbd, 0xb5, 0x7d, 0xf8, 0x1e, 0x06, 0x85, 0x62, 0x89, 0x71, 0x4f, 0xe2, 0x9b,
	0x5b, 0x5d, 0xab, 0x43, 0x06, 0xb8, 0x28, 0x14, 0x33, 0xbe, 0xf3, 0x31, 0x8d, 0x5e, 0x40, 0xc4,
	0xc4, 0x96, 0x2b, 0x29, 0x72, 0x26, 0x4a, 0x3b, 0xbf, 0x1a, 0xe6, 0xdb, 0x26, 0x43, 0xda, 0x30,
	0x34, 0xac, 0x9b, 0x63, 0xe6, 0x5a, 0xff, 0x4d, 0x88, 0x83, 0xba, 0x41, 0x4f, 0x00, 0x04, 0xcd,
	0x99, 0x2e, 0xa8, 0xb1, 0x86, 0x69, 0xe9, 0xd9, 0xb7, 0xc1, 0x33, 0xd2, 0x0a, 0xa2, 0xa7, 0x70,
	0xec, 0xcf, 0x6a, 0x9b, 0x7b, 0xf8, 0xa8, 0x15, 0x04, 0x7d, 0x05, 0x83, 0x0f, 0x52, 0xad, 0xb9,
	0x58, 0x25, 0x8d, 0x87, 0x7a, 0xd6, 0x14, 0x97, 0x3e, 0x31, 0xaf, 0xad, 0xf4, 0x0a, 0x4e, 0x53,
	0x5a, 0xd0, 0x5f, 0xf8, 0x7b, 0x5e, 0x72, 0xa6, 0xbd, 0x49, 0x1e, 0x54, 0xfa, 0x55, 0xea, 0xa3,
	0xbb, 0x74, 0x6d, 0xe8, 0xf8, 0xcf, 0xa0, 0x35, 0xc6, 0xde, 0x31, 0x95, 0x73, 0xe1, 0x9e, 0x83,
	0x87, 0xd0, 0xd3, 0x76, 0x58, 0xdb, 0x6a, 0x8f, 0x88, 0x5f, 0xa1, 0x2f, 0xe1, 0xc8, 0xce, 0x31,
	0x5b, 0xe4, 0xf9, 0xec, 0x72, 0x6f, 0xb8, 0x33, 0xe2, 0xd2, 0x68, 0x06, 0xc7, 0x6e, 0xba, 0x1b,
	0x2f, 0x77, 0x3e, 0xf9, 0x0c, 0x54, 0xc0, 0xfb, 0xdf, 0x94, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff,
	0x86, 0xcf, 0x1a, 0x88, 0x24, 0x07, 0x00, 0x00,
}
