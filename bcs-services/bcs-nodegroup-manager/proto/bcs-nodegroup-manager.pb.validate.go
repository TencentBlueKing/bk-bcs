// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/bcs-nodegroup-manager.proto

package nodegroupmanager

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ClusterAutoscalerReview with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAutoscalerReview) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAutoscalerReview with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterAutoscalerReviewMultiError, or nil if none found.
func (m *ClusterAutoscalerReview) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAutoscalerReview) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterAutoscalerReviewValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterAutoscalerReviewValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterAutoscalerReviewValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterAutoscalerReviewValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterAutoscalerReviewValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterAutoscalerReviewValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterAutoscalerReviewMultiError(errors)
	}
	return nil
}

// ClusterAutoscalerReviewMultiError is an error wrapping multiple validation
// errors returned by ClusterAutoscalerReview.ValidateAll() if the designated
// constraints aren't met.
type ClusterAutoscalerReviewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAutoscalerReviewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAutoscalerReviewMultiError) AllErrors() []error { return m }

// ClusterAutoscalerReviewValidationError is the validation error returned by
// ClusterAutoscalerReview.Validate if the designated constraints aren't met.
type ClusterAutoscalerReviewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAutoscalerReviewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAutoscalerReviewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAutoscalerReviewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAutoscalerReviewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAutoscalerReviewValidationError) ErrorName() string {
	return "ClusterAutoscalerReviewValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAutoscalerReviewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAutoscalerReview.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAutoscalerReviewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAutoscalerReviewValidationError{}

// Validate checks the field values on AutoscalerReviewRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AutoscalerReviewRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoscalerReviewRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutoscalerReviewRequestMultiError, or nil if none found.
func (m *AutoscalerReviewRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoscalerReviewRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	{
		sorted_keys := make([]string, len(m.GetNodeGroups()))
		i := 0
		for key := range m.GetNodeGroups() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNodeGroups()[key]
			_ = val

			// no validation rules for NodeGroups[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, AutoscalerReviewRequestValidationError{
							field:  fmt.Sprintf("NodeGroups[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, AutoscalerReviewRequestValidationError{
							field:  fmt.Sprintf("NodeGroups[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return AutoscalerReviewRequestValidationError{
						field:  fmt.Sprintf("NodeGroups[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return AutoscalerReviewRequestMultiError(errors)
	}
	return nil
}

// AutoscalerReviewRequestMultiError is an error wrapping multiple validation
// errors returned by AutoscalerReviewRequest.ValidateAll() if the designated
// constraints aren't met.
type AutoscalerReviewRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoscalerReviewRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoscalerReviewRequestMultiError) AllErrors() []error { return m }

// AutoscalerReviewRequestValidationError is the validation error returned by
// AutoscalerReviewRequest.Validate if the designated constraints aren't met.
type AutoscalerReviewRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoscalerReviewRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoscalerReviewRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoscalerReviewRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoscalerReviewRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoscalerReviewRequestValidationError) ErrorName() string {
	return "AutoscalerReviewRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AutoscalerReviewRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoscalerReviewRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoscalerReviewRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoscalerReviewRequestValidationError{}

// Validate checks the field values on AutoscalerReviewResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AutoscalerReviewResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoscalerReviewResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutoscalerReviewResponseMultiError, or nil if none found.
func (m *AutoscalerReviewResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoscalerReviewResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	for idx, item := range m.GetScaleUps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoscalerReviewResponseValidationError{
						field:  fmt.Sprintf("ScaleUps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoscalerReviewResponseValidationError{
						field:  fmt.Sprintf("ScaleUps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoscalerReviewResponseValidationError{
					field:  fmt.Sprintf("ScaleUps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetScaleDowns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoscalerReviewResponseValidationError{
						field:  fmt.Sprintf("ScaleDowns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoscalerReviewResponseValidationError{
						field:  fmt.Sprintf("ScaleDowns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoscalerReviewResponseValidationError{
					field:  fmt.Sprintf("ScaleDowns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AutoscalerReviewResponseMultiError(errors)
	}
	return nil
}

// AutoscalerReviewResponseMultiError is an error wrapping multiple validation
// errors returned by AutoscalerReviewResponse.ValidateAll() if the designated
// constraints aren't met.
type AutoscalerReviewResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoscalerReviewResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoscalerReviewResponseMultiError) AllErrors() []error { return m }

// AutoscalerReviewResponseValidationError is the validation error returned by
// AutoscalerReviewResponse.Validate if the designated constraints aren't met.
type AutoscalerReviewResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoscalerReviewResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoscalerReviewResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoscalerReviewResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoscalerReviewResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoscalerReviewResponseValidationError) ErrorName() string {
	return "AutoscalerReviewResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AutoscalerReviewResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoscalerReviewResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoscalerReviewResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoscalerReviewResponseValidationError{}

// Validate checks the field values on NodeGroup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupMultiError, or nil
// if none found.
func (m *NodeGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeGroupID

	// no validation rules for MaxSize

	// no validation rules for MinSize

	// no validation rules for DesiredSize

	// no validation rules for UpcomingSize

	if all {
		switch v := interface{}(m.GetNodeTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "NodeTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Priority

	// no validation rules for DeletingSize

	if len(errors) > 0 {
		return NodeGroupMultiError(errors)
	}
	return nil
}

// NodeGroupMultiError is an error wrapping multiple validation errors returned
// by NodeGroup.ValidateAll() if the designated constraints aren't met.
type NodeGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupMultiError) AllErrors() []error { return m }

// NodeGroupValidationError is the validation error returned by
// NodeGroup.Validate if the designated constraints aren't met.
type NodeGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupValidationError) ErrorName() string { return "NodeGroupValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupValidationError{}

// Validate checks the field values on NodeTemplate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeTemplateMultiError, or
// nil if none found.
func (m *NodeTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cpu

	// no validation rules for Mem

	// no validation rules for Gpu

	// no validation rules for Labels

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeTemplateValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeTemplateMultiError(errors)
	}
	return nil
}

// NodeTemplateMultiError is an error wrapping multiple validation errors
// returned by NodeTemplate.ValidateAll() if the designated constraints aren't met.
type NodeTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeTemplateMultiError) AllErrors() []error { return m }

// NodeTemplateValidationError is the validation error returned by
// NodeTemplate.Validate if the designated constraints aren't met.
type NodeTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeTemplateValidationError) ErrorName() string { return "NodeTemplateValidationError" }

// Error satisfies the builtin error interface
func (e NodeTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeTemplateValidationError{}

// Validate checks the field values on NodeTaint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeTaint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeTaint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeTaintMultiError, or nil
// if none found.
func (m *NodeTaint) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeTaint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	// no validation rules for Effect

	// no validation rules for TimeAdded

	if len(errors) > 0 {
		return NodeTaintMultiError(errors)
	}
	return nil
}

// NodeTaintMultiError is an error wrapping multiple validation errors returned
// by NodeTaint.ValidateAll() if the designated constraints aren't met.
type NodeTaintMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeTaintMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeTaintMultiError) AllErrors() []error { return m }

// NodeTaintValidationError is the validation error returned by
// NodeTaint.Validate if the designated constraints aren't met.
type NodeTaintValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeTaintValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeTaintValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeTaintValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeTaintValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeTaintValidationError) ErrorName() string { return "NodeTaintValidationError" }

// Error satisfies the builtin error interface
func (e NodeTaintValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeTaint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeTaintValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeTaintValidationError{}

// Validate checks the field values on NodeScaleUpPolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NodeScaleUpPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeScaleUpPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeScaleUpPolicyMultiError, or nil if none found.
func (m *NodeScaleUpPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeScaleUpPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeGroupID

	// no validation rules for DesiredSize

	if len(errors) > 0 {
		return NodeScaleUpPolicyMultiError(errors)
	}
	return nil
}

// NodeScaleUpPolicyMultiError is an error wrapping multiple validation errors
// returned by NodeScaleUpPolicy.ValidateAll() if the designated constraints
// aren't met.
type NodeScaleUpPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeScaleUpPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeScaleUpPolicyMultiError) AllErrors() []error { return m }

// NodeScaleUpPolicyValidationError is the validation error returned by
// NodeScaleUpPolicy.Validate if the designated constraints aren't met.
type NodeScaleUpPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeScaleUpPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeScaleUpPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeScaleUpPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeScaleUpPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeScaleUpPolicyValidationError) ErrorName() string {
	return "NodeScaleUpPolicyValidationError"
}

// Error satisfies the builtin error interface
func (e NodeScaleUpPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeScaleUpPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeScaleUpPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeScaleUpPolicyValidationError{}

// Validate checks the field values on NodeScaleDownPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeScaleDownPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeScaleDownPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeScaleDownPolicyMultiError, or nil if none found.
func (m *NodeScaleDownPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeScaleDownPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeGroupID

	// no validation rules for Type

	// no validation rules for NodeNum

	if len(errors) > 0 {
		return NodeScaleDownPolicyMultiError(errors)
	}
	return nil
}

// NodeScaleDownPolicyMultiError is an error wrapping multiple validation
// errors returned by NodeScaleDownPolicy.ValidateAll() if the designated
// constraints aren't met.
type NodeScaleDownPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeScaleDownPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeScaleDownPolicyMultiError) AllErrors() []error { return m }

// NodeScaleDownPolicyValidationError is the validation error returned by
// NodeScaleDownPolicy.Validate if the designated constraints aren't met.
type NodeScaleDownPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeScaleDownPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeScaleDownPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeScaleDownPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeScaleDownPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeScaleDownPolicyValidationError) ErrorName() string {
	return "NodeScaleDownPolicyValidationError"
}

// Error satisfies the builtin error interface
func (e NodeScaleDownPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeScaleDownPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeScaleDownPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeScaleDownPolicyValidationError{}

// Validate checks the field values on CreateNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodePoolMgrStrategyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodePoolMgrStrategyReqMultiError, or nil if none found.
func (m *CreateNodePoolMgrStrategyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodePoolMgrStrategyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOption()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodePoolMgrStrategyReqValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodePoolMgrStrategyReqValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOption()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodePoolMgrStrategyReqValidationError{
				field:  "Option",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStrategy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodePoolMgrStrategyReqValidationError{
					field:  "Strategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodePoolMgrStrategyReqValidationError{
					field:  "Strategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStrategy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodePoolMgrStrategyReqValidationError{
				field:  "Strategy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNodePoolMgrStrategyReqMultiError(errors)
	}
	return nil
}

// CreateNodePoolMgrStrategyReqMultiError is an error wrapping multiple
// validation errors returned by CreateNodePoolMgrStrategyReq.ValidateAll() if
// the designated constraints aren't met.
type CreateNodePoolMgrStrategyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodePoolMgrStrategyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodePoolMgrStrategyReqMultiError) AllErrors() []error { return m }

// CreateNodePoolMgrStrategyReqValidationError is the validation error returned
// by CreateNodePoolMgrStrategyReq.Validate if the designated constraints
// aren't met.
type CreateNodePoolMgrStrategyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodePoolMgrStrategyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodePoolMgrStrategyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodePoolMgrStrategyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodePoolMgrStrategyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodePoolMgrStrategyReqValidationError) ErrorName() string {
	return "CreateNodePoolMgrStrategyReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodePoolMgrStrategyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodePoolMgrStrategyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodePoolMgrStrategyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodePoolMgrStrategyReqValidationError{}

// Validate checks the field values on UpdateNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodePoolMgrStrategyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodePoolMgrStrategyReqMultiError, or nil if none found.
func (m *UpdateNodePoolMgrStrategyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodePoolMgrStrategyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOption()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodePoolMgrStrategyReqValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodePoolMgrStrategyReqValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOption()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodePoolMgrStrategyReqValidationError{
				field:  "Option",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStrategy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodePoolMgrStrategyReqValidationError{
					field:  "Strategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodePoolMgrStrategyReqValidationError{
					field:  "Strategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStrategy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodePoolMgrStrategyReqValidationError{
				field:  "Strategy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodePoolMgrStrategyReqMultiError(errors)
	}
	return nil
}

// UpdateNodePoolMgrStrategyReqMultiError is an error wrapping multiple
// validation errors returned by UpdateNodePoolMgrStrategyReq.ValidateAll() if
// the designated constraints aren't met.
type UpdateNodePoolMgrStrategyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodePoolMgrStrategyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodePoolMgrStrategyReqMultiError) AllErrors() []error { return m }

// UpdateNodePoolMgrStrategyReqValidationError is the validation error returned
// by UpdateNodePoolMgrStrategyReq.Validate if the designated constraints
// aren't met.
type UpdateNodePoolMgrStrategyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodePoolMgrStrategyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodePoolMgrStrategyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodePoolMgrStrategyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodePoolMgrStrategyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodePoolMgrStrategyReqValidationError) ErrorName() string {
	return "UpdateNodePoolMgrStrategyReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodePoolMgrStrategyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodePoolMgrStrategyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodePoolMgrStrategyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodePoolMgrStrategyReqValidationError{}

// Validate checks the field values on CreateNodePoolMgrStrategyRsp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodePoolMgrStrategyRsp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodePoolMgrStrategyRsp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodePoolMgrStrategyRspMultiError, or nil if none found.
func (m *CreateNodePoolMgrStrategyRsp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodePoolMgrStrategyRsp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateNodePoolMgrStrategyRspMultiError(errors)
	}
	return nil
}

// CreateNodePoolMgrStrategyRspMultiError is an error wrapping multiple
// validation errors returned by CreateNodePoolMgrStrategyRsp.ValidateAll() if
// the designated constraints aren't met.
type CreateNodePoolMgrStrategyRspMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodePoolMgrStrategyRspMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodePoolMgrStrategyRspMultiError) AllErrors() []error { return m }

// CreateNodePoolMgrStrategyRspValidationError is the validation error returned
// by CreateNodePoolMgrStrategyRsp.Validate if the designated constraints
// aren't met.
type CreateNodePoolMgrStrategyRspValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodePoolMgrStrategyRspValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodePoolMgrStrategyRspValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodePoolMgrStrategyRspValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodePoolMgrStrategyRspValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodePoolMgrStrategyRspValidationError) ErrorName() string {
	return "CreateNodePoolMgrStrategyRspValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodePoolMgrStrategyRspValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodePoolMgrStrategyRsp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodePoolMgrStrategyRspValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodePoolMgrStrategyRspValidationError{}

// Validate checks the field values on GetNodePoolMgrStrategyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodePoolMgrStrategyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodePoolMgrStrategyReqMultiError, or nil if none found.
func (m *GetNodePoolMgrStrategyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodePoolMgrStrategyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return GetNodePoolMgrStrategyReqMultiError(errors)
	}
	return nil
}

// GetNodePoolMgrStrategyReqMultiError is an error wrapping multiple validation
// errors returned by GetNodePoolMgrStrategyReq.ValidateAll() if the
// designated constraints aren't met.
type GetNodePoolMgrStrategyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodePoolMgrStrategyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodePoolMgrStrategyReqMultiError) AllErrors() []error { return m }

// GetNodePoolMgrStrategyReqValidationError is the validation error returned by
// GetNodePoolMgrStrategyReq.Validate if the designated constraints aren't met.
type GetNodePoolMgrStrategyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodePoolMgrStrategyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodePoolMgrStrategyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodePoolMgrStrategyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodePoolMgrStrategyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodePoolMgrStrategyReqValidationError) ErrorName() string {
	return "GetNodePoolMgrStrategyReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodePoolMgrStrategyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodePoolMgrStrategyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodePoolMgrStrategyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodePoolMgrStrategyReqValidationError{}

// Validate checks the field values on GetNodePoolMgrStrategyRsp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodePoolMgrStrategyRsp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodePoolMgrStrategyRsp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodePoolMgrStrategyRspMultiError, or nil if none found.
func (m *GetNodePoolMgrStrategyRsp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodePoolMgrStrategyRsp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNodePoolMgrStrategyRspValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNodePoolMgrStrategyRspValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNodePoolMgrStrategyRspValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNodePoolMgrStrategyRspMultiError(errors)
	}
	return nil
}

// GetNodePoolMgrStrategyRspMultiError is an error wrapping multiple validation
// errors returned by GetNodePoolMgrStrategyRsp.ValidateAll() if the
// designated constraints aren't met.
type GetNodePoolMgrStrategyRspMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodePoolMgrStrategyRspMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodePoolMgrStrategyRspMultiError) AllErrors() []error { return m }

// GetNodePoolMgrStrategyRspValidationError is the validation error returned by
// GetNodePoolMgrStrategyRsp.Validate if the designated constraints aren't met.
type GetNodePoolMgrStrategyRspValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodePoolMgrStrategyRspValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodePoolMgrStrategyRspValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodePoolMgrStrategyRspValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodePoolMgrStrategyRspValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodePoolMgrStrategyRspValidationError) ErrorName() string {
	return "GetNodePoolMgrStrategyRspValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodePoolMgrStrategyRspValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodePoolMgrStrategyRsp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodePoolMgrStrategyRspValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodePoolMgrStrategyRspValidationError{}

// Validate checks the field values on ListNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodePoolMgrStrategyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodePoolMgrStrategyReqMultiError, or nil if none found.
func (m *ListNodePoolMgrStrategyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodePoolMgrStrategyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetLimit() < 0 {
		err := ListNodePoolMgrStrategyReqValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPage() < 0 {
		err := ListNodePoolMgrStrategyReqValidationError{
			field:  "Page",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListNodePoolMgrStrategyReqMultiError(errors)
	}
	return nil
}

// ListNodePoolMgrStrategyReqMultiError is an error wrapping multiple
// validation errors returned by ListNodePoolMgrStrategyReq.ValidateAll() if
// the designated constraints aren't met.
type ListNodePoolMgrStrategyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodePoolMgrStrategyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodePoolMgrStrategyReqMultiError) AllErrors() []error { return m }

// ListNodePoolMgrStrategyReqValidationError is the validation error returned
// by ListNodePoolMgrStrategyReq.Validate if the designated constraints aren't met.
type ListNodePoolMgrStrategyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodePoolMgrStrategyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodePoolMgrStrategyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodePoolMgrStrategyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodePoolMgrStrategyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodePoolMgrStrategyReqValidationError) ErrorName() string {
	return "ListNodePoolMgrStrategyReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodePoolMgrStrategyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodePoolMgrStrategyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodePoolMgrStrategyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodePoolMgrStrategyReqValidationError{}

// Validate checks the field values on ListNodePoolMgrStrategyRsp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodePoolMgrStrategyRsp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodePoolMgrStrategyRsp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodePoolMgrStrategyRspMultiError, or nil if none found.
func (m *ListNodePoolMgrStrategyRsp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodePoolMgrStrategyRsp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodePoolMgrStrategyRspValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodePoolMgrStrategyRspValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodePoolMgrStrategyRspValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNodePoolMgrStrategyRspMultiError(errors)
	}
	return nil
}

// ListNodePoolMgrStrategyRspMultiError is an error wrapping multiple
// validation errors returned by ListNodePoolMgrStrategyRsp.ValidateAll() if
// the designated constraints aren't met.
type ListNodePoolMgrStrategyRspMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodePoolMgrStrategyRspMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodePoolMgrStrategyRspMultiError) AllErrors() []error { return m }

// ListNodePoolMgrStrategyRspValidationError is the validation error returned
// by ListNodePoolMgrStrategyRsp.Validate if the designated constraints aren't met.
type ListNodePoolMgrStrategyRspValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodePoolMgrStrategyRspValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodePoolMgrStrategyRspValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodePoolMgrStrategyRspValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodePoolMgrStrategyRspValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodePoolMgrStrategyRspValidationError) ErrorName() string {
	return "ListNodePoolMgrStrategyRspValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodePoolMgrStrategyRspValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodePoolMgrStrategyRsp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodePoolMgrStrategyRspValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodePoolMgrStrategyRspValidationError{}

// Validate checks the field values on DeleteNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodePoolMgrStrategyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodePoolMgrStrategyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodePoolMgrStrategyReqMultiError, or nil if none found.
func (m *DeleteNodePoolMgrStrategyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodePoolMgrStrategyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Operator

	if len(errors) > 0 {
		return DeleteNodePoolMgrStrategyReqMultiError(errors)
	}
	return nil
}

// DeleteNodePoolMgrStrategyReqMultiError is an error wrapping multiple
// validation errors returned by DeleteNodePoolMgrStrategyReq.ValidateAll() if
// the designated constraints aren't met.
type DeleteNodePoolMgrStrategyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodePoolMgrStrategyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodePoolMgrStrategyReqMultiError) AllErrors() []error { return m }

// DeleteNodePoolMgrStrategyReqValidationError is the validation error returned
// by DeleteNodePoolMgrStrategyReq.Validate if the designated constraints
// aren't met.
type DeleteNodePoolMgrStrategyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodePoolMgrStrategyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodePoolMgrStrategyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodePoolMgrStrategyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodePoolMgrStrategyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodePoolMgrStrategyReqValidationError) ErrorName() string {
	return "DeleteNodePoolMgrStrategyReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodePoolMgrStrategyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodePoolMgrStrategyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodePoolMgrStrategyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodePoolMgrStrategyReqValidationError{}

// Validate checks the field values on DeleteNodePoolMgrStrategyRsp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodePoolMgrStrategyRsp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodePoolMgrStrategyRsp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodePoolMgrStrategyRspMultiError, or nil if none found.
func (m *DeleteNodePoolMgrStrategyRsp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodePoolMgrStrategyRsp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DeleteNodePoolMgrStrategyRspMultiError(errors)
	}
	return nil
}

// DeleteNodePoolMgrStrategyRspMultiError is an error wrapping multiple
// validation errors returned by DeleteNodePoolMgrStrategyRsp.ValidateAll() if
// the designated constraints aren't met.
type DeleteNodePoolMgrStrategyRspMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodePoolMgrStrategyRspMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodePoolMgrStrategyRspMultiError) AllErrors() []error { return m }

// DeleteNodePoolMgrStrategyRspValidationError is the validation error returned
// by DeleteNodePoolMgrStrategyRsp.Validate if the designated constraints
// aren't met.
type DeleteNodePoolMgrStrategyRspValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodePoolMgrStrategyRspValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodePoolMgrStrategyRspValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodePoolMgrStrategyRspValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodePoolMgrStrategyRspValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodePoolMgrStrategyRspValidationError) ErrorName() string {
	return "DeleteNodePoolMgrStrategyRspValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodePoolMgrStrategyRspValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodePoolMgrStrategyRsp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodePoolMgrStrategyRspValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodePoolMgrStrategyRspValidationError{}

// Validate checks the field values on NodeGroupStrategy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NodeGroupStrategy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupStrategy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeGroupStrategyMultiError, or nil if none found.
func (m *NodeGroupStrategy) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupStrategy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for Name

	// no validation rules for Labels

	// no validation rules for ResourcePool

	if all {
		switch v := interface{}(m.GetReservedNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupStrategyValidationError{
					field:  "ReservedNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupStrategyValidationError{
					field:  "ReservedNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReservedNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupStrategyValidationError{
				field:  "ReservedNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetElasticNodeGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeGroupStrategyValidationError{
						field:  fmt.Sprintf("ElasticNodeGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeGroupStrategyValidationError{
						field:  fmt.Sprintf("ElasticNodeGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeGroupStrategyValidationError{
					field:  fmt.Sprintf("ElasticNodeGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetStrategy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupStrategyValidationError{
					field:  "Strategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupStrategyValidationError{
					field:  "Strategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStrategy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupStrategyValidationError{
				field:  "Strategy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeGroupStrategyMultiError(errors)
	}
	return nil
}

// NodeGroupStrategyMultiError is an error wrapping multiple validation errors
// returned by NodeGroupStrategy.ValidateAll() if the designated constraints
// aren't met.
type NodeGroupStrategyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupStrategyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupStrategyMultiError) AllErrors() []error { return m }

// NodeGroupStrategyValidationError is the validation error returned by
// NodeGroupStrategy.Validate if the designated constraints aren't met.
type NodeGroupStrategyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupStrategyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupStrategyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupStrategyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupStrategyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupStrategyValidationError) ErrorName() string {
	return "NodeGroupStrategyValidationError"
}

// Error satisfies the builtin error interface
func (e NodeGroupStrategyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupStrategy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupStrategyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupStrategyValidationError{}

// Validate checks the field values on ReservedNodeGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReservedNodeGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReservedNodeGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReservedNodeGroupMultiError, or nil if none found.
func (m *ReservedNodeGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *ReservedNodeGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for NodeGroup

	// no validation rules for ConsumerId

	if len(errors) > 0 {
		return ReservedNodeGroupMultiError(errors)
	}
	return nil
}

// ReservedNodeGroupMultiError is an error wrapping multiple validation errors
// returned by ReservedNodeGroup.ValidateAll() if the designated constraints
// aren't met.
type ReservedNodeGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReservedNodeGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReservedNodeGroupMultiError) AllErrors() []error { return m }

// ReservedNodeGroupValidationError is the validation error returned by
// ReservedNodeGroup.Validate if the designated constraints aren't met.
type ReservedNodeGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReservedNodeGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReservedNodeGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReservedNodeGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReservedNodeGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReservedNodeGroupValidationError) ErrorName() string {
	return "ReservedNodeGroupValidationError"
}

// Error satisfies the builtin error interface
func (e ReservedNodeGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReservedNodeGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReservedNodeGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReservedNodeGroupValidationError{}

// Validate checks the field values on ElasticNodeGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ElasticNodeGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ElasticNodeGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ElasticNodeGroupMultiError, or nil if none found.
func (m *ElasticNodeGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *ElasticNodeGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for NodeGroup

	// no validation rules for ConsumerId

	// no validation rules for Weight

	if all {
		switch v := interface{}(m.GetLimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ElasticNodeGroupValidationError{
					field:  "Limit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ElasticNodeGroupValidationError{
					field:  "Limit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ElasticNodeGroupValidationError{
				field:  "Limit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ElasticNodeGroupMultiError(errors)
	}
	return nil
}

// ElasticNodeGroupMultiError is an error wrapping multiple validation errors
// returned by ElasticNodeGroup.ValidateAll() if the designated constraints
// aren't met.
type ElasticNodeGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ElasticNodeGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ElasticNodeGroupMultiError) AllErrors() []error { return m }

// ElasticNodeGroupValidationError is the validation error returned by
// ElasticNodeGroup.Validate if the designated constraints aren't met.
type ElasticNodeGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ElasticNodeGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ElasticNodeGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ElasticNodeGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ElasticNodeGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ElasticNodeGroupValidationError) ErrorName() string { return "ElasticNodeGroupValidationError" }

// Error satisfies the builtin error interface
func (e ElasticNodeGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sElasticNodeGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ElasticNodeGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ElasticNodeGroupValidationError{}

// Validate checks the field values on NodegroupLimit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodegroupLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodegroupLimit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodegroupLimitMultiError,
// or nil if none found.
func (m *NodegroupLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *NodegroupLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodegroupLimit

	// no validation rules for NodegroupLimitNum

	// no validation rules for ClusterLimit

	// no validation rules for ClusterLimitNum

	if len(errors) > 0 {
		return NodegroupLimitMultiError(errors)
	}
	return nil
}

// NodegroupLimitMultiError is an error wrapping multiple validation errors
// returned by NodegroupLimit.ValidateAll() if the designated constraints
// aren't met.
type NodegroupLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodegroupLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodegroupLimitMultiError) AllErrors() []error { return m }

// NodegroupLimitValidationError is the validation error returned by
// NodegroupLimit.Validate if the designated constraints aren't met.
type NodegroupLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodegroupLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodegroupLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodegroupLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodegroupLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodegroupLimitValidationError) ErrorName() string { return "NodegroupLimitValidationError" }

// Error satisfies the builtin error interface
func (e NodegroupLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodegroupLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodegroupLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodegroupLimitValidationError{}

// Validate checks the field values on Strategy with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Strategy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Strategy with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StrategyMultiError, or nil
// if none found.
func (m *Strategy) ValidateAll() error {
	return m.validate(true)
}

func (m *Strategy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for ScaleUpCoolDown

	// no validation rules for ScaleUpDelay

	// no validation rules for MinScaleUpSize

	// no validation rules for ScaleDownDelay

	// no validation rules for MaxIdleDelay

	// no validation rules for ReservedTimeRange

	if all {
		switch v := interface{}(m.GetBuffer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StrategyValidationError{
					field:  "Buffer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StrategyValidationError{
					field:  "Buffer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuffer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StrategyValidationError{
				field:  "Buffer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ScaleDownBeforeDDL

	{
		sorted_keys := make([]string, len(m.GetNodegroupBuffer()))
		i := 0
		for key := range m.GetNodegroupBuffer() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNodegroupBuffer()[key]
			_ = val

			// no validation rules for NodegroupBuffer[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, StrategyValidationError{
							field:  fmt.Sprintf("NodegroupBuffer[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, StrategyValidationError{
							field:  fmt.Sprintf("NodegroupBuffer[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return StrategyValidationError{
						field:  fmt.Sprintf("NodegroupBuffer[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetTimeMode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StrategyValidationError{
					field:  "TimeMode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StrategyValidationError{
					field:  "TimeMode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeMode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StrategyValidationError{
				field:  "TimeMode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StrategyMultiError(errors)
	}
	return nil
}

// StrategyMultiError is an error wrapping multiple validation errors returned
// by Strategy.ValidateAll() if the designated constraints aren't met.
type StrategyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StrategyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StrategyMultiError) AllErrors() []error { return m }

// StrategyValidationError is the validation error returned by
// Strategy.Validate if the designated constraints aren't met.
type StrategyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StrategyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StrategyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StrategyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StrategyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StrategyValidationError) ErrorName() string { return "StrategyValidationError" }

// Error satisfies the builtin error interface
func (e StrategyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStrategy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StrategyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StrategyValidationError{}

// Validate checks the field values on Buffer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Buffer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Buffer with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BufferMultiError, or nil if none found.
func (m *Buffer) ValidateAll() error {
	return m.validate(true)
}

func (m *Buffer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Low

	// no validation rules for High

	if len(errors) > 0 {
		return BufferMultiError(errors)
	}
	return nil
}

// BufferMultiError is an error wrapping multiple validation errors returned by
// Buffer.ValidateAll() if the designated constraints aren't met.
type BufferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BufferMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BufferMultiError) AllErrors() []error { return m }

// BufferValidationError is the validation error returned by Buffer.Validate if
// the designated constraints aren't met.
type BufferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BufferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BufferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BufferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BufferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BufferValidationError) ErrorName() string { return "BufferValidationError" }

// Error satisfies the builtin error interface
func (e BufferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBuffer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BufferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BufferValidationError{}

// Validate checks the field values on TimeMode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeMode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeModeMultiError, or nil
// if none found.
func (m *TimeMode) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScaleDownWhenTimeout

	for idx, item := range m.GetTimePeriods() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TimeModeValidationError{
						field:  fmt.Sprintf("TimePeriods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TimeModeValidationError{
						field:  fmt.Sprintf("TimePeriods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TimeModeValidationError{
					field:  fmt.Sprintf("TimePeriods[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReservedHours

	if len(errors) > 0 {
		return TimeModeMultiError(errors)
	}
	return nil
}

// TimeModeMultiError is an error wrapping multiple validation errors returned
// by TimeMode.ValidateAll() if the designated constraints aren't met.
type TimeModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeModeMultiError) AllErrors() []error { return m }

// TimeModeValidationError is the validation error returned by
// TimeMode.Validate if the designated constraints aren't met.
type TimeModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeModeValidationError) ErrorName() string { return "TimeModeValidationError" }

// Error satisfies the builtin error interface
func (e TimeModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeModeValidationError{}

// Validate checks the field values on TimePeriod with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimePeriod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimePeriod with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimePeriodMultiError, or
// nil if none found.
func (m *TimePeriod) ValidateAll() error {
	return m.validate(true)
}

func (m *TimePeriod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScaleOutCron

	// no validation rules for ScaleInCron

	// no validation rules for ScaleOutTime

	// no validation rules for ScaleInTime

	if len(errors) > 0 {
		return TimePeriodMultiError(errors)
	}
	return nil
}

// TimePeriodMultiError is an error wrapping multiple validation errors
// returned by TimePeriod.ValidateAll() if the designated constraints aren't met.
type TimePeriodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimePeriodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimePeriodMultiError) AllErrors() []error { return m }

// TimePeriodValidationError is the validation error returned by
// TimePeriod.Validate if the designated constraints aren't met.
type TimePeriodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimePeriodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimePeriodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimePeriodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimePeriodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimePeriodValidationError) ErrorName() string { return "TimePeriodValidationError" }

// Error satisfies the builtin error interface
func (e TimePeriodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimePeriod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimePeriodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimePeriodValidationError{}

// Validate checks the field values on BufferParam with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BufferParam) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BufferParam with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BufferParamMultiError, or
// nil if none found.
func (m *BufferParam) ValidateAll() error {
	return m.validate(true)
}

func (m *BufferParam) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Percent

	// no validation rules for Count

	if len(errors) > 0 {
		return BufferParamMultiError(errors)
	}
	return nil
}

// BufferParamMultiError is an error wrapping multiple validation errors
// returned by BufferParam.ValidateAll() if the designated constraints aren't met.
type BufferParamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BufferParamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BufferParamMultiError) AllErrors() []error { return m }

// BufferParamValidationError is the validation error returned by
// BufferParam.Validate if the designated constraints aren't met.
type BufferParamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BufferParamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BufferParamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BufferParamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BufferParamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BufferParamValidationError) ErrorName() string { return "BufferParamValidationError" }

// Error satisfies the builtin error interface
func (e BufferParamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBufferParam.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BufferParamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BufferParamValidationError{}

// Validate checks the field values on CreateOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateOptionsMultiError, or
// nil if none found.
func (m *CreateOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OverWriteIfExist

	// no validation rules for Operator

	if len(errors) > 0 {
		return CreateOptionsMultiError(errors)
	}
	return nil
}

// CreateOptionsMultiError is an error wrapping multiple validation errors
// returned by CreateOptions.ValidateAll() if the designated constraints
// aren't met.
type CreateOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOptionsMultiError) AllErrors() []error { return m }

// CreateOptionsValidationError is the validation error returned by
// CreateOptions.Validate if the designated constraints aren't met.
type CreateOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOptionsValidationError) ErrorName() string { return "CreateOptionsValidationError" }

// Error satisfies the builtin error interface
func (e CreateOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOptionsValidationError{}

// Validate checks the field values on UpdateOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateOptionsMultiError, or
// nil if none found.
func (m *UpdateOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreateIfNotExist

	// no validation rules for OverwriteZeroOrEmptyStr

	// no validation rules for Operator

	if len(errors) > 0 {
		return UpdateOptionsMultiError(errors)
	}
	return nil
}

// UpdateOptionsMultiError is an error wrapping multiple validation errors
// returned by UpdateOptions.ValidateAll() if the designated constraints
// aren't met.
type UpdateOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOptionsMultiError) AllErrors() []error { return m }

// UpdateOptionsValidationError is the validation error returned by
// UpdateOptions.Validate if the designated constraints aren't met.
type UpdateOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOptionsValidationError) ErrorName() string { return "UpdateOptionsValidationError" }

// Error satisfies the builtin error interface
func (e UpdateOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOptionsValidationError{}
