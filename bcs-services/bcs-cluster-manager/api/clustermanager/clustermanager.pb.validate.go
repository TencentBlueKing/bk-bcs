// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: clustermanager.proto

package clustermanager

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClusterMultiError, or nil if none found.
func (m *Cluster) ValidateAll() error {
	return m.validate(true)
}

func (m *Cluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	// no validation rules for ClusterName

	// no validation rules for FederationClusterID

	// no validation rules for Provider

	// no validation rules for Region

	// no validation rules for VpcID

	// no validation rules for ProjectID

	// no validation rules for BusinessID

	// no validation rules for Environment

	// no validation rules for EngineType

	// no validation rules for IsExclusive

	// no validation rules for ClusterType

	// no validation rules for Labels

	// no validation rules for Creator

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	{
		sorted_keys := make([]string, len(m.GetBcsAddons()))
		i := 0
		for key := range m.GetBcsAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetBcsAddons()[key]
			_ = val

			// no validation rules for BcsAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClusterValidationError{
						field:  fmt.Sprintf("BcsAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraAddons()))
		i := 0
		for key := range m.GetExtraAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraAddons()[key]
			_ = val

			// no validation rules for ExtraAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClusterValidationError{
						field:  fmt.Sprintf("ExtraAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for SystemID

	// no validation rules for ManageType

	{
		sorted_keys := make([]string, len(m.GetMaster()))
		i := 0
		for key := range m.GetMaster() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMaster()[key]
			_ = val

			// no validation rules for Master[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("Master[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("Master[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClusterValidationError{
						field:  fmt.Sprintf("Master[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetNetworkSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "NetworkSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterBasicSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterBasicSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "ClusterBasicSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterAdvanceSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAdvanceSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "ClusterAdvanceSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "NodeSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _Cluster_Status_InLookup[m.GetStatus()]; !ok {
		err := ClusterValidationError{
			field:  "Status",
			reason: "value must be in list [CREATING RUNNING DELETING FALURE INITIALIZATION]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Updater

	if _, ok := _Cluster_NetworkType_InLookup[m.GetNetworkType()]; !ok {
		err := ClusterValidationError{
			field:  "NetworkType",
			reason: "value must be in list [underlay overlay ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AutoGenerateMasterNodes

	for idx, item := range m.GetTemplate() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterValidationError{
						field:  fmt.Sprintf("Template[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterValidationError{
						field:  fmt.Sprintf("Template[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterValidationError{
					field:  fmt.Sprintf("Template[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtraInfo

	// no validation rules for ModuleID

	// no validation rules for ExtraClusterID

	// no validation rules for IsCommonCluster

	// no validation rules for Description

	// no validation rules for ClusterCategory

	// no validation rules for IsShared

	// no validation rules for KubeConfig

	// no validation rules for ImportCategory

	// no validation rules for CloudAccountID

	if len(errors) > 0 {
		return ClusterMultiError(errors)
	}

	return nil
}

// ClusterMultiError is an error wrapping multiple validation errors returned
// by Cluster.ValidateAll() if the designated constraints aren't met.
type ClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMultiError) AllErrors() []error { return m }

// ClusterValidationError is the validation error returned by Cluster.Validate
// if the designated constraints aren't met.
type ClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterValidationError) ErrorName() string { return "ClusterValidationError" }

// Error satisfies the builtin error interface
func (e ClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterValidationError{}

var _Cluster_Status_InLookup = map[string]struct{}{
	"CREATING":       {},
	"RUNNING":        {},
	"DELETING":       {},
	"FALURE":         {},
	"INITIALIZATION": {},
}

var _Cluster_NetworkType_InLookup = map[string]struct{}{
	"underlay": {},
	"overlay":  {},
	"":         {},
}

// Validate checks the field values on Node with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Node) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Node with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NodeMultiError, or nil if none found.
func (m *Node) ValidateAll() error {
	return m.validate(true)
}

func (m *Node) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeID

	// no validation rules for InnerIP

	// no validation rules for InstanceType

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for Status

	// no validation rules for ZoneID

	// no validation rules for NodeGroupID

	// no validation rules for ClusterID

	// no validation rules for VPC

	// no validation rules for Region

	// no validation rules for Passwd

	// no validation rules for Zone

	// no validation rules for DeviceID

	// no validation rules for NodeTemplateID

	// no validation rules for NodeType

	// no validation rules for NodeName

	// no validation rules for InnerIPv6

	if len(errors) > 0 {
		return NodeMultiError(errors)
	}

	return nil
}

// NodeMultiError is an error wrapping multiple validation errors returned by
// Node.ValidateAll() if the designated constraints aren't met.
type NodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeMultiError) AllErrors() []error { return m }

// NodeValidationError is the validation error returned by Node.Validate if the
// designated constraints aren't met.
type NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeValidationError) ErrorName() string { return "NodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeValidationError{}

// Validate checks the field values on NetworkSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NetworkSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkSetting with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetworkSettingMultiError,
// or nil if none found.
func (m *NetworkSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterIPv4CIDR

	// no validation rules for ServiceIPv4CIDR

	// no validation rules for MaxNodePodNum

	// no validation rules for MaxServiceNum

	// no validation rules for EnableVPCCni

	if all {
		switch v := interface{}(m.GetSubnetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetworkSettingValidationError{
					field:  "SubnetSource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetworkSettingValidationError{
					field:  "SubnetSource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubnetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetworkSettingValidationError{
				field:  "SubnetSource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsStaticIpMode

	// no validation rules for ClaimExpiredSeconds

	// no validation rules for CidrStep

	if len(errors) > 0 {
		return NetworkSettingMultiError(errors)
	}

	return nil
}

// NetworkSettingMultiError is an error wrapping multiple validation errors
// returned by NetworkSetting.ValidateAll() if the designated constraints
// aren't met.
type NetworkSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkSettingMultiError) AllErrors() []error { return m }

// NetworkSettingValidationError is the validation error returned by
// NetworkSetting.Validate if the designated constraints aren't met.
type NetworkSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkSettingValidationError) ErrorName() string { return "NetworkSettingValidationError" }

// Error satisfies the builtin error interface
func (e NetworkSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkSettingValidationError{}

// Validate checks the field values on SubnetSource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubnetSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubnetSource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubnetSourceMultiError, or
// nil if none found.
func (m *SubnetSource) ValidateAll() error {
	return m.validate(true)
}

func (m *SubnetSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNew()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubnetSourceValidationError{
					field:  "New",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubnetSourceValidationError{
					field:  "New",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNew()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubnetSourceValidationError{
				field:  "New",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExisted()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubnetSourceValidationError{
					field:  "Existed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubnetSourceValidationError{
					field:  "Existed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExisted()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubnetSourceValidationError{
				field:  "Existed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubnetSourceMultiError(errors)
	}

	return nil
}

// SubnetSourceMultiError is an error wrapping multiple validation errors
// returned by SubnetSource.ValidateAll() if the designated constraints aren't met.
type SubnetSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubnetSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubnetSourceMultiError) AllErrors() []error { return m }

// SubnetSourceValidationError is the validation error returned by
// SubnetSource.Validate if the designated constraints aren't met.
type SubnetSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubnetSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubnetSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubnetSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubnetSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubnetSourceValidationError) ErrorName() string { return "SubnetSourceValidationError" }

// Error satisfies the builtin error interface
func (e SubnetSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubnetSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubnetSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubnetSourceValidationError{}

// Validate checks the field values on ExistedSubnetIDs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExistedSubnetIDs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExistedSubnetIDs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExistedSubnetIDsMultiError, or nil if none found.
func (m *ExistedSubnetIDs) ValidateAll() error {
	return m.validate(true)
}

func (m *ExistedSubnetIDs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExistedSubnetIDsMultiError(errors)
	}

	return nil
}

// ExistedSubnetIDsMultiError is an error wrapping multiple validation errors
// returned by ExistedSubnetIDs.ValidateAll() if the designated constraints
// aren't met.
type ExistedSubnetIDsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistedSubnetIDsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistedSubnetIDsMultiError) AllErrors() []error { return m }

// ExistedSubnetIDsValidationError is the validation error returned by
// ExistedSubnetIDs.Validate if the designated constraints aren't met.
type ExistedSubnetIDsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistedSubnetIDsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistedSubnetIDsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistedSubnetIDsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistedSubnetIDsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistedSubnetIDsValidationError) ErrorName() string { return "ExistedSubnetIDsValidationError" }

// Error satisfies the builtin error interface
func (e ExistedSubnetIDsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistedSubnetIDs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistedSubnetIDsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistedSubnetIDsValidationError{}

// Validate checks the field values on NewSubnet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NewSubnet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NewSubnet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NewSubnetMultiError, or nil
// if none found.
func (m *NewSubnet) ValidateAll() error {
	return m.validate(true)
}

func (m *NewSubnet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mask

	// no validation rules for Zone

	if len(errors) > 0 {
		return NewSubnetMultiError(errors)
	}

	return nil
}

// NewSubnetMultiError is an error wrapping multiple validation errors returned
// by NewSubnet.ValidateAll() if the designated constraints aren't met.
type NewSubnetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NewSubnetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NewSubnetMultiError) AllErrors() []error { return m }

// NewSubnetValidationError is the validation error returned by
// NewSubnet.Validate if the designated constraints aren't met.
type NewSubnetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NewSubnetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NewSubnetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NewSubnetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NewSubnetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NewSubnetValidationError) ErrorName() string { return "NewSubnetValidationError" }

// Error satisfies the builtin error interface
func (e NewSubnetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNewSubnet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NewSubnetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NewSubnetValidationError{}

// Validate checks the field values on ClusterBasicSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterBasicSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterBasicSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterBasicSettingMultiError, or nil if none found.
func (m *ClusterBasicSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterBasicSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OS

	// no validation rules for Version

	// no validation rules for ClusterTags

	// no validation rules for VersionName

	if len(errors) > 0 {
		return ClusterBasicSettingMultiError(errors)
	}

	return nil
}

// ClusterBasicSettingMultiError is an error wrapping multiple validation
// errors returned by ClusterBasicSetting.ValidateAll() if the designated
// constraints aren't met.
type ClusterBasicSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterBasicSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterBasicSettingMultiError) AllErrors() []error { return m }

// ClusterBasicSettingValidationError is the validation error returned by
// ClusterBasicSetting.Validate if the designated constraints aren't met.
type ClusterBasicSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterBasicSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterBasicSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterBasicSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterBasicSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterBasicSettingValidationError) ErrorName() string {
	return "ClusterBasicSettingValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterBasicSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterBasicSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterBasicSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterBasicSettingValidationError{}

// Validate checks the field values on ClusterAdvanceSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAdvanceSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAdvanceSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterAdvanceSettingMultiError, or nil if none found.
func (m *ClusterAdvanceSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAdvanceSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IPVS

	// no validation rules for ContainerRuntime

	// no validation rules for RuntimeVersion

	// no validation rules for ExtraArgs

	if len(errors) > 0 {
		return ClusterAdvanceSettingMultiError(errors)
	}

	return nil
}

// ClusterAdvanceSettingMultiError is an error wrapping multiple validation
// errors returned by ClusterAdvanceSetting.ValidateAll() if the designated
// constraints aren't met.
type ClusterAdvanceSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAdvanceSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAdvanceSettingMultiError) AllErrors() []error { return m }

// ClusterAdvanceSettingValidationError is the validation error returned by
// ClusterAdvanceSetting.Validate if the designated constraints aren't met.
type ClusterAdvanceSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAdvanceSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAdvanceSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAdvanceSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAdvanceSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAdvanceSettingValidationError) ErrorName() string {
	return "ClusterAdvanceSettingValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAdvanceSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAdvanceSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAdvanceSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAdvanceSettingValidationError{}

// Validate checks the field values on NodeSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeSettingMultiError, or
// nil if none found.
func (m *NodeSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DockerGraphPath

	// no validation rules for MountTarget

	// no validation rules for UnSchedulable

	// no validation rules for Labels

	// no validation rules for ExtraArgs

	if len(errors) > 0 {
		return NodeSettingMultiError(errors)
	}

	return nil
}

// NodeSettingMultiError is an error wrapping multiple validation errors
// returned by NodeSetting.ValidateAll() if the designated constraints aren't met.
type NodeSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSettingMultiError) AllErrors() []error { return m }

// NodeSettingValidationError is the validation error returned by
// NodeSetting.Validate if the designated constraints aren't met.
type NodeSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSettingValidationError) ErrorName() string { return "NodeSettingValidationError" }

// Error satisfies the builtin error interface
func (e NodeSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSettingValidationError{}

// Validate checks the field values on ClusterCredential with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClusterCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterCredentialMultiError, or nil if none found.
func (m *ClusterCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerKey

	// no validation rules for ClusterID

	// no validation rules for ClientModule

	// no validation rules for ServerAddress

	// no validation rules for CaCertData

	// no validation rules for UserToken

	// no validation rules for ClusterDomain

	// no validation rules for ConnectMode

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for ClientCert

	// no validation rules for ClientKey

	if len(errors) > 0 {
		return ClusterCredentialMultiError(errors)
	}

	return nil
}

// ClusterCredentialMultiError is an error wrapping multiple validation errors
// returned by ClusterCredential.ValidateAll() if the designated constraints
// aren't met.
type ClusterCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterCredentialMultiError) AllErrors() []error { return m }

// ClusterCredentialValidationError is the validation error returned by
// ClusterCredential.Validate if the designated constraints aren't met.
type ClusterCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterCredentialValidationError) ErrorName() string {
	return "ClusterCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterCredentialValidationError{}

// Validate checks the field values on Namespace with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Namespace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Namespace with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamespaceMultiError, or nil
// if none found.
func (m *Namespace) ValidateAll() error {
	return m.validate(true)
}

func (m *Namespace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for FederationClusterID

	// no validation rules for ProjectID

	// no validation rules for BusinessID

	// no validation rules for Labels

	// no validation rules for MaxQuota

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	for idx, item := range m.GetQuotaList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NamespaceValidationError{
						field:  fmt.Sprintf("QuotaList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NamespaceValidationError{
						field:  fmt.Sprintf("QuotaList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NamespaceValidationError{
					field:  fmt.Sprintf("QuotaList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NamespaceMultiError(errors)
	}

	return nil
}

// NamespaceMultiError is an error wrapping multiple validation errors returned
// by Namespace.ValidateAll() if the designated constraints aren't met.
type NamespaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceMultiError) AllErrors() []error { return m }

// NamespaceValidationError is the validation error returned by
// Namespace.Validate if the designated constraints aren't met.
type NamespaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceValidationError) ErrorName() string { return "NamespaceValidationError" }

// Error satisfies the builtin error interface
func (e NamespaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceValidationError{}

// Validate checks the field values on ResourceQuota with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceQuota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceQuota with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceQuotaMultiError, or
// nil if none found.
func (m *ResourceQuota) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceQuota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	// no validation rules for FederationClusterID

	// no validation rules for ClusterID

	// no validation rules for ResourceQuota

	// no validation rules for Region

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for Status

	// no validation rules for Message

	if len(errors) > 0 {
		return ResourceQuotaMultiError(errors)
	}

	return nil
}

// ResourceQuotaMultiError is an error wrapping multiple validation errors
// returned by ResourceQuota.ValidateAll() if the designated constraints
// aren't met.
type ResourceQuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceQuotaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceQuotaMultiError) AllErrors() []error { return m }

// ResourceQuotaValidationError is the validation error returned by
// ResourceQuota.Validate if the designated constraints aren't met.
type ResourceQuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceQuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceQuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceQuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceQuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceQuotaValidationError) ErrorName() string { return "ResourceQuotaValidationError" }

// Error satisfies the builtin error interface
func (e ResourceQuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceQuota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceQuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceQuotaValidationError{}

// Validate checks the field values on Credential with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Credential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Credential with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CredentialMultiError, or
// nil if none found.
func (m *Credential) ValidateAll() error {
	return m.validate(true)
}

func (m *Credential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Secret

	// no validation rules for SubscriptionID

	// no validation rules for TenantID

	// no validation rules for ResourceGroupName

	// no validation rules for ClientID

	// no validation rules for ClientSecret

	// no validation rules for ServiceAccountSecret

	// no validation rules for GkeProjectID

	if len(errors) > 0 {
		return CredentialMultiError(errors)
	}

	return nil
}

// CredentialMultiError is an error wrapping multiple validation errors
// returned by Credential.ValidateAll() if the designated constraints aren't met.
type CredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialMultiError) AllErrors() []error { return m }

// CredentialValidationError is the validation error returned by
// Credential.Validate if the designated constraints aren't met.
type CredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialValidationError) ErrorName() string { return "CredentialValidationError" }

// Error satisfies the builtin error interface
func (e CredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialValidationError{}

// Validate checks the field values on BKOpsPlugin with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BKOpsPlugin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BKOpsPlugin with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BKOpsPluginMultiError, or
// nil if none found.
func (m *BKOpsPlugin) ValidateAll() error {
	return m.validate(true)
}

func (m *BKOpsPlugin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for System

	// no validation rules for Link

	// no validation rules for Params

	if len(errors) > 0 {
		return BKOpsPluginMultiError(errors)
	}

	return nil
}

// BKOpsPluginMultiError is an error wrapping multiple validation errors
// returned by BKOpsPlugin.ValidateAll() if the designated constraints aren't met.
type BKOpsPluginMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BKOpsPluginMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BKOpsPluginMultiError) AllErrors() []error { return m }

// BKOpsPluginValidationError is the validation error returned by
// BKOpsPlugin.Validate if the designated constraints aren't met.
type BKOpsPluginValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BKOpsPluginValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BKOpsPluginValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BKOpsPluginValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BKOpsPluginValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BKOpsPluginValidationError) ErrorName() string { return "BKOpsPluginValidationError" }

// Error satisfies the builtin error interface
func (e BKOpsPluginValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBKOpsPlugin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BKOpsPluginValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BKOpsPluginValidationError{}

// Validate checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Action) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ActionMultiError, or nil if none found.
func (m *Action) ValidateAll() error {
	return m.validate(true)
}

func (m *Action) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetPlugins()))
		i := 0
		for key := range m.GetPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPlugins()[key]
			_ = val

			// no validation rules for Plugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ActionValidationError{
							field:  fmt.Sprintf("Plugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ActionValidationError{
							field:  fmt.Sprintf("Plugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ActionValidationError{
						field:  fmt.Sprintf("Plugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ActionMultiError(errors)
	}

	return nil
}

// ActionMultiError is an error wrapping multiple validation errors returned by
// Action.ValidateAll() if the designated constraints aren't met.
type ActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionMultiError) AllErrors() []error { return m }

// ActionValidationError is the validation error returned by Action.Validate if
// the designated constraints aren't met.
type ActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionValidationError) ErrorName() string { return "ActionValidationError" }

// Error satisfies the builtin error interface
func (e ActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionValidationError{}

// Validate checks the field values on ClusterMgr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterMgr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterMgr with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterMgrMultiError, or
// nil if none found.
func (m *ClusterMgr) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterMgr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "CreateCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "CreateCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "CreateCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "DeleteCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "DeleteCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "DeleteCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAddNodesToCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "AddNodesToCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "AddNodesToCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddNodesToCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "AddNodesToCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteNodesFromCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "DeleteNodesFromCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "DeleteNodesFromCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteNodesFromCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "DeleteNodesFromCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterMgrMultiError(errors)
	}

	return nil
}

// ClusterMgrMultiError is an error wrapping multiple validation errors
// returned by ClusterMgr.ValidateAll() if the designated constraints aren't met.
type ClusterMgrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMgrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMgrMultiError) AllErrors() []error { return m }

// ClusterMgrValidationError is the validation error returned by
// ClusterMgr.Validate if the designated constraints aren't met.
type ClusterMgrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterMgrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterMgrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterMgrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterMgrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterMgrValidationError) ErrorName() string { return "ClusterMgrValidationError" }

// Error satisfies the builtin error interface
func (e ClusterMgrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterMgr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterMgrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterMgrValidationError{}

// Validate checks the field values on NodeGroupMgr with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroupMgr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupMgr with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupMgrMultiError, or
// nil if none found.
func (m *NodeGroupMgr) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupMgr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "CreateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "CreateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "CreateNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "DeleteNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "DeleteNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "DeleteNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMoveNodesToGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "MoveNodesToGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "MoveNodesToGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMoveNodesToGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "MoveNodesToGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoveNodesFromGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "RemoveNodesFromGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "RemoveNodesFromGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoveNodesFromGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "RemoveNodesFromGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCleanNodesInGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "CleanNodesInGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "CleanNodesInGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCleanNodesInGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "CleanNodesInGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateDesiredNodes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "UpdateDesiredNodes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "UpdateDesiredNodes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateDesiredNodes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "UpdateDesiredNodes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeGroupMgrMultiError(errors)
	}

	return nil
}

// NodeGroupMgrMultiError is an error wrapping multiple validation errors
// returned by NodeGroupMgr.ValidateAll() if the designated constraints aren't met.
type NodeGroupMgrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupMgrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupMgrMultiError) AllErrors() []error { return m }

// NodeGroupMgrValidationError is the validation error returned by
// NodeGroupMgr.Validate if the designated constraints aren't met.
type NodeGroupMgrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupMgrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupMgrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupMgrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupMgrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupMgrValidationError) ErrorName() string { return "NodeGroupMgrValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupMgrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupMgr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupMgrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupMgrValidationError{}

// Validate checks the field values on OSInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OSInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OSInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OSInfoMultiError, or nil if none found.
func (m *OSInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OSInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Regions

	if len(errors) > 0 {
		return OSInfoMultiError(errors)
	}

	return nil
}

// OSInfoMultiError is an error wrapping multiple validation errors returned by
// OSInfo.ValidateAll() if the designated constraints aren't met.
type OSInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OSInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OSInfoMultiError) AllErrors() []error { return m }

// OSInfoValidationError is the validation error returned by OSInfo.Validate if
// the designated constraints aren't met.
type OSInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OSInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OSInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OSInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OSInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OSInfoValidationError) ErrorName() string { return "OSInfoValidationError" }

// Error satisfies the builtin error interface
func (e OSInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOSInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OSInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OSInfoValidationError{}

// Validate checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Account) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AccountMultiError, or nil if none found.
func (m *Account) ValidateAll() error {
	return m.validate(true)
}

func (m *Account) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecretID

	// no validation rules for SecretKey

	// no validation rules for SubscriptionID

	// no validation rules for TenantID

	// no validation rules for ResourceGroupName

	// no validation rules for ClientID

	// no validation rules for ClientSecret

	// no validation rules for ServiceAccountSecret

	// no validation rules for GkeProjectID

	if len(errors) > 0 {
		return AccountMultiError(errors)
	}

	return nil
}

// AccountMultiError is an error wrapping multiple validation errors returned
// by Account.ValidateAll() if the designated constraints aren't met.
type AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountMultiError) AllErrors() []error { return m }

// AccountValidationError is the validation error returned by Account.Validate
// if the designated constraints aren't met.
type AccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountValidationError) ErrorName() string { return "AccountValidationError" }

// Error satisfies the builtin error interface
func (e AccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountValidationError{}

// Validate checks the field values on CloudAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudAccountMultiError, or
// nil if none found.
func (m *CloudAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for ProjectID

	// no validation rules for AccountID

	// no validation rules for AccountName

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudAccountValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudAccountValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudAccountValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Enable

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return CloudAccountMultiError(errors)
	}

	return nil
}

// CloudAccountMultiError is an error wrapping multiple validation errors
// returned by CloudAccount.ValidateAll() if the designated constraints aren't met.
type CloudAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAccountMultiError) AllErrors() []error { return m }

// CloudAccountValidationError is the validation error returned by
// CloudAccount.Validate if the designated constraints aren't met.
type CloudAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAccountValidationError) ErrorName() string { return "CloudAccountValidationError" }

// Error satisfies the builtin error interface
func (e CloudAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAccountValidationError{}

// Validate checks the field values on CreateCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudAccountRequestMultiError, or nil if none found.
func (m *CreateCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 1024 {
		err := CreateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudAccountRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := CreateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountName()) < 1 {
		err := CreateCloudAccountRequestValidationError{
			field:  "AccountName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudAccountRequestValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudAccountRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudAccountRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudAccountRequestValidationError{
				field:  "Enable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 1024 {
		err := CreateCloudAccountRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudAccountRequest_Creator_Pattern.MatchString(m.GetCreator()) {
		err := CreateCloudAccountRequestValidationError{
			field:  "Creator",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 2 {
		err := CreateCloudAccountRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateCloudAccountRequestMultiError(errors)
	}

	return nil
}

// CreateCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by CreateCloudAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudAccountRequestMultiError) AllErrors() []error { return m }

// CreateCloudAccountRequestValidationError is the validation error returned by
// CreateCloudAccountRequest.Validate if the designated constraints aren't met.
type CreateCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudAccountRequestValidationError) ErrorName() string {
	return "CreateCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudAccountRequestValidationError{}

var _CreateCloudAccountRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudAccountRequest_Creator_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudAccountResponseMultiError, or nil if none found.
func (m *CreateCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateCloudAccountResponseMultiError(errors)
	}

	return nil
}

// CreateCloudAccountResponseMultiError is an error wrapping multiple
// validation errors returned by CreateCloudAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudAccountResponseMultiError) AllErrors() []error { return m }

// CreateCloudAccountResponseValidationError is the validation error returned
// by CreateCloudAccountResponse.Validate if the designated constraints aren't met.
type CreateCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudAccountResponseValidationError) ErrorName() string {
	return "CreateCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudAccountResponseValidationError{}

// Validate checks the field values on UpdateCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudAccountRequestMultiError, or nil if none found.
func (m *UpdateCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 1024 {
		err := UpdateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudAccountRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := UpdateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAccountID()); l < 2 || l > 1024 {
		err := UpdateCloudAccountRequestValidationError{
			field:  "AccountID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudAccountRequest_AccountID_Pattern.MatchString(m.GetAccountID()) {
		err := UpdateCloudAccountRequestValidationError{
			field:  "AccountID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountName

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetEnable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudAccountRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudAccountRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudAccountRequestValidationError{
				field:  "Enable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProjectID

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 1024 {
		err := UpdateCloudAccountRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudAccountRequest_Updater_Pattern.MatchString(m.GetUpdater()) {
		err := UpdateCloudAccountRequestValidationError{
			field:  "Updater",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateCloudAccountRequestMultiError(errors)
	}

	return nil
}

// UpdateCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateCloudAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudAccountRequestMultiError) AllErrors() []error { return m }

// UpdateCloudAccountRequestValidationError is the validation error returned by
// UpdateCloudAccountRequest.Validate if the designated constraints aren't met.
type UpdateCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudAccountRequestValidationError) ErrorName() string {
	return "UpdateCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudAccountRequestValidationError{}

var _UpdateCloudAccountRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateCloudAccountRequest_AccountID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateCloudAccountRequest_Updater_Pattern = regexp.MustCompile("^[0-9a-zA-Z]+$")

// Validate checks the field values on UpdateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudAccountResponseMultiError, or nil if none found.
func (m *UpdateCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateCloudAccountResponseMultiError(errors)
	}

	return nil
}

// UpdateCloudAccountResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateCloudAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudAccountResponseMultiError) AllErrors() []error { return m }

// UpdateCloudAccountResponseValidationError is the validation error returned
// by UpdateCloudAccountResponse.Validate if the designated constraints aren't met.
type UpdateCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudAccountResponseValidationError) ErrorName() string {
	return "UpdateCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudAccountResponseValidationError{}

// Validate checks the field values on DeleteCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudAccountRequestMultiError, or nil if none found.
func (m *DeleteCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 1024 {
		err := DeleteCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudAccountRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := DeleteCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAccountID()); l < 2 || l > 1024 {
		err := DeleteCloudAccountRequestValidationError{
			field:  "AccountID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudAccountRequest_AccountID_Pattern.MatchString(m.GetAccountID()) {
		err := DeleteCloudAccountRequestValidationError{
			field:  "AccountID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteCloudAccountRequestMultiError(errors)
	}

	return nil
}

// DeleteCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCloudAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudAccountRequestMultiError) AllErrors() []error { return m }

// DeleteCloudAccountRequestValidationError is the validation error returned by
// DeleteCloudAccountRequest.Validate if the designated constraints aren't met.
type DeleteCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudAccountRequestValidationError) ErrorName() string {
	return "DeleteCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudAccountRequestValidationError{}

var _DeleteCloudAccountRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _DeleteCloudAccountRequest_AccountID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudAccountResponseMultiError, or nil if none found.
func (m *DeleteCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DeleteCloudAccountResponseMultiError(errors)
	}

	return nil
}

// DeleteCloudAccountResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteCloudAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudAccountResponseMultiError) AllErrors() []error { return m }

// DeleteCloudAccountResponseValidationError is the validation error returned
// by DeleteCloudAccountResponse.Validate if the designated constraints aren't met.
type DeleteCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudAccountResponseValidationError) ErrorName() string {
	return "DeleteCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudAccountResponseValidationError{}

// Validate checks the field values on ListCloudAccountPermRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudAccountPermRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudAccountPermRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudAccountPermRequestMultiError, or nil if none found.
func (m *ListCloudAccountPermRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudAccountPermRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for AccountName

	if len(errors) > 0 {
		return ListCloudAccountPermRequestMultiError(errors)
	}

	return nil
}

// ListCloudAccountPermRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudAccountPermRequest.ValidateAll() if
// the designated constraints aren't met.
type ListCloudAccountPermRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudAccountPermRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudAccountPermRequestMultiError) AllErrors() []error { return m }

// ListCloudAccountPermRequestValidationError is the validation error returned
// by ListCloudAccountPermRequest.Validate if the designated constraints
// aren't met.
type ListCloudAccountPermRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudAccountPermRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudAccountPermRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudAccountPermRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudAccountPermRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudAccountPermRequestValidationError) ErrorName() string {
	return "ListCloudAccountPermRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudAccountPermRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudAccountPermRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudAccountPermRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudAccountPermRequestValidationError{}

// Validate checks the field values on ListCloudAccountPermResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudAccountPermResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudAccountPermResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudAccountPermResponseMultiError, or nil if none found.
func (m *ListCloudAccountPermResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudAccountPermResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudAccountPermResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudAccountPermResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudAccountPermResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudAccountPermResponseMultiError(errors)
	}

	return nil
}

// ListCloudAccountPermResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudAccountPermResponse.ValidateAll() if
// the designated constraints aren't met.
type ListCloudAccountPermResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudAccountPermResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudAccountPermResponseMultiError) AllErrors() []error { return m }

// ListCloudAccountPermResponseValidationError is the validation error returned
// by ListCloudAccountPermResponse.Validate if the designated constraints
// aren't met.
type ListCloudAccountPermResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudAccountPermResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudAccountPermResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudAccountPermResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudAccountPermResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudAccountPermResponseValidationError) ErrorName() string {
	return "ListCloudAccountPermResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudAccountPermResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudAccountPermResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudAccountPermResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudAccountPermResponseValidationError{}

// Validate checks the field values on ListCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudAccountRequestMultiError, or nil if none found.
func (m *ListCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 1024 {
		err := ListCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountID

	// no validation rules for ProjectID

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListCloudAccountRequestMultiError(errors)
	}

	return nil
}

// ListCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudAccountRequestMultiError) AllErrors() []error { return m }

// ListCloudAccountRequestValidationError is the validation error returned by
// ListCloudAccountRequest.Validate if the designated constraints aren't met.
type ListCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudAccountRequestValidationError) ErrorName() string {
	return "ListCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudAccountRequestValidationError{}

// Validate checks the field values on CloudAccountInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudAccountInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudAccountInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudAccountInfoMultiError, or nil if none found.
func (m *CloudAccountInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudAccountInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudAccountInfoValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudAccountInfoValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudAccountInfoValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CloudAccountInfoMultiError(errors)
	}

	return nil
}

// CloudAccountInfoMultiError is an error wrapping multiple validation errors
// returned by CloudAccountInfo.ValidateAll() if the designated constraints
// aren't met.
type CloudAccountInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAccountInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAccountInfoMultiError) AllErrors() []error { return m }

// CloudAccountInfoValidationError is the validation error returned by
// CloudAccountInfo.Validate if the designated constraints aren't met.
type CloudAccountInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAccountInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAccountInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAccountInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAccountInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAccountInfoValidationError) ErrorName() string { return "CloudAccountInfoValidationError" }

// Error satisfies the builtin error interface
func (e CloudAccountInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudAccountInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAccountInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAccountInfoValidationError{}

// Validate checks the field values on ListCloudAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudAccountResponseMultiError, or nil if none found.
func (m *ListCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudAccountResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudAccountResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudAccountResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCloudAccountResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCloudAccountResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCloudAccountResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCloudAccountResponseMultiError(errors)
	}

	return nil
}

// ListCloudAccountResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudAccountResponseMultiError) AllErrors() []error { return m }

// ListCloudAccountResponseValidationError is the validation error returned by
// ListCloudAccountResponse.Validate if the designated constraints aren't met.
type ListCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudAccountResponseValidationError) ErrorName() string {
	return "ListCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudAccountResponseValidationError{}

// Validate checks the field values on CloudVPC with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudVPC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudVPC with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudVPCMultiError, or nil
// if none found.
func (m *CloudVPC) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudVPC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Region

	// no validation rules for RegionName

	// no validation rules for NetworkType

	// no validation rules for VpcID

	// no validation rules for VpcName

	// no validation rules for Available

	// no validation rules for Extra

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return CloudVPCMultiError(errors)
	}

	return nil
}

// CloudVPCMultiError is an error wrapping multiple validation errors returned
// by CloudVPC.ValidateAll() if the designated constraints aren't met.
type CloudVPCMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudVPCMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudVPCMultiError) AllErrors() []error { return m }

// CloudVPCValidationError is the validation error returned by
// CloudVPC.Validate if the designated constraints aren't met.
type CloudVPCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudVPCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudVPCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudVPCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudVPCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudVPCValidationError) ErrorName() string { return "CloudVPCValidationError" }

// Error satisfies the builtin error interface
func (e CloudVPCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudVPC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudVPCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudVPCValidationError{}

// Validate checks the field values on CreateCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudVPCRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudVPCRequestMultiError, or nil if none found.
func (m *CreateCloudVPCRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudVPCRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateCloudVPCRequest_NetworkType_InLookup[m.GetNetworkType()]; !ok {
		err := CreateCloudVPCRequestValidationError{
			field:  "NetworkType",
			reason: "value must be in list [overlay underlay]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "Region",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_Region_Pattern.MatchString(m.GetRegion()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RegionName

	if l := utf8.RuneCountInString(m.GetVpcName()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "VpcName",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_VpcName_Pattern.MatchString(m.GetVpcName()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "VpcName",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVpcID()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_VpcID_Pattern.MatchString(m.GetVpcID()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateCloudVPCRequest_Available_InLookup[m.GetAvailable()]; !ok {
		err := CreateCloudVPCRequestValidationError{
			field:  "Available",
			reason: "value must be in list [true false]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_Creator_Pattern.MatchString(m.GetCreator()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "Creator",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateCloudVPCRequestMultiError(errors)
	}

	return nil
}

// CreateCloudVPCRequestMultiError is an error wrapping multiple validation
// errors returned by CreateCloudVPCRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateCloudVPCRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudVPCRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudVPCRequestMultiError) AllErrors() []error { return m }

// CreateCloudVPCRequestValidationError is the validation error returned by
// CreateCloudVPCRequest.Validate if the designated constraints aren't met.
type CreateCloudVPCRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudVPCRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudVPCRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudVPCRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudVPCRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudVPCRequestValidationError) ErrorName() string {
	return "CreateCloudVPCRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudVPCRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudVPCRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudVPCRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudVPCRequestValidationError{}

var _CreateCloudVPCRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudVPCRequest_NetworkType_InLookup = map[string]struct{}{
	"overlay":  {},
	"underlay": {},
}

var _CreateCloudVPCRequest_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudVPCRequest_VpcName_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudVPCRequest_VpcID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudVPCRequest_Available_InLookup = map[string]struct{}{
	"true":  {},
	"false": {},
}

var _CreateCloudVPCRequest_Creator_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudVPCResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudVPCResponseMultiError, or nil if none found.
func (m *CreateCloudVPCResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudVPCResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateCloudVPCResponseMultiError(errors)
	}

	return nil
}

// CreateCloudVPCResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCloudVPCResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCloudVPCResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudVPCResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudVPCResponseMultiError) AllErrors() []error { return m }

// CreateCloudVPCResponseValidationError is the validation error returned by
// CreateCloudVPCResponse.Validate if the designated constraints aren't met.
type CreateCloudVPCResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudVPCResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudVPCResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudVPCResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudVPCResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudVPCResponseValidationError) ErrorName() string {
	return "CreateCloudVPCResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudVPCResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudVPCResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudVPCResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudVPCResponseValidationError{}

// Validate checks the field values on UpdateCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudVPCRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudVPCRequestMultiError, or nil if none found.
func (m *UpdateCloudVPCRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudVPCRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 100 {
		err := UpdateCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudVPCRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := UpdateCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NetworkType

	// no validation rules for Region

	// no validation rules for RegionName

	// no validation rules for VpcName

	if l := utf8.RuneCountInString(m.GetVpcID()); l < 2 || l > 100 {
		err := UpdateCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudVPCRequest_VpcID_Pattern.MatchString(m.GetVpcID()) {
		err := UpdateCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateCloudVPCRequest_Available_InLookup[m.GetAvailable()]; !ok {
		err := UpdateCloudVPCRequestValidationError{
			field:  "Available",
			reason: "value must be in list [ true false]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 100 {
		err := UpdateCloudVPCRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudVPCRequest_Updater_Pattern.MatchString(m.GetUpdater()) {
		err := UpdateCloudVPCRequestValidationError{
			field:  "Updater",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateCloudVPCRequestMultiError(errors)
	}

	return nil
}

// UpdateCloudVPCRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateCloudVPCRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateCloudVPCRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudVPCRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudVPCRequestMultiError) AllErrors() []error { return m }

// UpdateCloudVPCRequestValidationError is the validation error returned by
// UpdateCloudVPCRequest.Validate if the designated constraints aren't met.
type UpdateCloudVPCRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudVPCRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudVPCRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudVPCRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudVPCRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudVPCRequestValidationError) ErrorName() string {
	return "UpdateCloudVPCRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudVPCRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudVPCRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudVPCRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudVPCRequestValidationError{}

var _UpdateCloudVPCRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateCloudVPCRequest_VpcID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateCloudVPCRequest_Available_InLookup = map[string]struct{}{
	"":      {},
	"true":  {},
	"false": {},
}

var _UpdateCloudVPCRequest_Updater_Pattern = regexp.MustCompile("^[0-9a-zA-Z]+$")

// Validate checks the field values on UpdateCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudVPCResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudVPCResponseMultiError, or nil if none found.
func (m *UpdateCloudVPCResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudVPCResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudVPCResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudVPCResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudVPCResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCloudVPCResponseMultiError(errors)
	}

	return nil
}

// UpdateCloudVPCResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateCloudVPCResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateCloudVPCResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudVPCResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudVPCResponseMultiError) AllErrors() []error { return m }

// UpdateCloudVPCResponseValidationError is the validation error returned by
// UpdateCloudVPCResponse.Validate if the designated constraints aren't met.
type UpdateCloudVPCResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudVPCResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudVPCResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudVPCResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudVPCResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudVPCResponseValidationError) ErrorName() string {
	return "UpdateCloudVPCResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudVPCResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudVPCResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudVPCResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudVPCResponseValidationError{}

// Validate checks the field values on DeleteCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudVPCRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudVPCRequestMultiError, or nil if none found.
func (m *DeleteCloudVPCRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudVPCRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 100 {
		err := DeleteCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudVPCRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := DeleteCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVpcID()); l < 2 || l > 100 {
		err := DeleteCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudVPCRequest_VpcID_Pattern.MatchString(m.GetVpcID()) {
		err := DeleteCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteCloudVPCRequestMultiError(errors)
	}

	return nil
}

// DeleteCloudVPCRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCloudVPCRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteCloudVPCRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudVPCRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudVPCRequestMultiError) AllErrors() []error { return m }

// DeleteCloudVPCRequestValidationError is the validation error returned by
// DeleteCloudVPCRequest.Validate if the designated constraints aren't met.
type DeleteCloudVPCRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudVPCRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudVPCRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudVPCRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudVPCRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudVPCRequestValidationError) ErrorName() string {
	return "DeleteCloudVPCRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudVPCRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudVPCRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudVPCRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudVPCRequestValidationError{}

var _DeleteCloudVPCRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _DeleteCloudVPCRequest_VpcID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudVPCResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudVPCResponseMultiError, or nil if none found.
func (m *DeleteCloudVPCResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudVPCResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteCloudVPCResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteCloudVPCResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteCloudVPCResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteCloudVPCResponseMultiError(errors)
	}

	return nil
}

// DeleteCloudVPCResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCloudVPCResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteCloudVPCResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudVPCResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudVPCResponseMultiError) AllErrors() []error { return m }

// DeleteCloudVPCResponseValidationError is the validation error returned by
// DeleteCloudVPCResponse.Validate if the designated constraints aren't met.
type DeleteCloudVPCResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudVPCResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudVPCResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudVPCResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudVPCResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudVPCResponseValidationError) ErrorName() string {
	return "DeleteCloudVPCResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudVPCResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudVPCResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudVPCResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudVPCResponseValidationError{}

// Validate checks the field values on ListCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudVPCRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudVPCRequestMultiError, or nil if none found.
func (m *ListCloudVPCRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudVPCRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 20 {
		err := ListCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for VpcID

	if _, ok := _ListCloudVPCRequest_NetworkType_InLookup[m.GetNetworkType()]; !ok {
		err := ListCloudVPCRequestValidationError{
			field:  "NetworkType",
			reason: "value must be in list [overlay underlay]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCloudVPCRequestMultiError(errors)
	}

	return nil
}

// ListCloudVPCRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudVPCRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudVPCRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudVPCRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudVPCRequestMultiError) AllErrors() []error { return m }

// ListCloudVPCRequestValidationError is the validation error returned by
// ListCloudVPCRequest.Validate if the designated constraints aren't met.
type ListCloudVPCRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudVPCRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudVPCRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudVPCRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudVPCRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudVPCRequestValidationError) ErrorName() string {
	return "ListCloudVPCRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudVPCRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudVPCRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudVPCRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudVPCRequestValidationError{}

var _ListCloudVPCRequest_NetworkType_InLookup = map[string]struct{}{
	"overlay":  {},
	"underlay": {},
}

// Validate checks the field values on ListCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudVPCResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudVPCResponseMultiError, or nil if none found.
func (m *ListCloudVPCResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudVPCResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudVPCResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudVPCResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudVPCResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudVPCResponseMultiError(errors)
	}

	return nil
}

// ListCloudVPCResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudVPCResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudVPCResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudVPCResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudVPCResponseMultiError) AllErrors() []error { return m }

// ListCloudVPCResponseValidationError is the validation error returned by
// ListCloudVPCResponse.Validate if the designated constraints aren't met.
type ListCloudVPCResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudVPCResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudVPCResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudVPCResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudVPCResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudVPCResponseValidationError) ErrorName() string {
	return "ListCloudVPCResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudVPCResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudVPCResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudVPCResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudVPCResponseValidationError{}

// Validate checks the field values on ListCloudRegionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRegionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRegionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudRegionsRequestMultiError, or nil if none found.
func (m *ListCloudRegionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRegionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 20 {
		err := ListCloudRegionsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCloudRegionsRequestMultiError(errors)
	}

	return nil
}

// ListCloudRegionsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudRegionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudRegionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRegionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRegionsRequestMultiError) AllErrors() []error { return m }

// ListCloudRegionsRequestValidationError is the validation error returned by
// ListCloudRegionsRequest.Validate if the designated constraints aren't met.
type ListCloudRegionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRegionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRegionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRegionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRegionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRegionsRequestValidationError) ErrorName() string {
	return "ListCloudRegionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRegionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRegionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRegionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRegionsRequestValidationError{}

// Validate checks the field values on ListCloudRegionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRegionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRegionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudRegionsResponseMultiError, or nil if none found.
func (m *ListCloudRegionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRegionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudRegionsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudRegionsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudRegionsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudRegionsResponseMultiError(errors)
	}

	return nil
}

// ListCloudRegionsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudRegionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudRegionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRegionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRegionsResponseMultiError) AllErrors() []error { return m }

// ListCloudRegionsResponseValidationError is the validation error returned by
// ListCloudRegionsResponse.Validate if the designated constraints aren't met.
type ListCloudRegionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRegionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRegionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRegionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRegionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRegionsResponseValidationError) ErrorName() string {
	return "ListCloudRegionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRegionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRegionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRegionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRegionsResponseValidationError{}

// Validate checks the field values on CloudRegion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudRegion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudRegion with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudRegionMultiError, or
// nil if none found.
func (m *CloudRegion) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudRegion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for RegionName

	// no validation rules for Region

	if len(errors) > 0 {
		return CloudRegionMultiError(errors)
	}

	return nil
}

// CloudRegionMultiError is an error wrapping multiple validation errors
// returned by CloudRegion.ValidateAll() if the designated constraints aren't met.
type CloudRegionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudRegionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudRegionMultiError) AllErrors() []error { return m }

// CloudRegionValidationError is the validation error returned by
// CloudRegion.Validate if the designated constraints aren't met.
type CloudRegionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudRegionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudRegionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudRegionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudRegionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudRegionValidationError) ErrorName() string { return "CloudRegionValidationError" }

// Error satisfies the builtin error interface
func (e CloudRegionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudRegion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudRegionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudRegionValidationError{}

// Validate checks the field values on GetVPCCidrRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetVPCCidrRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVPCCidrRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVPCCidrRequestMultiError, or nil if none found.
func (m *GetVPCCidrRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVPCCidrRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VpcID

	if len(errors) > 0 {
		return GetVPCCidrRequestMultiError(errors)
	}

	return nil
}

// GetVPCCidrRequestMultiError is an error wrapping multiple validation errors
// returned by GetVPCCidrRequest.ValidateAll() if the designated constraints
// aren't met.
type GetVPCCidrRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVPCCidrRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVPCCidrRequestMultiError) AllErrors() []error { return m }

// GetVPCCidrRequestValidationError is the validation error returned by
// GetVPCCidrRequest.Validate if the designated constraints aren't met.
type GetVPCCidrRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVPCCidrRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVPCCidrRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVPCCidrRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVPCCidrRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVPCCidrRequestValidationError) ErrorName() string {
	return "GetVPCCidrRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetVPCCidrRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVPCCidrRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVPCCidrRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVPCCidrRequestValidationError{}

// Validate checks the field values on GetVPCCidrResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVPCCidrResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVPCCidrResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVPCCidrResponseMultiError, or nil if none found.
func (m *GetVPCCidrResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVPCCidrResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetVPCCidrResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetVPCCidrResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetVPCCidrResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetVPCCidrResponseMultiError(errors)
	}

	return nil
}

// GetVPCCidrResponseMultiError is an error wrapping multiple validation errors
// returned by GetVPCCidrResponse.ValidateAll() if the designated constraints
// aren't met.
type GetVPCCidrResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVPCCidrResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVPCCidrResponseMultiError) AllErrors() []error { return m }

// GetVPCCidrResponseValidationError is the validation error returned by
// GetVPCCidrResponse.Validate if the designated constraints aren't met.
type GetVPCCidrResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVPCCidrResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVPCCidrResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVPCCidrResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVPCCidrResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVPCCidrResponseValidationError) ErrorName() string {
	return "GetVPCCidrResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetVPCCidrResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVPCCidrResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVPCCidrResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVPCCidrResponseValidationError{}

// Validate checks the field values on VPCCidr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VPCCidr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VPCCidr with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VPCCidrMultiError, or nil if none found.
func (m *VPCCidr) ValidateAll() error {
	return m.validate(true)
}

func (m *VPCCidr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Vpc

	// no validation rules for Cidr

	// no validation rules for IPNumber

	// no validation rules for Status

	if len(errors) > 0 {
		return VPCCidrMultiError(errors)
	}

	return nil
}

// VPCCidrMultiError is an error wrapping multiple validation errors returned
// by VPCCidr.ValidateAll() if the designated constraints aren't met.
type VPCCidrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VPCCidrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VPCCidrMultiError) AllErrors() []error { return m }

// VPCCidrValidationError is the validation error returned by VPCCidr.Validate
// if the designated constraints aren't met.
type VPCCidrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VPCCidrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VPCCidrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VPCCidrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VPCCidrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VPCCidrValidationError) ErrorName() string { return "VPCCidrValidationError" }

// Error satisfies the builtin error interface
func (e VPCCidrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVPCCidr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VPCCidrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VPCCidrValidationError{}

// Validate checks the field values on Cloud with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cloud) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cloud with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CloudMultiError, or nil if none found.
func (m *Cloud) ValidateAll() error {
	return m.validate(true)
}

func (m *Cloud) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Name

	// no validation rules for Editable

	{
		sorted_keys := make([]string, len(m.GetOpsPlugins()))
		i := 0
		for key := range m.GetOpsPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOpsPlugins()[key]
			_ = val

			// no validation rules for OpsPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CloudValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CloudValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CloudValidationError{
						field:  fmt.Sprintf("OpsPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraPlugins()))
		i := 0
		for key := range m.GetExtraPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraPlugins()[key]
			_ = val

			// no validation rules for ExtraPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CloudValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CloudValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CloudValidationError{
						field:  fmt.Sprintf("ExtraPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetCloudCredential()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudCredential()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "CloudCredential",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOsManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOsManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "OsManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "ClusterManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeGroupManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroupManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "NodeGroupManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	// no validation rules for CloudProvider

	// no validation rules for Config

	// no validation rules for Description

	// no validation rules for EngineType

	// no validation rules for Enable

	if all {
		switch v := interface{}(m.GetNetworkInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "NetworkInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "ConfInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlatformInfo

	if len(errors) > 0 {
		return CloudMultiError(errors)
	}

	return nil
}

// CloudMultiError is an error wrapping multiple validation errors returned by
// Cloud.ValidateAll() if the designated constraints aren't met.
type CloudMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudMultiError) AllErrors() []error { return m }

// CloudValidationError is the validation error returned by Cloud.Validate if
// the designated constraints aren't met.
type CloudValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudValidationError) ErrorName() string { return "CloudValidationError" }

// Error satisfies the builtin error interface
func (e CloudValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloud.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudValidationError{}

// Validate checks the field values on CloudConfigInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudConfigInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudConfigInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudConfigInfoMultiError, or nil if none found.
func (m *CloudConfigInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudConfigInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudInternalEnable

	// no validation rules for CloudDomain

	// no validation rules for MachineDomain

	// no validation rules for DisableCreateCluster

	// no validation rules for DisableImportCluster

	// no validation rules for DisableNodeGroup

	if len(errors) > 0 {
		return CloudConfigInfoMultiError(errors)
	}

	return nil
}

// CloudConfigInfoMultiError is an error wrapping multiple validation errors
// returned by CloudConfigInfo.ValidateAll() if the designated constraints
// aren't met.
type CloudConfigInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudConfigInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudConfigInfoMultiError) AllErrors() []error { return m }

// CloudConfigInfoValidationError is the validation error returned by
// CloudConfigInfo.Validate if the designated constraints aren't met.
type CloudConfigInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudConfigInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudConfigInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudConfigInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudConfigInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudConfigInfoValidationError) ErrorName() string { return "CloudConfigInfoValidationError" }

// Error satisfies the builtin error interface
func (e CloudConfigInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudConfigInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudConfigInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudConfigInfoValidationError{}

// Validate checks the field values on CloudNetworkInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudNetworkInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudNetworkInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudNetworkInfoMultiError, or nil if none found.
func (m *CloudNetworkInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudNetworkInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CloudNetworkInfoMultiError(errors)
	}

	return nil
}

// CloudNetworkInfoMultiError is an error wrapping multiple validation errors
// returned by CloudNetworkInfo.ValidateAll() if the designated constraints
// aren't met.
type CloudNetworkInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudNetworkInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudNetworkInfoMultiError) AllErrors() []error { return m }

// CloudNetworkInfoValidationError is the validation error returned by
// CloudNetworkInfo.Validate if the designated constraints aren't met.
type CloudNetworkInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudNetworkInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudNetworkInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudNetworkInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudNetworkInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudNetworkInfoValidationError) ErrorName() string { return "CloudNetworkInfoValidationError" }

// Error satisfies the builtin error interface
func (e CloudNetworkInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudNetworkInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudNetworkInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudNetworkInfoValidationError{}

// Validate checks the field values on NodeGroup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupMultiError, or nil
// if none found.
func (m *NodeGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeGroupID

	// no validation rules for Name

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := NodeGroupValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := NodeGroupValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_NodeGroup_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := NodeGroupValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for EnableAutoscale

	if all {
		switch v := interface{}(m.GetAutoScaling()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutoScaling()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "AutoScaling",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLaunchTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLaunchTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "LaunchTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	// no validation rules for Taints

	// no validation rules for NodeOS

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for ProjectID

	// no validation rules for Provider

	if _, ok := _NodeGroup_Status_InLookup[m.GetStatus()]; !ok {
		err := NodeGroupValidationError{
			field:  "Status",
			reason: "value must be in list [CREATING RUNNING DELETING UPDATING DELETED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ConsumerID

	if m.GetNodeTemplate() == nil {
		err := NodeGroupValidationError{
			field:  "NodeTemplate",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNodeTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "NodeTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CloudNodeGroupID

	// no validation rules for Tags

	// no validation rules for NodeGroupType

	if all {
		switch v := interface{}(m.GetArea()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "Area",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "Area",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArea()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "Area",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NodeRole

	if len(errors) > 0 {
		return NodeGroupMultiError(errors)
	}

	return nil
}

// NodeGroupMultiError is an error wrapping multiple validation errors returned
// by NodeGroup.ValidateAll() if the designated constraints aren't met.
type NodeGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupMultiError) AllErrors() []error { return m }

// NodeGroupValidationError is the validation error returned by
// NodeGroup.Validate if the designated constraints aren't met.
type NodeGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupValidationError) ErrorName() string { return "NodeGroupValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupValidationError{}

var _NodeGroup_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _NodeGroup_Status_InLookup = map[string]struct{}{
	"CREATING": {},
	"RUNNING":  {},
	"DELETING": {},
	"UPDATING": {},
	"DELETED":  {},
}

// Validate checks the field values on CloudArea with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudArea) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudArea with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudAreaMultiError, or nil
// if none found.
func (m *CloudArea) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudArea) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BkCloudID

	// no validation rules for BkCloudName

	if len(errors) > 0 {
		return CloudAreaMultiError(errors)
	}

	return nil
}

// CloudAreaMultiError is an error wrapping multiple validation errors returned
// by CloudArea.ValidateAll() if the designated constraints aren't met.
type CloudAreaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAreaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAreaMultiError) AllErrors() []error { return m }

// CloudAreaValidationError is the validation error returned by
// CloudArea.Validate if the designated constraints aren't met.
type CloudAreaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAreaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAreaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAreaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAreaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAreaValidationError) ErrorName() string { return "CloudAreaValidationError" }

// Error satisfies the builtin error interface
func (e CloudAreaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudArea.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAreaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAreaValidationError{}

// Validate checks the field values on AutoScalingGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AutoScalingGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoScalingGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutoScalingGroupMultiError, or nil if none found.
func (m *AutoScalingGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoScalingGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AutoScalingID

	// no validation rules for AutoScalingName

	if val := m.GetMinSize(); val < 0 || val >= 320000 {
		err := AutoScalingGroupValidationError{
			field:  "MinSize",
			reason: "value must be inside range [0, 320000)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxSize(); val < 0 || val >= 320000 {
		err := AutoScalingGroupValidationError{
			field:  "MaxSize",
			reason: "value must be inside range [0, 320000)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DesiredSize

	// no validation rules for VpcID

	// no validation rules for DefaultCooldown

	// no validation rules for RetryPolicy

	// no validation rules for MultiZoneSubnetPolicy

	// no validation rules for ReplaceUnhealthy

	// no validation rules for ScalingMode

	for idx, item := range m.GetTimeRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoScalingGroupValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoScalingGroupValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoScalingGroupValidationError{
					field:  fmt.Sprintf("TimeRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AutoUpgrade

	if len(errors) > 0 {
		return AutoScalingGroupMultiError(errors)
	}

	return nil
}

// AutoScalingGroupMultiError is an error wrapping multiple validation errors
// returned by AutoScalingGroup.ValidateAll() if the designated constraints
// aren't met.
type AutoScalingGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoScalingGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoScalingGroupMultiError) AllErrors() []error { return m }

// AutoScalingGroupValidationError is the validation error returned by
// AutoScalingGroup.Validate if the designated constraints aren't met.
type AutoScalingGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoScalingGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoScalingGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoScalingGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoScalingGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoScalingGroupValidationError) ErrorName() string { return "AutoScalingGroupValidationError" }

// Error satisfies the builtin error interface
func (e AutoScalingGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoScalingGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoScalingGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoScalingGroupValidationError{}

// Validate checks the field values on TimeRange with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeRange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeRangeMultiError, or nil
// if none found.
func (m *TimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 1024 {
		err := TimeRangeValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSchedule()); l < 2 || l > 1024 {
		err := TimeRangeValidationError{
			field:  "Schedule",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Zone

	// no validation rules for DesiredNum

	if len(errors) > 0 {
		return TimeRangeMultiError(errors)
	}

	return nil
}

// TimeRangeMultiError is an error wrapping multiple validation errors returned
// by TimeRange.ValidateAll() if the designated constraints aren't met.
type TimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeRangeMultiError) AllErrors() []error { return m }

// TimeRangeValidationError is the validation error returned by
// TimeRange.Validate if the designated constraints aren't met.
type TimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeRangeValidationError) ErrorName() string { return "TimeRangeValidationError" }

// Error satisfies the builtin error interface
func (e TimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeRangeValidationError{}

// Validate checks the field values on DataDisk with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataDisk) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataDisk with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataDiskMultiError, or nil
// if none found.
func (m *DataDisk) ValidateAll() error {
	return m.validate(true)
}

func (m *DataDisk) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DiskType

	// no validation rules for DiskSize

	// no validation rules for FileSystem

	// no validation rules for AutoFormatAndMount

	// no validation rules for MountTarget

	if len(errors) > 0 {
		return DataDiskMultiError(errors)
	}

	return nil
}

// DataDiskMultiError is an error wrapping multiple validation errors returned
// by DataDisk.ValidateAll() if the designated constraints aren't met.
type DataDiskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataDiskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataDiskMultiError) AllErrors() []error { return m }

// DataDiskValidationError is the validation error returned by
// DataDisk.Validate if the designated constraints aren't met.
type DataDiskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataDiskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataDiskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataDiskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataDiskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataDiskValidationError) ErrorName() string { return "DataDiskValidationError" }

// Error satisfies the builtin error interface
func (e DataDiskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataDisk.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataDiskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataDiskValidationError{}

// Validate checks the field values on InternetAccessible with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InternetAccessible) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InternetAccessible with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InternetAccessibleMultiError, or nil if none found.
func (m *InternetAccessible) ValidateAll() error {
	return m.validate(true)
}

func (m *InternetAccessible) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InternetChargeType

	// no validation rules for InternetMaxBandwidth

	// no validation rules for PublicIPAssigned

	if len(errors) > 0 {
		return InternetAccessibleMultiError(errors)
	}

	return nil
}

// InternetAccessibleMultiError is an error wrapping multiple validation errors
// returned by InternetAccessible.ValidateAll() if the designated constraints
// aren't met.
type InternetAccessibleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InternetAccessibleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InternetAccessibleMultiError) AllErrors() []error { return m }

// InternetAccessibleValidationError is the validation error returned by
// InternetAccessible.Validate if the designated constraints aren't met.
type InternetAccessibleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InternetAccessibleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InternetAccessibleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InternetAccessibleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InternetAccessibleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InternetAccessibleValidationError) ErrorName() string {
	return "InternetAccessibleValidationError"
}

// Error satisfies the builtin error interface
func (e InternetAccessibleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInternetAccessible.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InternetAccessibleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InternetAccessibleValidationError{}

// Validate checks the field values on InstanceTemplateConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceTemplateConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceTemplateConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceTemplateConfigMultiError, or nil if none found.
func (m *InstanceTemplateConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceTemplateConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for Zone

	// no validation rules for VpcID

	// no validation rules for SubnetID

	// no validation rules for ApplyNum

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for InstanceType

	if _, ok := _InstanceTemplateConfig_InstanceChargeType_InLookup[m.GetInstanceChargeType()]; !ok {
		err := InstanceTemplateConfigValidationError{
			field:  "InstanceChargeType",
			reason: "value must be in list [PREPAID POSTPAID_BY_HOUR SPOTPAID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSystemDisk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSystemDisk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTemplateConfigValidationError{
				field:  "SystemDisk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTemplateConfigValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTemplateConfigValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTemplateConfigValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetImageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "ImageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "ImageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTemplateConfigValidationError{
				field:  "ImageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InitLoginPassword

	// no validation rules for IsSecurityService

	// no validation rules for IsMonitorService

	if len(errors) > 0 {
		return InstanceTemplateConfigMultiError(errors)
	}

	return nil
}

// InstanceTemplateConfigMultiError is an error wrapping multiple validation
// errors returned by InstanceTemplateConfig.ValidateAll() if the designated
// constraints aren't met.
type InstanceTemplateConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTemplateConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTemplateConfigMultiError) AllErrors() []error { return m }

// InstanceTemplateConfigValidationError is the validation error returned by
// InstanceTemplateConfig.Validate if the designated constraints aren't met.
type InstanceTemplateConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTemplateConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTemplateConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTemplateConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTemplateConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTemplateConfigValidationError) ErrorName() string {
	return "InstanceTemplateConfigValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceTemplateConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceTemplateConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTemplateConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTemplateConfigValidationError{}

var _InstanceTemplateConfig_InstanceChargeType_InLookup = map[string]struct{}{
	"PREPAID":          {},
	"POSTPAID_BY_HOUR": {},
	"SPOTPAID":         {},
}

// Validate checks the field values on LaunchConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LaunchConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LaunchConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LaunchConfigurationMultiError, or nil if none found.
func (m *LaunchConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *LaunchConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LaunchConfigurationID

	// no validation rules for LaunchConfigureName

	// no validation rules for ProjectID

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for InstanceType

	// no validation rules for InstanceChargeType

	if all {
		switch v := interface{}(m.GetSystemDisk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSystemDisk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LaunchConfigurationValidationError{
				field:  "SystemDisk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LaunchConfigurationValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LaunchConfigurationValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LaunchConfigurationValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetInternetAccess()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "InternetAccess",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "InternetAccess",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInternetAccess()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LaunchConfigurationValidationError{
				field:  "InternetAccess",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InitLoginPassword

	if all {
		switch v := interface{}(m.GetImageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "ImageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "ImageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LaunchConfigurationValidationError{
				field:  "ImageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsSecurityService

	// no validation rules for IsMonitorService

	// no validation rules for UserData

	// no validation rules for SshKey

	if len(errors) > 0 {
		return LaunchConfigurationMultiError(errors)
	}

	return nil
}

// LaunchConfigurationMultiError is an error wrapping multiple validation
// errors returned by LaunchConfiguration.ValidateAll() if the designated
// constraints aren't met.
type LaunchConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LaunchConfigurationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LaunchConfigurationMultiError) AllErrors() []error { return m }

// LaunchConfigurationValidationError is the validation error returned by
// LaunchConfiguration.Validate if the designated constraints aren't met.
type LaunchConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LaunchConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LaunchConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LaunchConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LaunchConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LaunchConfigurationValidationError) ErrorName() string {
	return "LaunchConfigurationValidationError"
}

// Error satisfies the builtin error interface
func (e LaunchConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLaunchConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LaunchConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LaunchConfigurationValidationError{}

// Validate checks the field values on ImageInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImageInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImageInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImageInfoMultiError, or nil
// if none found.
func (m *ImageInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ImageInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ImageID

	// no validation rules for ImageName

	if len(errors) > 0 {
		return ImageInfoMultiError(errors)
	}

	return nil
}

// ImageInfoMultiError is an error wrapping multiple validation errors returned
// by ImageInfo.ValidateAll() if the designated constraints aren't met.
type ImageInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImageInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImageInfoMultiError) AllErrors() []error { return m }

// ImageInfoValidationError is the validation error returned by
// ImageInfo.Validate if the designated constraints aren't met.
type ImageInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImageInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImageInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImageInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImageInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImageInfoValidationError) ErrorName() string { return "ImageInfoValidationError" }

// Error satisfies the builtin error interface
func (e ImageInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImageInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImageInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImageInfoValidationError{}

// Validate checks the field values on ClusterAutoScalingOption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAutoScalingOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAutoScalingOption with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterAutoScalingOptionMultiError, or nil if none found.
func (m *ClusterAutoScalingOption) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAutoScalingOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsScaleDownEnable

	// no validation rules for Expander

	// no validation rules for MaxEmptyBulkDelete

	// no validation rules for ScaleDownDelay

	// no validation rules for ScaleDownUnneededTime

	// no validation rules for ScaleDownUtilizationThreahold

	// no validation rules for SkipNodesWithLocalStorage

	// no validation rules for SkipNodesWithSystemPods

	// no validation rules for IgnoreDaemonSetsUtilization

	// no validation rules for OkTotalUnreadyCount

	// no validation rules for MaxTotalUnreadyPercentage

	// no validation rules for ScaleDownUnreadyTime

	// no validation rules for UnregisteredNodeRemovalTime

	// no validation rules for ProjectID

	// no validation rules for ClusterID

	// no validation rules for Creator

	// no validation rules for CreateTime

	// no validation rules for Updater

	// no validation rules for UpdateTime

	// no validation rules for Provider

	// no validation rules for EnableAutoscale

	// no validation rules for BufferResourceRatio

	// no validation rules for MaxGracefulTerminationSec

	// no validation rules for ScanInterval

	// no validation rules for MaxNodeProvisionTime

	// no validation rules for ScaleUpFromZero

	// no validation rules for ScaleDownDelayAfterAdd

	// no validation rules for ScaleDownDelayAfterDelete

	// no validation rules for ScaleDownDelayAfterFailure

	// no validation rules for ScaleDownGpuUtilizationThreshold

	// no validation rules for Status

	// no validation rules for ErrorMessage

	if len(errors) > 0 {
		return ClusterAutoScalingOptionMultiError(errors)
	}

	return nil
}

// ClusterAutoScalingOptionMultiError is an error wrapping multiple validation
// errors returned by ClusterAutoScalingOption.ValidateAll() if the designated
// constraints aren't met.
type ClusterAutoScalingOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAutoScalingOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAutoScalingOptionMultiError) AllErrors() []error { return m }

// ClusterAutoScalingOptionValidationError is the validation error returned by
// ClusterAutoScalingOption.Validate if the designated constraints aren't met.
type ClusterAutoScalingOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAutoScalingOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAutoScalingOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAutoScalingOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAutoScalingOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAutoScalingOptionValidationError) ErrorName() string {
	return "ClusterAutoScalingOptionValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAutoScalingOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAutoScalingOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAutoScalingOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAutoScalingOptionValidationError{}

// Validate checks the field values on Taint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Taint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Taint with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaintMultiError, or nil if none found.
func (m *Taint) ValidateAll() error {
	return m.validate(true)
}

func (m *Taint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	// no validation rules for Effect

	if len(errors) > 0 {
		return TaintMultiError(errors)
	}

	return nil
}

// TaintMultiError is an error wrapping multiple validation errors returned by
// Taint.ValidateAll() if the designated constraints aren't met.
type TaintMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaintMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaintMultiError) AllErrors() []error { return m }

// TaintValidationError is the validation error returned by Taint.Validate if
// the designated constraints aren't met.
type TaintValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaintValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaintValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaintValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaintValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaintValidationError) ErrorName() string { return "TaintValidationError" }

// Error satisfies the builtin error interface
func (e TaintValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaintValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaintValidationError{}

// Validate checks the field values on NodeTemplate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeTemplateMultiError, or
// nil if none found.
func (m *NodeTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeTemplateID

	// no validation rules for Name

	// no validation rules for ProjectID

	// no validation rules for Labels

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeTemplateValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DockerGraphPath

	// no validation rules for MountTarget

	// no validation rules for UserScript

	// no validation rules for UnSchedulable

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeTemplateValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtraArgs

	// no validation rules for PreStartUserScript

	if all {
		switch v := interface{}(m.GetBcsScaleOutAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "BcsScaleOutAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "BcsScaleOutAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBcsScaleOutAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "BcsScaleOutAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBcsScaleInAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "BcsScaleInAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "BcsScaleInAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBcsScaleInAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "BcsScaleInAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleOutExtraAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "ScaleOutExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "ScaleOutExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleOutExtraAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "ScaleOutExtraAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleInExtraAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "ScaleInExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "ScaleInExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleInExtraAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "ScaleInExtraAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NodeOS

	// no validation rules for ModuleID

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "Runtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "Module",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxPodsPerNode

	if len(errors) > 0 {
		return NodeTemplateMultiError(errors)
	}

	return nil
}

// NodeTemplateMultiError is an error wrapping multiple validation errors
// returned by NodeTemplate.ValidateAll() if the designated constraints aren't met.
type NodeTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeTemplateMultiError) AllErrors() []error { return m }

// NodeTemplateValidationError is the validation error returned by
// NodeTemplate.Validate if the designated constraints aren't met.
type NodeTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeTemplateValidationError) ErrorName() string { return "NodeTemplateValidationError" }

// Error satisfies the builtin error interface
func (e NodeTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeTemplateValidationError{}

// Validate checks the field values on ModuleInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModuleInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModuleInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModuleInfoMultiError, or
// nil if none found.
func (m *ModuleInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ModuleInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScaleOutModuleID

	// no validation rules for ScaleInModuleID

	// no validation rules for ScaleOutBizID

	// no validation rules for ScaleInBizID

	// no validation rules for ScaleOutModuleName

	// no validation rules for ScaleInModuleName

	if len(errors) > 0 {
		return ModuleInfoMultiError(errors)
	}

	return nil
}

// ModuleInfoMultiError is an error wrapping multiple validation errors
// returned by ModuleInfo.ValidateAll() if the designated constraints aren't met.
type ModuleInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModuleInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModuleInfoMultiError) AllErrors() []error { return m }

// ModuleInfoValidationError is the validation error returned by
// ModuleInfo.Validate if the designated constraints aren't met.
type ModuleInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModuleInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModuleInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModuleInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModuleInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModuleInfoValidationError) ErrorName() string { return "ModuleInfoValidationError" }

// Error satisfies the builtin error interface
func (e ModuleInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModuleInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModuleInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModuleInfoValidationError{}

// Validate checks the field values on RunTimeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunTimeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunTimeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunTimeInfoMultiError, or
// nil if none found.
func (m *RunTimeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RunTimeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContainerRuntime

	// no validation rules for RuntimeVersion

	if len(errors) > 0 {
		return RunTimeInfoMultiError(errors)
	}

	return nil
}

// RunTimeInfoMultiError is an error wrapping multiple validation errors
// returned by RunTimeInfo.ValidateAll() if the designated constraints aren't met.
type RunTimeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunTimeInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunTimeInfoMultiError) AllErrors() []error { return m }

// RunTimeInfoValidationError is the validation error returned by
// RunTimeInfo.Validate if the designated constraints aren't met.
type RunTimeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunTimeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunTimeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunTimeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunTimeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunTimeInfoValidationError) ErrorName() string { return "RunTimeInfoValidationError" }

// Error satisfies the builtin error interface
func (e RunTimeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunTimeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunTimeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunTimeInfoValidationError{}

// Validate checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Project) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProjectMultiError, or nil if none found.
func (m *Project) ValidateAll() error {
	return m.validate(true)
}

func (m *Project) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for Name

	// no validation rules for EnglishName

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for ProjectType

	// no validation rules for UseBKRes

	// no validation rules for Description

	// no validation rules for IsOffline

	// no validation rules for Kind

	// no validation rules for BusinessID

	// no validation rules for DeployType

	// no validation rules for BgID

	// no validation rules for BgName

	// no validation rules for DeptID

	// no validation rules for DeptName

	// no validation rules for CenterID

	// no validation rules for CenterName

	// no validation rules for IsSecret

	{
		sorted_keys := make([]string, len(m.GetCredentials()))
		i := 0
		for key := range m.GetCredentials() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCredentials()[key]
			_ = val

			// no validation rules for Credentials[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ProjectValidationError{
							field:  fmt.Sprintf("Credentials[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ProjectValidationError{
							field:  fmt.Sprintf("Credentials[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ProjectValidationError{
						field:  fmt.Sprintf("Credentials[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return ProjectMultiError(errors)
	}

	return nil
}

// ProjectMultiError is an error wrapping multiple validation errors returned
// by Project.ValidateAll() if the designated constraints aren't met.
type ProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectMultiError) AllErrors() []error { return m }

// ProjectValidationError is the validation error returned by Project.Validate
// if the designated constraints aren't met.
type ProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectValidationError) ErrorName() string { return "ProjectValidationError" }

// Error satisfies the builtin error interface
func (e ProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectValidationError{}

// Validate checks the field values on Task with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Task) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaskMultiError, or nil if none found.
func (m *Task) ValidateAll() error {
	return m.validate(true)
}

func (m *Task) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskID

	// no validation rules for TaskType

	if _, ok := _Task_Status_InLookup[m.GetStatus()]; !ok {
		err := TaskValidationError{
			field:  "Status",
			reason: "value must be in list [INITIALIZING RUNNING SUCCESS FAILURE TIMEOUT FORCETERMINATE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ExecutionTime

	// no validation rules for CurrentStep

	{
		sorted_keys := make([]string, len(m.GetSteps()))
		i := 0
		for key := range m.GetSteps() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSteps()[key]
			_ = val

			// no validation rules for Steps[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TaskValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TaskValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TaskValidationError{
						field:  fmt.Sprintf("Steps[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for ClusterID

	// no validation rules for ProjectID

	// no validation rules for Creator

	// no validation rules for LastUpdate

	// no validation rules for Updater

	// no validation rules for ForceTerminate

	// no validation rules for CommonParams

	// no validation rules for TaskName

	// no validation rules for NodeGroupID

	if len(errors) > 0 {
		return TaskMultiError(errors)
	}

	return nil
}

// TaskMultiError is an error wrapping multiple validation errors returned by
// Task.ValidateAll() if the designated constraints aren't met.
type TaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskMultiError) AllErrors() []error { return m }

// TaskValidationError is the validation error returned by Task.Validate if the
// designated constraints aren't met.
type TaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskValidationError) ErrorName() string { return "TaskValidationError" }

// Error satisfies the builtin error interface
func (e TaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskValidationError{}

var _Task_Status_InLookup = map[string]struct{}{
	"INITIALIZING":   {},
	"RUNNING":        {},
	"SUCCESS":        {},
	"FAILURE":        {},
	"TIMEOUT":        {},
	"FORCETERMINATE": {},
}

// Validate checks the field values on Step with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Step with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StepMultiError, or nil if none found.
func (m *Step) ValidateAll() error {
	return m.validate(true)
}

func (m *Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for System

	// no validation rules for Link

	// no validation rules for Params

	// no validation rules for Retry

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ExecutionTime

	if _, ok := _Step_Status_InLookup[m.GetStatus()]; !ok {
		err := StepValidationError{
			field:  "Status",
			reason: "value must be in list [NOTSTARTED RUNNING SUCCESS FAILURE TIMEOUT FORCETERMINATE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for LastUpdate

	// no validation rules for TaskMethod

	// no validation rules for TaskName

	// no validation rules for SkipOnFailed

	if len(errors) > 0 {
		return StepMultiError(errors)
	}

	return nil
}

// StepMultiError is an error wrapping multiple validation errors returned by
// Step.ValidateAll() if the designated constraints aren't met.
type StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StepMultiError) AllErrors() []error { return m }

// StepValidationError is the validation error returned by Step.Validate if the
// designated constraints aren't met.
type StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StepValidationError) ErrorName() string { return "StepValidationError" }

// Error satisfies the builtin error interface
func (e StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StepValidationError{}

var _Step_Status_InLookup = map[string]struct{}{
	"NOTSTARTED":     {},
	"RUNNING":        {},
	"SUCCESS":        {},
	"FAILURE":        {},
	"TIMEOUT":        {},
	"FORCETERMINATE": {},
}

// Validate checks the field values on TkeCidr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TkeCidr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TkeCidr with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TkeCidrMultiError, or nil if none found.
func (m *TkeCidr) ValidateAll() error {
	return m.validate(true)
}

func (m *TkeCidr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VPC

	// no validation rules for CIDR

	// no validation rules for IPNumber

	// no validation rules for Status

	// no validation rules for Cluster

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return TkeCidrMultiError(errors)
	}

	return nil
}

// TkeCidrMultiError is an error wrapping multiple validation errors returned
// by TkeCidr.ValidateAll() if the designated constraints aren't met.
type TkeCidrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TkeCidrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TkeCidrMultiError) AllErrors() []error { return m }

// TkeCidrValidationError is the validation error returned by TkeCidr.Validate
// if the designated constraints aren't met.
type TkeCidrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TkeCidrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TkeCidrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TkeCidrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TkeCidrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TkeCidrValidationError) ErrorName() string { return "TkeCidrValidationError" }

// Error satisfies the builtin error interface
func (e TkeCidrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTkeCidr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TkeCidrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TkeCidrValidationError{}

// Validate checks the field values on TkeCidrCount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TkeCidrCount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TkeCidrCount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TkeCidrCountMultiError, or
// nil if none found.
func (m *TkeCidrCount) ValidateAll() error {
	return m.validate(true)
}

func (m *TkeCidrCount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	// no validation rules for VPC

	// no validation rules for IPNumber

	// no validation rules for Status

	if len(errors) > 0 {
		return TkeCidrCountMultiError(errors)
	}

	return nil
}

// TkeCidrCountMultiError is an error wrapping multiple validation errors
// returned by TkeCidrCount.ValidateAll() if the designated constraints aren't met.
type TkeCidrCountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TkeCidrCountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TkeCidrCountMultiError) AllErrors() []error { return m }

// TkeCidrCountValidationError is the validation error returned by
// TkeCidrCount.Validate if the designated constraints aren't met.
type TkeCidrCountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TkeCidrCountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TkeCidrCountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TkeCidrCountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TkeCidrCountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TkeCidrCountValidationError) ErrorName() string { return "TkeCidrCountValidationError" }

// Error satisfies the builtin error interface
func (e TkeCidrCountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTkeCidrCount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TkeCidrCountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TkeCidrCountValidationError{}

// Validate checks the field values on CreateClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterReqMultiError, or nil if none found.
func (m *CreateClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if l := utf8.RuneCountInString(m.GetClusterName()); l < 1 || l > 1024 {
		err := CreateClusterReqValidationError{
			field:  "ClusterName",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProvider()) > 32 {
		err := CreateClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 1 || l > 100 {
		err := CreateClusterReqValidationError{
			field:  "Region",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateClusterReq_Region_Pattern.MatchString(m.GetRegion()) {
		err := CreateClusterReqValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVpcID()) > 32 {
		err := CreateClusterReqValidationError{
			field:  "VpcID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := CreateClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateClusterReq_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := CreateClusterReqValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 100 {
		err := CreateClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateClusterReq_BusinessID_Pattern.MatchString(m.GetBusinessID()) {
		err := CreateClusterReqValidationError{
			field:  "BusinessID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateClusterReq_Environment_InLookup[m.GetEnvironment()]; !ok {
		err := CreateClusterReqValidationError{
			field:  "Environment",
			reason: "value must be in list [stag debug prod]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateClusterReq_EngineType_InLookup[m.GetEngineType()]; !ok {
		err := CreateClusterReqValidationError{
			field:  "EngineType",
			reason: "value must be in list [k8s mesos]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsExclusive

	if _, ok := _CreateClusterReq_ClusterType_InLookup[m.GetClusterType()]; !ok {
		err := CreateClusterReqValidationError{
			field:  "ClusterType",
			reason: "value must be in list [federation single]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FederationClusterID

	if len(m.GetLabels()) > 20 {
		err := CreateClusterReqValidationError{
			field:  "Labels",
			reason: "value must contain no more than 20 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateClusterReqValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OnlyCreateInfo

	{
		sorted_keys := make([]string, len(m.GetBcsAddons()))
		i := 0
		for key := range m.GetBcsAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetBcsAddons()[key]
			_ = val

			// no validation rules for BcsAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateClusterReqValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateClusterReqValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateClusterReqValidationError{
						field:  fmt.Sprintf("BcsAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraAddons()))
		i := 0
		for key := range m.GetExtraAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraAddons()[key]
			_ = val

			// no validation rules for ExtraAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateClusterReqValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateClusterReqValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateClusterReqValidationError{
						field:  fmt.Sprintf("ExtraAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for CloudID

	// no validation rules for ManageType

	if m.GetNetworkSettings() == nil {
		err := CreateClusterReqValidationError{
			field:  "NetworkSettings",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetNetworkSettings(); a != nil {

	}

	if m.GetClusterBasicSettings() == nil {
		err := CreateClusterReqValidationError{
			field:  "ClusterBasicSettings",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetClusterBasicSettings(); a != nil {

	}

	if all {
		switch v := interface{}(m.GetClusterAdvanceSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAdvanceSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterReqValidationError{
				field:  "ClusterAdvanceSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterReqValidationError{
				field:  "NodeSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SystemReinstall

	// no validation rules for InitLoginPassword

	// no validation rules for NetworkType

	// no validation rules for AutoGenerateMasterNodes

	for idx, item := range m.GetInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateClusterReqValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateClusterReqValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateClusterReqValidationError{
					field:  fmt.Sprintf("Instances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtraInfo

	// no validation rules for ModuleID

	// no validation rules for ExtraClusterID

	// no validation rules for IsCommonCluster

	// no validation rules for Description

	// no validation rules for ClusterCategory

	// no validation rules for IsShared

	// no validation rules for CloudAccountID

	if len(errors) > 0 {
		return CreateClusterReqMultiError(errors)
	}

	return nil
}

// CreateClusterReqMultiError is an error wrapping multiple validation errors
// returned by CreateClusterReq.ValidateAll() if the designated constraints
// aren't met.
type CreateClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterReqMultiError) AllErrors() []error { return m }

// CreateClusterReqValidationError is the validation error returned by
// CreateClusterReq.Validate if the designated constraints aren't met.
type CreateClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterReqValidationError) ErrorName() string { return "CreateClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterReqValidationError{}

var _CreateClusterReq_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateClusterReq_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateClusterReq_BusinessID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateClusterReq_Environment_InLookup = map[string]struct{}{
	"stag":  {},
	"debug": {},
	"prod":  {},
}

var _CreateClusterReq_EngineType_InLookup = map[string]struct{}{
	"k8s":   {},
	"mesos": {},
}

var _CreateClusterReq_ClusterType_InLookup = map[string]struct{}{
	"federation": {},
	"single":     {},
}

// Validate checks the field values on CreateClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterRespMultiError, or nil if none found.
func (m *CreateClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterRespValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateClusterRespMultiError(errors)
	}

	return nil
}

// CreateClusterRespMultiError is an error wrapping multiple validation errors
// returned by CreateClusterResp.ValidateAll() if the designated constraints
// aren't met.
type CreateClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterRespMultiError) AllErrors() []error { return m }

// CreateClusterRespValidationError is the validation error returned by
// CreateClusterResp.Validate if the designated constraints aren't met.
type CreateClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterRespValidationError) ErrorName() string {
	return "CreateClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterRespValidationError{}

// Validate checks the field values on KubeConfigReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KubeConfigReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubeConfigReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KubeConfigReqMultiError, or
// nil if none found.
func (m *KubeConfigReq) ValidateAll() error {
	return m.validate(true)
}

func (m *KubeConfigReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKubeConfig()) < 1 {
		err := KubeConfigReqValidationError{
			field:  "KubeConfig",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return KubeConfigReqMultiError(errors)
	}

	return nil
}

// KubeConfigReqMultiError is an error wrapping multiple validation errors
// returned by KubeConfigReq.ValidateAll() if the designated constraints
// aren't met.
type KubeConfigReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubeConfigReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubeConfigReqMultiError) AllErrors() []error { return m }

// KubeConfigReqValidationError is the validation error returned by
// KubeConfigReq.Validate if the designated constraints aren't met.
type KubeConfigReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubeConfigReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubeConfigReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubeConfigReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubeConfigReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubeConfigReqValidationError) ErrorName() string { return "KubeConfigReqValidationError" }

// Error satisfies the builtin error interface
func (e KubeConfigReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubeConfigReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubeConfigReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubeConfigReqValidationError{}

// Validate checks the field values on KubeConfigResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KubeConfigResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubeConfigResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KubeConfigRespMultiError,
// or nil if none found.
func (m *KubeConfigResp) ValidateAll() error {
	return m.validate(true)
}

func (m *KubeConfigResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return KubeConfigRespMultiError(errors)
	}

	return nil
}

// KubeConfigRespMultiError is an error wrapping multiple validation errors
// returned by KubeConfigResp.ValidateAll() if the designated constraints
// aren't met.
type KubeConfigRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubeConfigRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubeConfigRespMultiError) AllErrors() []error { return m }

// KubeConfigRespValidationError is the validation error returned by
// KubeConfigResp.Validate if the designated constraints aren't met.
type KubeConfigRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubeConfigRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubeConfigRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubeConfigRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubeConfigRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubeConfigRespValidationError) ErrorName() string { return "KubeConfigRespValidationError" }

// Error satisfies the builtin error interface
func (e KubeConfigRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubeConfigResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubeConfigRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubeConfigRespValidationError{}

// Validate checks the field values on ImportCloudMode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportCloudMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportCloudMode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportCloudModeMultiError, or nil if none found.
func (m *ImportCloudMode) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportCloudMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for KubeConfig

	if len(errors) > 0 {
		return ImportCloudModeMultiError(errors)
	}

	return nil
}

// ImportCloudModeMultiError is an error wrapping multiple validation errors
// returned by ImportCloudMode.ValidateAll() if the designated constraints
// aren't met.
type ImportCloudModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportCloudModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportCloudModeMultiError) AllErrors() []error { return m }

// ImportCloudModeValidationError is the validation error returned by
// ImportCloudMode.Validate if the designated constraints aren't met.
type ImportCloudModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportCloudModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportCloudModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportCloudModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportCloudModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportCloudModeValidationError) ErrorName() string { return "ImportCloudModeValidationError" }

// Error satisfies the builtin error interface
func (e ImportCloudModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportCloudMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportCloudModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportCloudModeValidationError{}

// Validate checks the field values on ImportClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportClusterReqMultiError, or nil if none found.
func (m *ImportClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if l := utf8.RuneCountInString(m.GetClusterName()); l < 1 || l > 1024 {
		err := ImportClusterReqValidationError{
			field:  "ClusterName",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	if l := utf8.RuneCountInString(m.GetProvider()); l < 1 || l > 1024 {
		err := ImportClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := ImportClusterReqValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ImportClusterReq_Region_Pattern.MatchString(m.GetRegion()) {
		err := ImportClusterReqValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 100 {
		err := ImportClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ImportClusterReq_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := ImportClusterReqValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetBusinessID()); l < 1 || l > 100 {
		err := ImportClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ImportClusterReq_BusinessID_Pattern.MatchString(m.GetBusinessID()) {
		err := ImportClusterReqValidationError{
			field:  "BusinessID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _ImportClusterReq_Environment_InLookup[m.GetEnvironment()]; !ok {
		err := ImportClusterReqValidationError{
			field:  "Environment",
			reason: "value must be in list [stag debug prod]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _ImportClusterReq_EngineType_InLookup[m.GetEngineType()]; !ok {
		err := ImportClusterReqValidationError{
			field:  "EngineType",
			reason: "value must be in list [k8s mesos ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetIsExclusive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportClusterReqValidationError{
					field:  "IsExclusive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportClusterReqValidationError{
					field:  "IsExclusive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsExclusive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportClusterReqValidationError{
				field:  "IsExclusive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _ImportClusterReq_ClusterType_InLookup[m.GetClusterType()]; !ok {
		err := ImportClusterReqValidationError{
			field:  "ClusterType",
			reason: "value must be in list [federation single ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetLabels()) > 20 {
		err := ImportClusterReqValidationError{
			field:  "Labels",
			reason: "value must contain no more than 20 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 1 || l > 1024 {
		err := ImportClusterReqValidationError{
			field:  "Creator",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetCloudMode() == nil {
		err := ImportClusterReqValidationError{
			field:  "CloudMode",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetCloudMode(); a != nil {

	}

	// no validation rules for ManageType

	// no validation rules for NetworkType

	// no validation rules for ExtraInfo

	// no validation rules for ExtraClusterID

	// no validation rules for ClusterCategory

	// no validation rules for IsShared

	if utf8.RuneCountInString(m.GetVersion()) > 1024 {
		err := ImportClusterReqValidationError{
			field:  "Version",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountID()) > 1024 {
		err := ImportClusterReqValidationError{
			field:  "AccountID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ImportClusterReqMultiError(errors)
	}

	return nil
}

// ImportClusterReqMultiError is an error wrapping multiple validation errors
// returned by ImportClusterReq.ValidateAll() if the designated constraints
// aren't met.
type ImportClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportClusterReqMultiError) AllErrors() []error { return m }

// ImportClusterReqValidationError is the validation error returned by
// ImportClusterReq.Validate if the designated constraints aren't met.
type ImportClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportClusterReqValidationError) ErrorName() string { return "ImportClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e ImportClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportClusterReqValidationError{}

var _ImportClusterReq_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _ImportClusterReq_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _ImportClusterReq_BusinessID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _ImportClusterReq_Environment_InLookup = map[string]struct{}{
	"stag":  {},
	"debug": {},
	"prod":  {},
}

var _ImportClusterReq_EngineType_InLookup = map[string]struct{}{
	"k8s":   {},
	"mesos": {},
	"":      {},
}

var _ImportClusterReq_ClusterType_InLookup = map[string]struct{}{
	"federation": {},
	"single":     {},
	"":           {},
}

// Validate checks the field values on ImportClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportClusterRespMultiError, or nil if none found.
func (m *ImportClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ImportClusterRespMultiError(errors)
	}

	return nil
}

// ImportClusterRespMultiError is an error wrapping multiple validation errors
// returned by ImportClusterResp.ValidateAll() if the designated constraints
// aren't met.
type ImportClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportClusterRespMultiError) AllErrors() []error { return m }

// ImportClusterRespValidationError is the validation error returned by
// ImportClusterResp.Validate if the designated constraints aren't met.
type ImportClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportClusterRespValidationError) ErrorName() string {
	return "ImportClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e ImportClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportClusterRespValidationError{}

// Validate checks the field values on DeleteClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterReqMultiError, or nil if none found.
func (m *DeleteClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := DeleteClusterReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := DeleteClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteClusterReq_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := DeleteClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForced

	// no validation rules for InstanceDeleteMode

	// no validation rules for OnlyDeleteInfo

	// no validation rules for Operator

	// no validation rules for DeleteClusterRecord

	if len(errors) > 0 {
		return DeleteClusterReqMultiError(errors)
	}

	return nil
}

// DeleteClusterReqMultiError is an error wrapping multiple validation errors
// returned by DeleteClusterReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterReqMultiError) AllErrors() []error { return m }

// DeleteClusterReqValidationError is the validation error returned by
// DeleteClusterReq.Validate if the designated constraints aren't met.
type DeleteClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterReqValidationError) ErrorName() string { return "DeleteClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterReqValidationError{}

var _DeleteClusterReq_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterRespMultiError, or nil if none found.
func (m *DeleteClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteClusterRespValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteClusterRespMultiError(errors)
	}

	return nil
}

// DeleteClusterRespMultiError is an error wrapping multiple validation errors
// returned by DeleteClusterResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterRespMultiError) AllErrors() []error { return m }

// DeleteClusterRespValidationError is the validation error returned by
// DeleteClusterResp.Validate if the designated constraints aren't met.
type DeleteClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterRespValidationError) ErrorName() string {
	return "DeleteClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterRespValidationError{}

// Validate checks the field values on UpdateClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterReqMultiError, or nil if none found.
func (m *UpdateClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterID()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	if utf8.RuneCountInString(m.GetProvider()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	if utf8.RuneCountInString(m.GetVpcID()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "VpcID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Environment

	// no validation rules for EngineType

	if all {
		switch v := interface{}(m.GetIsExclusive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsExclusive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsExclusive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsExclusive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "IsExclusive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ClusterType

	// no validation rules for FederationClusterID

	if len(m.GetLabels()) > 20 {
		err := UpdateClusterReqValidationError{
			field:  "Labels",
			reason: "value must contain no more than 20 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUpdater()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "Updater",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateClusterReq_Status_InLookup[m.GetStatus()]; !ok {
		err := UpdateClusterReqValidationError{
			field:  "Status",
			reason: "value must be in list [CREATING RUNNING DELETING FAILURE INITIALIZATION DELETED ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetBcsAddons()))
		i := 0
		for key := range m.GetBcsAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetBcsAddons()[key]
			_ = val

			// no validation rules for BcsAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateClusterReqValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateClusterReqValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateClusterReqValidationError{
						field:  fmt.Sprintf("BcsAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraAddons()))
		i := 0
		for key := range m.GetExtraAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraAddons()[key]
			_ = val

			// no validation rules for ExtraAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateClusterReqValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateClusterReqValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateClusterReqValidationError{
						field:  fmt.Sprintf("ExtraAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for SystemID

	// no validation rules for ManageType

	if all {
		switch v := interface{}(m.GetNetworkSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "NetworkSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterBasicSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterBasicSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "ClusterBasicSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterAdvanceSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAdvanceSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "ClusterAdvanceSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "NodeSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NetworkType

	// no validation rules for ExtraInfo

	// no validation rules for ModuleID

	// no validation rules for ExtraClusterID

	if all {
		switch v := interface{}(m.GetIsCommonCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsCommonCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsCommonCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsCommonCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "IsCommonCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for ClusterCategory

	if all {
		switch v := interface{}(m.GetIsShared()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsShared",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsShared",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsShared()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "IsShared",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreateTime

	if utf8.RuneCountInString(m.GetCreator()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "Creator",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ImportCategory

	// no validation rules for CloudAccountID

	if len(errors) > 0 {
		return UpdateClusterReqMultiError(errors)
	}

	return nil
}

// UpdateClusterReqMultiError is an error wrapping multiple validation errors
// returned by UpdateClusterReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterReqMultiError) AllErrors() []error { return m }

// UpdateClusterReqValidationError is the validation error returned by
// UpdateClusterReq.Validate if the designated constraints aren't met.
type UpdateClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterReqValidationError) ErrorName() string { return "UpdateClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterReqValidationError{}

var _UpdateClusterReq_Status_InLookup = map[string]struct{}{
	"CREATING":       {},
	"RUNNING":        {},
	"DELETING":       {},
	"FAILURE":        {},
	"INITIALIZATION": {},
	"DELETED":        {},
	"":               {},
}

// Validate checks the field values on UpdateClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterRespMultiError, or nil if none found.
func (m *UpdateClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateClusterRespMultiError(errors)
	}

	return nil
}

// UpdateClusterRespMultiError is an error wrapping multiple validation errors
// returned by UpdateClusterResp.ValidateAll() if the designated constraints
// aren't met.
type UpdateClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterRespMultiError) AllErrors() []error { return m }

// UpdateClusterRespValidationError is the validation error returned by
// UpdateClusterResp.Validate if the designated constraints aren't met.
type UpdateClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterRespValidationError) ErrorName() string {
	return "UpdateClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterRespValidationError{}

// Validate checks the field values on RetryCreateClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RetryCreateClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryCreateClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryCreateClusterReqMultiError, or nil if none found.
func (m *RetryCreateClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryCreateClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if l := utf8.RuneCountInString(m.GetOperator()); l < 1 || l > 100 {
		err := RetryCreateClusterReqValidationError{
			field:  "Operator",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RetryCreateClusterReqMultiError(errors)
	}

	return nil
}

// RetryCreateClusterReqMultiError is an error wrapping multiple validation
// errors returned by RetryCreateClusterReq.ValidateAll() if the designated
// constraints aren't met.
type RetryCreateClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryCreateClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryCreateClusterReqMultiError) AllErrors() []error { return m }

// RetryCreateClusterReqValidationError is the validation error returned by
// RetryCreateClusterReq.Validate if the designated constraints aren't met.
type RetryCreateClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryCreateClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryCreateClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryCreateClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryCreateClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryCreateClusterReqValidationError) ErrorName() string {
	return "RetryCreateClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e RetryCreateClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryCreateClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryCreateClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryCreateClusterReqValidationError{}

// Validate checks the field values on RetryCreateClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RetryCreateClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryCreateClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryCreateClusterRespMultiError, or nil if none found.
func (m *RetryCreateClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryCreateClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryCreateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryCreateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryCreateClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryCreateClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryCreateClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryCreateClusterRespValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RetryCreateClusterRespMultiError(errors)
	}

	return nil
}

// RetryCreateClusterRespMultiError is an error wrapping multiple validation
// errors returned by RetryCreateClusterResp.ValidateAll() if the designated
// constraints aren't met.
type RetryCreateClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryCreateClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryCreateClusterRespMultiError) AllErrors() []error { return m }

// RetryCreateClusterRespValidationError is the validation error returned by
// RetryCreateClusterResp.Validate if the designated constraints aren't met.
type RetryCreateClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryCreateClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryCreateClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryCreateClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryCreateClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryCreateClusterRespValidationError) ErrorName() string {
	return "RetryCreateClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e RetryCreateClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryCreateClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryCreateClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryCreateClusterRespValidationError{}

// Validate checks the field values on GetClusterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetClusterReqMultiError, or
// nil if none found.
func (m *GetClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := GetClusterReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := GetClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetClusterReq_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := GetClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetClusterReqMultiError(errors)
	}

	return nil
}

// GetClusterReqMultiError is an error wrapping multiple validation errors
// returned by GetClusterReq.ValidateAll() if the designated constraints
// aren't met.
type GetClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterReqMultiError) AllErrors() []error { return m }

// GetClusterReqValidationError is the validation error returned by
// GetClusterReq.Validate if the designated constraints aren't met.
type GetClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterReqValidationError) ErrorName() string { return "GetClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e GetClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterReqValidationError{}

var _GetClusterReq_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetClusterResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetClusterRespMultiError,
// or nil if none found.
func (m *GetClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterRespValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetClusterRespMultiError(errors)
	}

	return nil
}

// GetClusterRespMultiError is an error wrapping multiple validation errors
// returned by GetClusterResp.ValidateAll() if the designated constraints
// aren't met.
type GetClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterRespMultiError) AllErrors() []error { return m }

// GetClusterRespValidationError is the validation error returned by
// GetClusterResp.Validate if the designated constraints aren't met.
type GetClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterRespValidationError) ErrorName() string { return "GetClusterRespValidationError" }

// Error satisfies the builtin error interface
func (e GetClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterRespValidationError{}

// Validate checks the field values on ExtraClusterInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExtraClusterInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtraClusterInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtraClusterInfoMultiError, or nil if none found.
func (m *ExtraClusterInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtraClusterInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProviderType

	if len(errors) > 0 {
		return ExtraClusterInfoMultiError(errors)
	}

	return nil
}

// ExtraClusterInfoMultiError is an error wrapping multiple validation errors
// returned by ExtraClusterInfo.ValidateAll() if the designated constraints
// aren't met.
type ExtraClusterInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtraClusterInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtraClusterInfoMultiError) AllErrors() []error { return m }

// ExtraClusterInfoValidationError is the validation error returned by
// ExtraClusterInfo.Validate if the designated constraints aren't met.
type ExtraClusterInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtraClusterInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtraClusterInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtraClusterInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtraClusterInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtraClusterInfoValidationError) ErrorName() string { return "ExtraClusterInfoValidationError" }

// Error satisfies the builtin error interface
func (e ExtraClusterInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtraClusterInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtraClusterInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtraClusterInfoValidationError{}

// Validate checks the field values on CheckNodesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CheckNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckNodesRequestMultiError, or nil if none found.
func (m *CheckNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CheckNodesRequestMultiError(errors)
	}

	return nil
}

// CheckNodesRequestMultiError is an error wrapping multiple validation errors
// returned by CheckNodesRequest.ValidateAll() if the designated constraints
// aren't met.
type CheckNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckNodesRequestMultiError) AllErrors() []error { return m }

// CheckNodesRequestValidationError is the validation error returned by
// CheckNodesRequest.Validate if the designated constraints aren't met.
type CheckNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckNodesRequestValidationError) ErrorName() string {
	return "CheckNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckNodesRequestValidationError{}

// Validate checks the field values on CheckNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckNodesResponseMultiError, or nil if none found.
func (m *CheckNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	{
		sorted_keys := make([]string, len(m.GetData()))
		i := 0
		for key := range m.GetData() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetData()[key]
			_ = val

			// no validation rules for Data[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CheckNodesResponseValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CheckNodesResponseValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CheckNodesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return CheckNodesResponseMultiError(errors)
	}

	return nil
}

// CheckNodesResponseMultiError is an error wrapping multiple validation errors
// returned by CheckNodesResponse.ValidateAll() if the designated constraints
// aren't met.
type CheckNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckNodesResponseMultiError) AllErrors() []error { return m }

// CheckNodesResponseValidationError is the validation error returned by
// CheckNodesResponse.Validate if the designated constraints aren't met.
type CheckNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckNodesResponseValidationError) ErrorName() string {
	return "CheckNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckNodesResponseValidationError{}

// Validate checks the field values on NodeResult with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeResultMultiError, or
// nil if none found.
func (m *NodeResult) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsExist

	// no validation rules for ClusterID

	// no validation rules for ClusterName

	if len(errors) > 0 {
		return NodeResultMultiError(errors)
	}

	return nil
}

// NodeResultMultiError is an error wrapping multiple validation errors
// returned by NodeResult.ValidateAll() if the designated constraints aren't met.
type NodeResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeResultMultiError) AllErrors() []error { return m }

// NodeResultValidationError is the validation error returned by
// NodeResult.Validate if the designated constraints aren't met.
type NodeResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeResultValidationError) ErrorName() string { return "NodeResultValidationError" }

// Error satisfies the builtin error interface
func (e NodeResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeResultValidationError{}

// Validate checks the field values on UnCordonNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnCordonNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnCordonNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnCordonNodeRequestMultiError, or nil if none found.
func (m *UnCordonNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnCordonNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClusterID()) < 1 {
		err := UnCordonNodeRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UnCordonNodeRequestMultiError(errors)
	}

	return nil
}

// UnCordonNodeRequestMultiError is an error wrapping multiple validation
// errors returned by UnCordonNodeRequest.ValidateAll() if the designated
// constraints aren't met.
type UnCordonNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnCordonNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnCordonNodeRequestMultiError) AllErrors() []error { return m }

// UnCordonNodeRequestValidationError is the validation error returned by
// UnCordonNodeRequest.Validate if the designated constraints aren't met.
type UnCordonNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnCordonNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnCordonNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnCordonNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnCordonNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnCordonNodeRequestValidationError) ErrorName() string {
	return "UnCordonNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnCordonNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnCordonNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnCordonNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnCordonNodeRequestValidationError{}

// Validate checks the field values on UnCordonNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnCordonNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnCordonNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnCordonNodeResponseMultiError, or nil if none found.
func (m *UnCordonNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnCordonNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnCordonNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnCordonNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnCordonNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnCordonNodeResponseMultiError(errors)
	}

	return nil
}

// UnCordonNodeResponseMultiError is an error wrapping multiple validation
// errors returned by UnCordonNodeResponse.ValidateAll() if the designated
// constraints aren't met.
type UnCordonNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnCordonNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnCordonNodeResponseMultiError) AllErrors() []error { return m }

// UnCordonNodeResponseValidationError is the validation error returned by
// UnCordonNodeResponse.Validate if the designated constraints aren't met.
type UnCordonNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnCordonNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnCordonNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnCordonNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnCordonNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnCordonNodeResponseValidationError) ErrorName() string {
	return "UnCordonNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnCordonNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnCordonNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnCordonNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnCordonNodeResponseValidationError{}

// Validate checks the field values on CordonNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CordonNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CordonNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CordonNodeRequestMultiError, or nil if none found.
func (m *CordonNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CordonNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClusterID()) < 1 {
		err := CordonNodeRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CordonNodeRequestMultiError(errors)
	}

	return nil
}

// CordonNodeRequestMultiError is an error wrapping multiple validation errors
// returned by CordonNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type CordonNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CordonNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CordonNodeRequestMultiError) AllErrors() []error { return m }

// CordonNodeRequestValidationError is the validation error returned by
// CordonNodeRequest.Validate if the designated constraints aren't met.
type CordonNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CordonNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CordonNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CordonNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CordonNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CordonNodeRequestValidationError) ErrorName() string {
	return "CordonNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CordonNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCordonNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CordonNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CordonNodeRequestValidationError{}

// Validate checks the field values on CordonNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CordonNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CordonNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CordonNodeResponseMultiError, or nil if none found.
func (m *CordonNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CordonNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CordonNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CordonNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CordonNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CordonNodeResponseMultiError(errors)
	}

	return nil
}

// CordonNodeResponseMultiError is an error wrapping multiple validation errors
// returned by CordonNodeResponse.ValidateAll() if the designated constraints
// aren't met.
type CordonNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CordonNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CordonNodeResponseMultiError) AllErrors() []error { return m }

// CordonNodeResponseValidationError is the validation error returned by
// CordonNodeResponse.Validate if the designated constraints aren't met.
type CordonNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CordonNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CordonNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CordonNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CordonNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CordonNodeResponseValidationError) ErrorName() string {
	return "CordonNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CordonNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCordonNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CordonNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CordonNodeResponseValidationError{}

// Validate checks the field values on UpdateNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeRequestMultiError, or nil if none found.
func (m *UpdateNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetInnerIPs()); l < 1 || l > 100 {
		err := UpdateNodeRequestValidationError{
			field:  "InnerIPs",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateNodeRequest_Status_InLookup[m.GetStatus()]; !ok {
		err := UpdateNodeRequestValidationError{
			field:  "Status",
			reason: "value must be in list [INITIALIZATION RUNNING DELETING ADD-FAILURE REMOVE-FAILURE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NodeGroupID

	// no validation rules for ClusterID

	if len(m.GetUpdater()) < 1 {
		err := UpdateNodeRequestValidationError{
			field:  "Updater",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateNodeRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeRequestMultiError) AllErrors() []error { return m }

// UpdateNodeRequestValidationError is the validation error returned by
// UpdateNodeRequest.Validate if the designated constraints aren't met.
type UpdateNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeRequestValidationError) ErrorName() string {
	return "UpdateNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeRequestValidationError{}

var _UpdateNodeRequest_Status_InLookup = map[string]struct{}{
	"INITIALIZATION": {},
	"RUNNING":        {},
	"DELETING":       {},
	"ADD-FAILURE":    {},
	"REMOVE-FAILURE": {},
}

// Validate checks the field values on UpdateNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeResponseMultiError, or nil if none found.
func (m *UpdateNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateNodeResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeResponseMultiError) AllErrors() []error { return m }

// UpdateNodeResponseValidationError is the validation error returned by
// UpdateNodeResponse.Validate if the designated constraints aren't met.
type UpdateNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeResponseValidationError) ErrorName() string {
	return "UpdateNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeResponseValidationError{}

// Validate checks the field values on NodeStatus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeStatusMultiError, or
// nil if none found.
func (m *NodeStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NodeStatusMultiError(errors)
	}

	return nil
}

// NodeStatusMultiError is an error wrapping multiple validation errors
// returned by NodeStatus.ValidateAll() if the designated constraints aren't met.
type NodeStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeStatusMultiError) AllErrors() []error { return m }

// NodeStatusValidationError is the validation error returned by
// NodeStatus.Validate if the designated constraints aren't met.
type NodeStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeStatusValidationError) ErrorName() string { return "NodeStatusValidationError" }

// Error satisfies the builtin error interface
func (e NodeStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeStatusValidationError{}

// Validate checks the field values on GetNodeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetNodeRequestMultiError,
// or nil if none found.
func (m *GetNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetInnerIP()); ip == nil || ip.To4() == nil {
		err := GetNodeRequestValidationError{
			field:  "InnerIP",
			reason: "value must be a valid IPv4 address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShowPwd

	if len(errors) > 0 {
		return GetNodeRequestMultiError(errors)
	}

	return nil
}

// GetNodeRequestMultiError is an error wrapping multiple validation errors
// returned by GetNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type GetNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeRequestMultiError) AllErrors() []error { return m }

// GetNodeRequestValidationError is the validation error returned by
// GetNodeRequest.Validate if the designated constraints aren't met.
type GetNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeRequestValidationError) ErrorName() string { return "GetNodeRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeRequestValidationError{}

// Validate checks the field values on GetNodeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeResponseMultiError, or nil if none found.
func (m *GetNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetNodeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetNodeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetNodeResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetNodeResponseMultiError(errors)
	}

	return nil
}

// GetNodeResponseMultiError is an error wrapping multiple validation errors
// returned by GetNodeResponse.ValidateAll() if the designated constraints
// aren't met.
type GetNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeResponseMultiError) AllErrors() []error { return m }

// GetNodeResponseValidationError is the validation error returned by
// GetNodeResponse.Validate if the designated constraints aren't met.
type GetNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeResponseValidationError) ErrorName() string { return "GetNodeResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeResponseValidationError{}

// Validate checks the field values on ListCommonClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCommonClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommonClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommonClusterReqMultiError, or nil if none found.
func (m *ListCommonClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommonClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListCommonClusterReqMultiError(errors)
	}

	return nil
}

// ListCommonClusterReqMultiError is an error wrapping multiple validation
// errors returned by ListCommonClusterReq.ValidateAll() if the designated
// constraints aren't met.
type ListCommonClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommonClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommonClusterReqMultiError) AllErrors() []error { return m }

// ListCommonClusterReqValidationError is the validation error returned by
// ListCommonClusterReq.Validate if the designated constraints aren't met.
type ListCommonClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommonClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommonClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommonClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommonClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommonClusterReqValidationError) ErrorName() string {
	return "ListCommonClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListCommonClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommonClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommonClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommonClusterReqValidationError{}

// Validate checks the field values on ListCommonClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCommonClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommonClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommonClusterRespMultiError, or nil if none found.
func (m *ListCommonClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommonClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCommonClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCommonClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCommonClusterRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCommonClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCommonClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCommonClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCommonClusterRespMultiError(errors)
	}

	return nil
}

// ListCommonClusterRespMultiError is an error wrapping multiple validation
// errors returned by ListCommonClusterResp.ValidateAll() if the designated
// constraints aren't met.
type ListCommonClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommonClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommonClusterRespMultiError) AllErrors() []error { return m }

// ListCommonClusterRespValidationError is the validation error returned by
// ListCommonClusterResp.Validate if the designated constraints aren't met.
type ListCommonClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommonClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommonClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommonClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommonClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommonClusterRespValidationError) ErrorName() string {
	return "ListCommonClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListCommonClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommonClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommonClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommonClusterRespValidationError{}

// Validate checks the field values on ListProjectClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectClusterReqMultiError, or nil if none found.
func (m *ListProjectClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := ListProjectClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListProjectClusterReqMultiError(errors)
	}

	return nil
}

// ListProjectClusterReqMultiError is an error wrapping multiple validation
// errors returned by ListProjectClusterReq.ValidateAll() if the designated
// constraints aren't met.
type ListProjectClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectClusterReqMultiError) AllErrors() []error { return m }

// ListProjectClusterReqValidationError is the validation error returned by
// ListProjectClusterReq.Validate if the designated constraints aren't met.
type ListProjectClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectClusterReqValidationError) ErrorName() string {
	return "ListProjectClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectClusterReqValidationError{}

// Validate checks the field values on ListProjectClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectClusterRespMultiError, or nil if none found.
func (m *ListProjectClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectClusterRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetClusterExtraInfo()))
		i := 0
		for key := range m.GetClusterExtraInfo() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClusterExtraInfo()[key]
			_ = val

			// no validation rules for ClusterExtraInfo[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ListProjectClusterRespValidationError{
							field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ListProjectClusterRespValidationError{
							field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ListProjectClusterRespValidationError{
						field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProjectClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProjectClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProjectClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListProjectClusterRespMultiError(errors)
	}

	return nil
}

// ListProjectClusterRespMultiError is an error wrapping multiple validation
// errors returned by ListProjectClusterResp.ValidateAll() if the designated
// constraints aren't met.
type ListProjectClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectClusterRespMultiError) AllErrors() []error { return m }

// ListProjectClusterRespValidationError is the validation error returned by
// ListProjectClusterResp.Validate if the designated constraints aren't met.
type ListProjectClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectClusterRespValidationError) ErrorName() string {
	return "ListProjectClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectClusterRespValidationError{}

// Validate checks the field values on ListClusterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListClusterReqMultiError,
// or nil if none found.
func (m *ListClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) > 100 {
		err := ListClusterReqValidationError{
			field:  "ClusterName",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProvider()) > 32 {
		err := ListClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := ListClusterReqValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVpcID()) > 32 {
		err := ListClusterReqValidationError{
			field:  "VpcID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := ListClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 100 {
		err := ListClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Environment

	// no validation rules for EngineType

	// no validation rules for IsExclusive

	// no validation rules for ClusterType

	// no validation rules for FederationClusterID

	if _, ok := _ListClusterReq_Status_InLookup[m.GetStatus()]; !ok {
		err := ListClusterReqValidationError{
			field:  "Status",
			reason: "value must be in list [CREATING RUNNING DELETING FALURE INITIALIZATION DELETED ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := ListClusterReqValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 1000 {
		err := ListClusterReqValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if utf8.RuneCountInString(m.GetSystemID()) > 100 {
		err := ListClusterReqValidationError{
			field:  "SystemID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ExtraClusterID

	// no validation rules for IsCommonCluster

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ListClusterReqMultiError(errors)
	}

	return nil
}

// ListClusterReqMultiError is an error wrapping multiple validation errors
// returned by ListClusterReq.ValidateAll() if the designated constraints
// aren't met.
type ListClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterReqMultiError) AllErrors() []error { return m }

// ListClusterReqValidationError is the validation error returned by
// ListClusterReq.Validate if the designated constraints aren't met.
type ListClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterReqValidationError) ErrorName() string { return "ListClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e ListClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterReqValidationError{}

var _ListClusterReq_Status_InLookup = map[string]struct{}{
	"CREATING":       {},
	"RUNNING":        {},
	"DELETING":       {},
	"FALURE":         {},
	"INITIALIZATION": {},
	"DELETED":        {},
	"":               {},
}

// Validate checks the field values on ListClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterRespMultiError, or nil if none found.
func (m *ListClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListClusterRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetClusterExtraInfo()))
		i := 0
		for key := range m.GetClusterExtraInfo() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClusterExtraInfo()[key]
			_ = val

			// no validation rules for ClusterExtraInfo[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ListClusterRespValidationError{
							field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ListClusterRespValidationError{
							field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ListClusterRespValidationError{
						field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListClusterRespMultiError(errors)
	}

	return nil
}

// ListClusterRespMultiError is an error wrapping multiple validation errors
// returned by ListClusterResp.ValidateAll() if the designated constraints
// aren't met.
type ListClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterRespMultiError) AllErrors() []error { return m }

// ListClusterRespValidationError is the validation error returned by
// ListClusterResp.Validate if the designated constraints aren't met.
type ListClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterRespValidationError) ErrorName() string { return "ListClusterRespValidationError" }

// Error satisfies the builtin error interface
func (e ListClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterRespValidationError{}

// Validate checks the field values on ExtraInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExtraInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtraInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExtraInfoMultiError, or nil
// if none found.
func (m *ExtraInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtraInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CanDeleted

	// no validation rules for ProviderType

	if len(errors) > 0 {
		return ExtraInfoMultiError(errors)
	}

	return nil
}

// ExtraInfoMultiError is an error wrapping multiple validation errors returned
// by ExtraInfo.ValidateAll() if the designated constraints aren't met.
type ExtraInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtraInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtraInfoMultiError) AllErrors() []error { return m }

// ExtraInfoValidationError is the validation error returned by
// ExtraInfo.Validate if the designated constraints aren't met.
type ExtraInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtraInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtraInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtraInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtraInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtraInfoValidationError) ErrorName() string { return "ExtraInfoValidationError" }

// Error satisfies the builtin error interface
func (e ExtraInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtraInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtraInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtraInfoValidationError{}

// Validate checks the field values on WebAnnotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebAnnotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAnnotations with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebAnnotationsMultiError,
// or nil if none found.
func (m *WebAnnotations) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAnnotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetPerms()))
		i := 0
		for key := range m.GetPerms() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPerms()[key]
			_ = val

			// no validation rules for Perms[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, WebAnnotationsValidationError{
							field:  fmt.Sprintf("Perms[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, WebAnnotationsValidationError{
							field:  fmt.Sprintf("Perms[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return WebAnnotationsValidationError{
						field:  fmt.Sprintf("Perms[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return WebAnnotationsMultiError(errors)
	}

	return nil
}

// WebAnnotationsMultiError is an error wrapping multiple validation errors
// returned by WebAnnotations.ValidateAll() if the designated constraints
// aren't met.
type WebAnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAnnotationsMultiError) AllErrors() []error { return m }

// WebAnnotationsValidationError is the validation error returned by
// WebAnnotations.Validate if the designated constraints aren't met.
type WebAnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAnnotationsValidationError) ErrorName() string { return "WebAnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e WebAnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAnnotationsValidationError{}

// Validate checks the field values on WebAnnotationsV2 with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WebAnnotationsV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAnnotationsV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebAnnotationsV2MultiError, or nil if none found.
func (m *WebAnnotationsV2) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAnnotationsV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPerms()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebAnnotationsV2ValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebAnnotationsV2ValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerms()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebAnnotationsV2ValidationError{
				field:  "Perms",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WebAnnotationsV2MultiError(errors)
	}

	return nil
}

// WebAnnotationsV2MultiError is an error wrapping multiple validation errors
// returned by WebAnnotationsV2.ValidateAll() if the designated constraints
// aren't met.
type WebAnnotationsV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAnnotationsV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAnnotationsV2MultiError) AllErrors() []error { return m }

// WebAnnotationsV2ValidationError is the validation error returned by
// WebAnnotationsV2.Validate if the designated constraints aren't met.
type WebAnnotationsV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAnnotationsV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAnnotationsV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAnnotationsV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAnnotationsV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAnnotationsV2ValidationError) ErrorName() string { return "WebAnnotationsV2ValidationError" }

// Error satisfies the builtin error interface
func (e WebAnnotationsV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAnnotationsV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAnnotationsV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAnnotationsV2ValidationError{}

// Validate checks the field values on ListNodesInClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInClusterRequestMultiError, or nil if none found.
func (m *ListNodesInClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := ListNodesInClusterRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := ListNodesInClusterRequestValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVpcID()) > 32 {
		err := ListNodesInClusterRequestValidationError{
			field:  "VpcID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNodeGroupID()) > 100 {
		err := ListNodesInClusterRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for InstanceType

	// no validation rules for Status

	if m.GetOffset() < 0 {
		err := ListNodesInClusterRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 1000 {
		err := ListNodesInClusterRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShowPwd

	if len(errors) > 0 {
		return ListNodesInClusterRequestMultiError(errors)
	}

	return nil
}

// ListNodesInClusterRequestMultiError is an error wrapping multiple validation
// errors returned by ListNodesInClusterRequest.ValidateAll() if the
// designated constraints aren't met.
type ListNodesInClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInClusterRequestMultiError) AllErrors() []error { return m }

// ListNodesInClusterRequestValidationError is the validation error returned by
// ListNodesInClusterRequest.Validate if the designated constraints aren't met.
type ListNodesInClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInClusterRequestValidationError) ErrorName() string {
	return "ListNodesInClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInClusterRequestValidationError{}

// Validate checks the field values on ListNodesInClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInClusterResponseMultiError, or nil if none found.
func (m *ListNodesInClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodesInClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodesInClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodesInClusterResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNodesInClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNodesInClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNodesInClusterResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListNodesInClusterResponseMultiError(errors)
	}

	return nil
}

// ListNodesInClusterResponseMultiError is an error wrapping multiple
// validation errors returned by ListNodesInClusterResponse.ValidateAll() if
// the designated constraints aren't met.
type ListNodesInClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInClusterResponseMultiError) AllErrors() []error { return m }

// ListNodesInClusterResponseValidationError is the validation error returned
// by ListNodesInClusterResponse.Validate if the designated constraints aren't met.
type ListNodesInClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInClusterResponseValidationError) ErrorName() string {
	return "ListNodesInClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInClusterResponseValidationError{}

// Validate checks the field values on ClusterNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterNodeMultiError, or
// nil if none found.
func (m *ClusterNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeID

	// no validation rules for InnerIP

	// no validation rules for InstanceType

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for Status

	// no validation rules for ZoneID

	// no validation rules for NodeGroupID

	// no validation rules for ClusterID

	// no validation rules for VPC

	// no validation rules for Region

	// no validation rules for Passwd

	// no validation rules for Zone

	// no validation rules for DeviceID

	// no validation rules for Labels

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterNodeValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterNodeValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterNodeValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for UnSchedulable

	// no validation rules for NodeName

	// no validation rules for Agent

	// no validation rules for Idc

	// no validation rules for Rack

	// no validation rules for DeviceClass

	// no validation rules for InnerIPv6

	// no validation rules for NodeGroupName

	if len(errors) > 0 {
		return ClusterNodeMultiError(errors)
	}

	return nil
}

// ClusterNodeMultiError is an error wrapping multiple validation errors
// returned by ClusterNode.ValidateAll() if the designated constraints aren't met.
type ClusterNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterNodeMultiError) AllErrors() []error { return m }

// ClusterNodeValidationError is the validation error returned by
// ClusterNode.Validate if the designated constraints aren't met.
type ClusterNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterNodeValidationError) ErrorName() string { return "ClusterNodeValidationError" }

// Error satisfies the builtin error interface
func (e ClusterNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterNodeValidationError{}

// Validate checks the field values on ListMastersInClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMastersInClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMastersInClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMastersInClusterRequestMultiError, or nil if none found.
func (m *ListMastersInClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMastersInClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := ListMastersInClusterRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListMastersInClusterRequestMultiError(errors)
	}

	return nil
}

// ListMastersInClusterRequestMultiError is an error wrapping multiple
// validation errors returned by ListMastersInClusterRequest.ValidateAll() if
// the designated constraints aren't met.
type ListMastersInClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMastersInClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMastersInClusterRequestMultiError) AllErrors() []error { return m }

// ListMastersInClusterRequestValidationError is the validation error returned
// by ListMastersInClusterRequest.Validate if the designated constraints
// aren't met.
type ListMastersInClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMastersInClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMastersInClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMastersInClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMastersInClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMastersInClusterRequestValidationError) ErrorName() string {
	return "ListMastersInClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMastersInClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMastersInClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMastersInClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMastersInClusterRequestValidationError{}

// Validate checks the field values on ListMastersInClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMastersInClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMastersInClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMastersInClusterResponseMultiError, or nil if none found.
func (m *ListMastersInClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMastersInClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMastersInClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMastersInClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMastersInClusterResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMastersInClusterResponseMultiError(errors)
	}

	return nil
}

// ListMastersInClusterResponseMultiError is an error wrapping multiple
// validation errors returned by ListMastersInClusterResponse.ValidateAll() if
// the designated constraints aren't met.
type ListMastersInClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMastersInClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMastersInClusterResponseMultiError) AllErrors() []error { return m }

// ListMastersInClusterResponseValidationError is the validation error returned
// by ListMastersInClusterResponse.Validate if the designated constraints
// aren't met.
type ListMastersInClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMastersInClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMastersInClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMastersInClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMastersInClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMastersInClusterResponseValidationError) ErrorName() string {
	return "ListMastersInClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMastersInClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMastersInClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMastersInClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMastersInClusterResponseValidationError{}

// Validate checks the field values on GetClusterCredentialReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterCredentialReqMultiError, or nil if none found.
func (m *GetClusterCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServerKey()); l < 1 || l > 100 {
		err := GetClusterCredentialReqValidationError{
			field:  "ServerKey",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetClusterCredentialReqMultiError(errors)
	}

	return nil
}

// GetClusterCredentialReqMultiError is an error wrapping multiple validation
// errors returned by GetClusterCredentialReq.ValidateAll() if the designated
// constraints aren't met.
type GetClusterCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterCredentialReqMultiError) AllErrors() []error { return m }

// GetClusterCredentialReqValidationError is the validation error returned by
// GetClusterCredentialReq.Validate if the designated constraints aren't met.
type GetClusterCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterCredentialReqValidationError) ErrorName() string {
	return "GetClusterCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterCredentialReqValidationError{}

// Validate checks the field values on GetClusterCredentialResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterCredentialRespMultiError, or nil if none found.
func (m *GetClusterCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterCredentialRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterCredentialRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterCredentialRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetClusterCredentialRespMultiError(errors)
	}

	return nil
}

// GetClusterCredentialRespMultiError is an error wrapping multiple validation
// errors returned by GetClusterCredentialResp.ValidateAll() if the designated
// constraints aren't met.
type GetClusterCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterCredentialRespMultiError) AllErrors() []error { return m }

// GetClusterCredentialRespValidationError is the validation error returned by
// GetClusterCredentialResp.Validate if the designated constraints aren't met.
type GetClusterCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterCredentialRespValidationError) ErrorName() string {
	return "GetClusterCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterCredentialRespValidationError{}

// Validate checks the field values on UpdateClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterCredentialReqMultiError, or nil if none found.
func (m *UpdateClusterCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServerKey()); l < 1 || l > 100 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ServerKey",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClientModule()); l < 1 || l > 100 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClientModule",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetServerAddress()); l < 1 || l > 2048 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ServerAddress",
			reason: "value length must be between 1 and 2048 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCaCertData()) > 4096 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "CaCertData",
			reason: "value length must be at most 4096 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUserToken()) > 2048 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "UserToken",
			reason: "value length must be at most 2048 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterDomain()) > 2048 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClusterDomain",
			reason: "value length must be at most 2048 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientCert()) > 4096 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClientCert",
			reason: "value length must be at most 4096 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientKey()) > 4096 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClientKey",
			reason: "value length must be at most 4096 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateClusterCredentialReqMultiError(errors)
	}

	return nil
}

// UpdateClusterCredentialReqMultiError is an error wrapping multiple
// validation errors returned by UpdateClusterCredentialReq.ValidateAll() if
// the designated constraints aren't met.
type UpdateClusterCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterCredentialReqMultiError) AllErrors() []error { return m }

// UpdateClusterCredentialReqValidationError is the validation error returned
// by UpdateClusterCredentialReq.Validate if the designated constraints aren't met.
type UpdateClusterCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterCredentialReqValidationError) ErrorName() string {
	return "UpdateClusterCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterCredentialReqValidationError{}

// Validate checks the field values on UpdateClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterCredentialRespMultiError, or nil if none found.
func (m *UpdateClusterCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateClusterCredentialRespMultiError(errors)
	}

	return nil
}

// UpdateClusterCredentialRespMultiError is an error wrapping multiple
// validation errors returned by UpdateClusterCredentialResp.ValidateAll() if
// the designated constraints aren't met.
type UpdateClusterCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterCredentialRespMultiError) AllErrors() []error { return m }

// UpdateClusterCredentialRespValidationError is the validation error returned
// by UpdateClusterCredentialResp.Validate if the designated constraints
// aren't met.
type UpdateClusterCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterCredentialRespValidationError) ErrorName() string {
	return "UpdateClusterCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterCredentialRespValidationError{}

// Validate checks the field values on DeleteClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterCredentialReqMultiError, or nil if none found.
func (m *DeleteClusterCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServerKey()); l < 1 || l > 100 {
		err := DeleteClusterCredentialReqValidationError{
			field:  "ServerKey",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteClusterCredentialReqMultiError(errors)
	}

	return nil
}

// DeleteClusterCredentialReqMultiError is an error wrapping multiple
// validation errors returned by DeleteClusterCredentialReq.ValidateAll() if
// the designated constraints aren't met.
type DeleteClusterCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterCredentialReqMultiError) AllErrors() []error { return m }

// DeleteClusterCredentialReqValidationError is the validation error returned
// by DeleteClusterCredentialReq.Validate if the designated constraints aren't met.
type DeleteClusterCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterCredentialReqValidationError) ErrorName() string {
	return "DeleteClusterCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterCredentialReqValidationError{}

// Validate checks the field values on DeleteClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterCredentialRespMultiError, or nil if none found.
func (m *DeleteClusterCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DeleteClusterCredentialRespMultiError(errors)
	}

	return nil
}

// DeleteClusterCredentialRespMultiError is an error wrapping multiple
// validation errors returned by DeleteClusterCredentialResp.ValidateAll() if
// the designated constraints aren't met.
type DeleteClusterCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterCredentialRespMultiError) AllErrors() []error { return m }

// DeleteClusterCredentialRespValidationError is the validation error returned
// by DeleteClusterCredentialResp.Validate if the designated constraints
// aren't met.
type DeleteClusterCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterCredentialRespValidationError) ErrorName() string {
	return "DeleteClusterCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterCredentialRespValidationError{}

// Validate checks the field values on ListClusterCredentialReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterCredentialReqMultiError, or nil if none found.
func (m *ListClusterCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetServerKey()) > 100 {
		err := ListClusterCredentialReqValidationError{
			field:  "ServerKey",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := ListClusterCredentialReqValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientMode()) > 100 {
		err := ListClusterCredentialReqValidationError{
			field:  "ClientMode",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetConnectMode()) > 100 {
		err := ListClusterCredentialReqValidationError{
			field:  "ConnectMode",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := ListClusterCredentialReqValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 1000 {
		err := ListClusterCredentialReqValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListClusterCredentialReqMultiError(errors)
	}

	return nil
}

// ListClusterCredentialReqMultiError is an error wrapping multiple validation
// errors returned by ListClusterCredentialReq.ValidateAll() if the designated
// constraints aren't met.
type ListClusterCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterCredentialReqMultiError) AllErrors() []error { return m }

// ListClusterCredentialReqValidationError is the validation error returned by
// ListClusterCredentialReq.Validate if the designated constraints aren't met.
type ListClusterCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterCredentialReqValidationError) ErrorName() string {
	return "ListClusterCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterCredentialReqValidationError{}

// Validate checks the field values on ListClusterCredentialResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterCredentialRespMultiError, or nil if none found.
func (m *ListClusterCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListClusterCredentialRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListClusterCredentialRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListClusterCredentialRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListClusterCredentialRespMultiError(errors)
	}

	return nil
}

// ListClusterCredentialRespMultiError is an error wrapping multiple validation
// errors returned by ListClusterCredentialResp.ValidateAll() if the
// designated constraints aren't met.
type ListClusterCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterCredentialRespMultiError) AllErrors() []error { return m }

// ListClusterCredentialRespValidationError is the validation error returned by
// ListClusterCredentialResp.Validate if the designated constraints aren't met.
type ListClusterCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterCredentialRespValidationError) ErrorName() string {
	return "ListClusterCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterCredentialRespValidationError{}

// Validate checks the field values on InitFederationClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitFederationClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitFederationClusterReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitFederationClusterReqMultiError, or nil if none found.
func (m *InitFederationClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InitFederationClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return InitFederationClusterReqMultiError(errors)
	}

	return nil
}

// InitFederationClusterReqMultiError is an error wrapping multiple validation
// errors returned by InitFederationClusterReq.ValidateAll() if the designated
// constraints aren't met.
type InitFederationClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitFederationClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitFederationClusterReqMultiError) AllErrors() []error { return m }

// InitFederationClusterReqValidationError is the validation error returned by
// InitFederationClusterReq.Validate if the designated constraints aren't met.
type InitFederationClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitFederationClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitFederationClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitFederationClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitFederationClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitFederationClusterReqValidationError) ErrorName() string {
	return "InitFederationClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e InitFederationClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitFederationClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitFederationClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitFederationClusterReqValidationError{}

// Validate checks the field values on InitFederationClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitFederationClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitFederationClusterResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitFederationClusterRespMultiError, or nil if none found.
func (m *InitFederationClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *InitFederationClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return InitFederationClusterRespMultiError(errors)
	}

	return nil
}

// InitFederationClusterRespMultiError is an error wrapping multiple validation
// errors returned by InitFederationClusterResp.ValidateAll() if the
// designated constraints aren't met.
type InitFederationClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitFederationClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitFederationClusterRespMultiError) AllErrors() []error { return m }

// InitFederationClusterRespValidationError is the validation error returned by
// InitFederationClusterResp.Validate if the designated constraints aren't met.
type InitFederationClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitFederationClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitFederationClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitFederationClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitFederationClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitFederationClusterRespValidationError) ErrorName() string {
	return "InitFederationClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e InitFederationClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitFederationClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitFederationClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitFederationClusterRespValidationError{}

// Validate checks the field values on AddFederatedClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddFederatedClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFederatedClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFederatedClusterReqMultiError, or nil if none found.
func (m *AddFederatedClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFederatedClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FederationClusterID

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return AddFederatedClusterReqMultiError(errors)
	}

	return nil
}

// AddFederatedClusterReqMultiError is an error wrapping multiple validation
// errors returned by AddFederatedClusterReq.ValidateAll() if the designated
// constraints aren't met.
type AddFederatedClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFederatedClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFederatedClusterReqMultiError) AllErrors() []error { return m }

// AddFederatedClusterReqValidationError is the validation error returned by
// AddFederatedClusterReq.Validate if the designated constraints aren't met.
type AddFederatedClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFederatedClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFederatedClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFederatedClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFederatedClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFederatedClusterReqValidationError) ErrorName() string {
	return "AddFederatedClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e AddFederatedClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFederatedClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFederatedClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFederatedClusterReqValidationError{}

// Validate checks the field values on AddFederatedClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddFederatedClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFederatedClusterResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFederatedClusterRespMultiError, or nil if none found.
func (m *AddFederatedClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFederatedClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return AddFederatedClusterRespMultiError(errors)
	}

	return nil
}

// AddFederatedClusterRespMultiError is an error wrapping multiple validation
// errors returned by AddFederatedClusterResp.ValidateAll() if the designated
// constraints aren't met.
type AddFederatedClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFederatedClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFederatedClusterRespMultiError) AllErrors() []error { return m }

// AddFederatedClusterRespValidationError is the validation error returned by
// AddFederatedClusterResp.Validate if the designated constraints aren't met.
type AddFederatedClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFederatedClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFederatedClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFederatedClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFederatedClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFederatedClusterRespValidationError) ErrorName() string {
	return "AddFederatedClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e AddFederatedClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFederatedClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFederatedClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFederatedClusterRespValidationError{}

// Validate checks the field values on CreateNamespaceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceReqMultiError, or nil if none found.
func (m *CreateNamespaceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := CreateNamespaceReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := CreateNamespaceReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := CreateNamespaceReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 100 {
		err := CreateNamespaceReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Labels

	// no validation rules for MaxQuota

	if len(errors) > 0 {
		return CreateNamespaceReqMultiError(errors)
	}

	return nil
}

// CreateNamespaceReqMultiError is an error wrapping multiple validation errors
// returned by CreateNamespaceReq.ValidateAll() if the designated constraints
// aren't met.
type CreateNamespaceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceReqMultiError) AllErrors() []error { return m }

// CreateNamespaceReqValidationError is the validation error returned by
// CreateNamespaceReq.Validate if the designated constraints aren't met.
type CreateNamespaceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceReqValidationError) ErrorName() string {
	return "CreateNamespaceReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceReqValidationError{}

// Validate checks the field values on CreateNamespaceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceRespMultiError, or nil if none found.
func (m *CreateNamespaceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateNamespaceRespMultiError(errors)
	}

	return nil
}

// CreateNamespaceRespMultiError is an error wrapping multiple validation
// errors returned by CreateNamespaceResp.ValidateAll() if the designated
// constraints aren't met.
type CreateNamespaceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceRespMultiError) AllErrors() []error { return m }

// CreateNamespaceRespValidationError is the validation error returned by
// CreateNamespaceResp.Validate if the designated constraints aren't met.
type CreateNamespaceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceRespValidationError) ErrorName() string {
	return "CreateNamespaceRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceRespValidationError{}

// Validate checks the field values on DeleteNamespaceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNamespaceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNamespaceReqMultiError, or nil if none found.
func (m *DeleteNamespaceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 100 {
		err := DeleteNamespaceReqValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := DeleteNamespaceReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForced

	if len(errors) > 0 {
		return DeleteNamespaceReqMultiError(errors)
	}

	return nil
}

// DeleteNamespaceReqMultiError is an error wrapping multiple validation errors
// returned by DeleteNamespaceReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteNamespaceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceReqMultiError) AllErrors() []error { return m }

// DeleteNamespaceReqValidationError is the validation error returned by
// DeleteNamespaceReq.Validate if the designated constraints aren't met.
type DeleteNamespaceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceReqValidationError) ErrorName() string {
	return "DeleteNamespaceReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceReqValidationError{}

// Validate checks the field values on DeleteNamespaceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNamespaceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNamespaceRespMultiError, or nil if none found.
func (m *DeleteNamespaceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DeleteNamespaceRespMultiError(errors)
	}

	return nil
}

// DeleteNamespaceRespMultiError is an error wrapping multiple validation
// errors returned by DeleteNamespaceResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteNamespaceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceRespMultiError) AllErrors() []error { return m }

// DeleteNamespaceRespValidationError is the validation error returned by
// DeleteNamespaceResp.Validate if the designated constraints aren't met.
type DeleteNamespaceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceRespValidationError) ErrorName() string {
	return "DeleteNamespaceRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceRespValidationError{}

// Validate checks the field values on UpdateNamespaceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNamespaceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNamespaceReqMultiError, or nil if none found.
func (m *UpdateNamespaceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 100 {
		err := UpdateNamespaceReqValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := UpdateNamespaceReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Labels

	// no validation rules for MaxQuota

	if len(errors) > 0 {
		return UpdateNamespaceReqMultiError(errors)
	}

	return nil
}

// UpdateNamespaceReqMultiError is an error wrapping multiple validation errors
// returned by UpdateNamespaceReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateNamespaceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceReqMultiError) AllErrors() []error { return m }

// UpdateNamespaceReqValidationError is the validation error returned by
// UpdateNamespaceReq.Validate if the designated constraints aren't met.
type UpdateNamespaceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceReqValidationError) ErrorName() string {
	return "UpdateNamespaceReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceReqValidationError{}

// Validate checks the field values on UpdateNamespaceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNamespaceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNamespaceRespMultiError, or nil if none found.
func (m *UpdateNamespaceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateNamespaceRespMultiError(errors)
	}

	return nil
}

// UpdateNamespaceRespMultiError is an error wrapping multiple validation
// errors returned by UpdateNamespaceResp.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespaceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceRespMultiError) AllErrors() []error { return m }

// UpdateNamespaceRespValidationError is the validation error returned by
// UpdateNamespaceResp.Validate if the designated constraints aren't met.
type UpdateNamespaceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceRespValidationError) ErrorName() string {
	return "UpdateNamespaceRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceRespValidationError{}

// Validate checks the field values on GetNamespaceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNamespaceReqMultiError, or nil if none found.
func (m *GetNamespaceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 100 {
		err := GetNamespaceReqValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := GetNamespaceReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNamespaceReqMultiError(errors)
	}

	return nil
}

// GetNamespaceReqMultiError is an error wrapping multiple validation errors
// returned by GetNamespaceReq.ValidateAll() if the designated constraints
// aren't met.
type GetNamespaceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceReqMultiError) AllErrors() []error { return m }

// GetNamespaceReqValidationError is the validation error returned by
// GetNamespaceReq.Validate if the designated constraints aren't met.
type GetNamespaceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceReqValidationError) ErrorName() string { return "GetNamespaceReqValidationError" }

// Error satisfies the builtin error interface
func (e GetNamespaceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceReqValidationError{}

// Validate checks the field values on GetNamespaceResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNamespaceRespMultiError, or nil if none found.
func (m *GetNamespaceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNamespaceRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNamespaceRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNamespaceRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNamespaceRespMultiError(errors)
	}

	return nil
}

// GetNamespaceRespMultiError is an error wrapping multiple validation errors
// returned by GetNamespaceResp.ValidateAll() if the designated constraints
// aren't met.
type GetNamespaceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceRespMultiError) AllErrors() []error { return m }

// GetNamespaceRespValidationError is the validation error returned by
// GetNamespaceResp.Validate if the designated constraints aren't met.
type GetNamespaceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceRespValidationError) ErrorName() string { return "GetNamespaceRespValidationError" }

// Error satisfies the builtin error interface
func (e GetNamespaceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceRespValidationError{}

// Validate checks the field values on ListNamespaceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNamespaceReqMultiError, or nil if none found.
func (m *ListNamespaceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := ListNamespaceReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := ListNamespaceReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 100 {
		err := ListNamespaceReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Offset

	// no validation rules for Limit

	if len(errors) > 0 {
		return ListNamespaceReqMultiError(errors)
	}

	return nil
}

// ListNamespaceReqMultiError is an error wrapping multiple validation errors
// returned by ListNamespaceReq.ValidateAll() if the designated constraints
// aren't met.
type ListNamespaceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceReqMultiError) AllErrors() []error { return m }

// ListNamespaceReqValidationError is the validation error returned by
// ListNamespaceReq.Validate if the designated constraints aren't met.
type ListNamespaceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceReqValidationError) ErrorName() string { return "ListNamespaceReqValidationError" }

// Error satisfies the builtin error interface
func (e ListNamespaceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceReqValidationError{}

// Validate checks the field values on ListNamespaceResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNamespaceRespMultiError, or nil if none found.
func (m *ListNamespaceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNamespaceRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNamespaceRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNamespaceRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNamespaceRespMultiError(errors)
	}

	return nil
}

// ListNamespaceRespMultiError is an error wrapping multiple validation errors
// returned by ListNamespaceResp.ValidateAll() if the designated constraints
// aren't met.
type ListNamespaceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceRespMultiError) AllErrors() []error { return m }

// ListNamespaceRespValidationError is the validation error returned by
// ListNamespaceResp.Validate if the designated constraints aren't met.
type ListNamespaceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceRespValidationError) ErrorName() string {
	return "ListNamespaceRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceRespValidationError{}

// Validate checks the field values on CreateNamespaceQuotaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceQuotaReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceQuotaReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceQuotaReqMultiError, or nil if none found.
func (m *CreateNamespaceQuotaReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceQuotaReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 2 || l > 100 {
		err := CreateNamespaceQuotaReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := CreateNamespaceQuotaReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := CreateNamespaceQuotaReqValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := CreateNamespaceQuotaReqValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceQuota

	if len(errors) > 0 {
		return CreateNamespaceQuotaReqMultiError(errors)
	}

	return nil
}

// CreateNamespaceQuotaReqMultiError is an error wrapping multiple validation
// errors returned by CreateNamespaceQuotaReq.ValidateAll() if the designated
// constraints aren't met.
type CreateNamespaceQuotaReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceQuotaReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceQuotaReqMultiError) AllErrors() []error { return m }

// CreateNamespaceQuotaReqValidationError is the validation error returned by
// CreateNamespaceQuotaReq.Validate if the designated constraints aren't met.
type CreateNamespaceQuotaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceQuotaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceQuotaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceQuotaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceQuotaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceQuotaReqValidationError) ErrorName() string {
	return "CreateNamespaceQuotaReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceQuotaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceQuotaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceQuotaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceQuotaReqValidationError{}

// Validate checks the field values on CreateNamespaceQuotaResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceQuotaResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceQuotaResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceQuotaRespMultiError, or nil if none found.
func (m *CreateNamespaceQuotaResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceQuotaResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNamespaceQuotaRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNamespaceQuotaRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNamespaceQuotaRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNamespaceQuotaRespMultiError(errors)
	}

	return nil
}

// CreateNamespaceQuotaRespMultiError is an error wrapping multiple validation
// errors returned by CreateNamespaceQuotaResp.ValidateAll() if the designated
// constraints aren't met.
type CreateNamespaceQuotaRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceQuotaRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceQuotaRespMultiError) AllErrors() []error { return m }

// CreateNamespaceQuotaRespValidationError is the validation error returned by
// CreateNamespaceQuotaResp.Validate if the designated constraints aren't met.
type CreateNamespaceQuotaRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceQuotaRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceQuotaRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceQuotaRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceQuotaRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceQuotaRespValidationError) ErrorName() string {
	return "CreateNamespaceQuotaRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceQuotaRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceQuotaResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceQuotaRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceQuotaRespValidationError{}

// Validate checks the field values on DeleteNamespaceQuotaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNamespaceQuotaReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceQuotaReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNamespaceQuotaReqMultiError, or nil if none found.
func (m *DeleteNamespaceQuotaReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceQuotaReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 2 || l > 100 {
		err := DeleteNamespaceQuotaReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := DeleteNamespaceQuotaReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := DeleteNamespaceQuotaReqValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForced

	if len(errors) > 0 {
		return DeleteNamespaceQuotaReqMultiError(errors)
	}

	return nil
}

// DeleteNamespaceQuotaReqMultiError is an error wrapping multiple validation
// errors returned by DeleteNamespaceQuotaReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteNamespaceQuotaReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceQuotaReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceQuotaReqMultiError) AllErrors() []error { return m }

// DeleteNamespaceQuotaReqValidationError is the validation error returned by
// DeleteNamespaceQuotaReq.Validate if the designated constraints aren't met.
type DeleteNamespaceQuotaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceQuotaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceQuotaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceQuotaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceQuotaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceQuotaReqValidationError) ErrorName() string {
	return "DeleteNamespaceQuotaReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceQuotaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceQuotaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceQuotaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceQuotaReqValidationError{}

// Validate checks the field values on DeleteNamespaceQuotaResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNamespaceQuotaResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceQuotaResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNamespaceQuotaRespMultiError, or nil if none found.
func (m *DeleteNamespaceQuotaResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceQuotaResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DeleteNamespaceQuotaRespMultiError(errors)
	}

	return nil
}

// DeleteNamespaceQuotaRespMultiError is an error wrapping multiple validation
// errors returned by DeleteNamespaceQuotaResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteNamespaceQuotaRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceQuotaRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceQuotaRespMultiError) AllErrors() []error { return m }

// DeleteNamespaceQuotaRespValidationError is the validation error returned by
// DeleteNamespaceQuotaResp.Validate if the designated constraints aren't met.
type DeleteNamespaceQuotaRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceQuotaRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceQuotaRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceQuotaRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceQuotaRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceQuotaRespValidationError) ErrorName() string {
	return "DeleteNamespaceQuotaRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceQuotaRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceQuotaResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceQuotaRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceQuotaRespValidationError{}

// Validate checks the field values on UpdateNamespaceQuotaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNamespaceQuotaReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceQuotaReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNamespaceQuotaReqMultiError, or nil if none found.
func (m *UpdateNamespaceQuotaReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceQuotaReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 2 || l > 100 {
		err := UpdateNamespaceQuotaReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := UpdateNamespaceQuotaReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := UpdateNamespaceQuotaReqValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceQuota

	if len(errors) > 0 {
		return UpdateNamespaceQuotaReqMultiError(errors)
	}

	return nil
}

// UpdateNamespaceQuotaReqMultiError is an error wrapping multiple validation
// errors returned by UpdateNamespaceQuotaReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespaceQuotaReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceQuotaReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceQuotaReqMultiError) AllErrors() []error { return m }

// UpdateNamespaceQuotaReqValidationError is the validation error returned by
// UpdateNamespaceQuotaReq.Validate if the designated constraints aren't met.
type UpdateNamespaceQuotaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceQuotaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceQuotaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceQuotaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceQuotaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceQuotaReqValidationError) ErrorName() string {
	return "UpdateNamespaceQuotaReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceQuotaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceQuotaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceQuotaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceQuotaReqValidationError{}

// Validate checks the field values on UpdateNamespaceQuotaResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNamespaceQuotaResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceQuotaResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNamespaceQuotaRespMultiError, or nil if none found.
func (m *UpdateNamespaceQuotaResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceQuotaResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateNamespaceQuotaRespMultiError(errors)
	}

	return nil
}

// UpdateNamespaceQuotaRespMultiError is an error wrapping multiple validation
// errors returned by UpdateNamespaceQuotaResp.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespaceQuotaRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceQuotaRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceQuotaRespMultiError) AllErrors() []error { return m }

// UpdateNamespaceQuotaRespValidationError is the validation error returned by
// UpdateNamespaceQuotaResp.Validate if the designated constraints aren't met.
type UpdateNamespaceQuotaRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceQuotaRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceQuotaRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceQuotaRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceQuotaRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceQuotaRespValidationError) ErrorName() string {
	return "UpdateNamespaceQuotaRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceQuotaRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceQuotaResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceQuotaRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceQuotaRespValidationError{}

// Validate checks the field values on GetNamespaceQuotaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceQuotaReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceQuotaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNamespaceQuotaReqMultiError, or nil if none found.
func (m *GetNamespaceQuotaReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceQuotaReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 2 || l > 100 {
		err := GetNamespaceQuotaReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := GetNamespaceQuotaReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := GetNamespaceQuotaReqValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNamespaceQuotaReqMultiError(errors)
	}

	return nil
}

// GetNamespaceQuotaReqMultiError is an error wrapping multiple validation
// errors returned by GetNamespaceQuotaReq.ValidateAll() if the designated
// constraints aren't met.
type GetNamespaceQuotaReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceQuotaReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceQuotaReqMultiError) AllErrors() []error { return m }

// GetNamespaceQuotaReqValidationError is the validation error returned by
// GetNamespaceQuotaReq.Validate if the designated constraints aren't met.
type GetNamespaceQuotaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceQuotaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceQuotaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceQuotaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceQuotaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceQuotaReqValidationError) ErrorName() string {
	return "GetNamespaceQuotaReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetNamespaceQuotaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceQuotaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceQuotaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceQuotaReqValidationError{}

// Validate checks the field values on GetNamespaceQuotaResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceQuotaResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceQuotaResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNamespaceQuotaRespMultiError, or nil if none found.
func (m *GetNamespaceQuotaResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceQuotaResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNamespaceQuotaRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNamespaceQuotaRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNamespaceQuotaRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNamespaceQuotaRespMultiError(errors)
	}

	return nil
}

// GetNamespaceQuotaRespMultiError is an error wrapping multiple validation
// errors returned by GetNamespaceQuotaResp.ValidateAll() if the designated
// constraints aren't met.
type GetNamespaceQuotaRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceQuotaRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceQuotaRespMultiError) AllErrors() []error { return m }

// GetNamespaceQuotaRespValidationError is the validation error returned by
// GetNamespaceQuotaResp.Validate if the designated constraints aren't met.
type GetNamespaceQuotaRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceQuotaRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceQuotaRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceQuotaRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceQuotaRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceQuotaRespValidationError) ErrorName() string {
	return "GetNamespaceQuotaRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetNamespaceQuotaRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceQuotaResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceQuotaRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceQuotaRespValidationError{}

// Validate checks the field values on ListNamespaceQuotaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceQuotaReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceQuotaReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNamespaceQuotaReqMultiError, or nil if none found.
func (m *ListNamespaceQuotaReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceQuotaReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetNamespace()) > 100 {
		err := ListNamespaceQuotaReqValidationError{
			field:  "Namespace",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFederationClusterID()) > 100 {
		err := ListNamespaceQuotaReqValidationError{
			field:  "FederationClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Offset

	// no validation rules for Limit

	if len(errors) > 0 {
		return ListNamespaceQuotaReqMultiError(errors)
	}

	return nil
}

// ListNamespaceQuotaReqMultiError is an error wrapping multiple validation
// errors returned by ListNamespaceQuotaReq.ValidateAll() if the designated
// constraints aren't met.
type ListNamespaceQuotaReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceQuotaReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceQuotaReqMultiError) AllErrors() []error { return m }

// ListNamespaceQuotaReqValidationError is the validation error returned by
// ListNamespaceQuotaReq.Validate if the designated constraints aren't met.
type ListNamespaceQuotaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceQuotaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceQuotaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceQuotaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceQuotaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceQuotaReqValidationError) ErrorName() string {
	return "ListNamespaceQuotaReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceQuotaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceQuotaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceQuotaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceQuotaReqValidationError{}

// Validate checks the field values on ListNamespaceQuotaResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceQuotaResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceQuotaResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNamespaceQuotaRespMultiError, or nil if none found.
func (m *ListNamespaceQuotaResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceQuotaResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNamespaceQuotaRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNamespaceQuotaRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNamespaceQuotaRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNamespaceQuotaRespMultiError(errors)
	}

	return nil
}

// ListNamespaceQuotaRespMultiError is an error wrapping multiple validation
// errors returned by ListNamespaceQuotaResp.ValidateAll() if the designated
// constraints aren't met.
type ListNamespaceQuotaRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceQuotaRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceQuotaRespMultiError) AllErrors() []error { return m }

// ListNamespaceQuotaRespValidationError is the validation error returned by
// ListNamespaceQuotaResp.Validate if the designated constraints aren't met.
type ListNamespaceQuotaRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceQuotaRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceQuotaRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceQuotaRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceQuotaRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceQuotaRespValidationError) ErrorName() string {
	return "ListNamespaceQuotaRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceQuotaRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceQuotaResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceQuotaRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceQuotaRespValidationError{}

// Validate checks the field values on CreateNamespaceWithQuotaReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceWithQuotaReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceWithQuotaReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceWithQuotaReqMultiError, or nil if none found.
func (m *CreateNamespaceWithQuotaReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceWithQuotaReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for FederationClusterID

	// no validation rules for ProjectID

	// no validation rules for BusinessID

	// no validation rules for Labels

	// no validation rules for ClusterID

	// no validation rules for Region

	// no validation rules for MaxQuota

	// no validation rules for ResourceQuota

	if len(errors) > 0 {
		return CreateNamespaceWithQuotaReqMultiError(errors)
	}

	return nil
}

// CreateNamespaceWithQuotaReqMultiError is an error wrapping multiple
// validation errors returned by CreateNamespaceWithQuotaReq.ValidateAll() if
// the designated constraints aren't met.
type CreateNamespaceWithQuotaReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceWithQuotaReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceWithQuotaReqMultiError) AllErrors() []error { return m }

// CreateNamespaceWithQuotaReqValidationError is the validation error returned
// by CreateNamespaceWithQuotaReq.Validate if the designated constraints
// aren't met.
type CreateNamespaceWithQuotaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceWithQuotaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceWithQuotaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceWithQuotaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceWithQuotaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceWithQuotaReqValidationError) ErrorName() string {
	return "CreateNamespaceWithQuotaReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceWithQuotaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceWithQuotaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceWithQuotaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceWithQuotaReqValidationError{}

// Validate checks the field values on CreateNamespaceWithQuotaResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceWithQuotaResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceWithQuotaResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceWithQuotaRespMultiError, or nil if none found.
func (m *CreateNamespaceWithQuotaResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceWithQuotaResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNamespaceWithQuotaRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNamespaceWithQuotaRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNamespaceWithQuotaRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNamespaceWithQuotaRespMultiError(errors)
	}

	return nil
}

// CreateNamespaceWithQuotaRespMultiError is an error wrapping multiple
// validation errors returned by CreateNamespaceWithQuotaResp.ValidateAll() if
// the designated constraints aren't met.
type CreateNamespaceWithQuotaRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceWithQuotaRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceWithQuotaRespMultiError) AllErrors() []error { return m }

// CreateNamespaceWithQuotaRespValidationError is the validation error returned
// by CreateNamespaceWithQuotaResp.Validate if the designated constraints
// aren't met.
type CreateNamespaceWithQuotaRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceWithQuotaRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceWithQuotaRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceWithQuotaRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceWithQuotaRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceWithQuotaRespValidationError) ErrorName() string {
	return "CreateNamespaceWithQuotaRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceWithQuotaRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceWithQuotaResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceWithQuotaRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceWithQuotaRespValidationError{}

// Validate checks the field values on CreateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProjectRequestMultiError, or nil if none found.
func (m *CreateProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CreateProjectRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnglishName()) < 1 {
		err := CreateProjectRequestValidationError{
			field:  "EnglishName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) < 1 {
		err := CreateProjectRequestValidationError{
			field:  "Creator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProjectType

	// no validation rules for UseBKRes

	// no validation rules for Description

	// no validation rules for IsOffline

	// no validation rules for Kind

	// no validation rules for BusinessID

	if _, ok := _CreateProjectRequest_DeployType_InLookup[m.GetDeployType()]; !ok {
		err := CreateProjectRequestValidationError{
			field:  "DeployType",
			reason: "value must be in list [1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for BgID

	// no validation rules for BgName

	// no validation rules for DeptID

	// no validation rules for DeptName

	// no validation rules for CenterID

	// no validation rules for CenterName

	// no validation rules for IsSecret

	{
		sorted_keys := make([]string, len(m.GetCredentials()))
		i := 0
		for key := range m.GetCredentials() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCredentials()[key]
			_ = val

			// no validation rules for Credentials[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateProjectRequestValidationError{
							field:  fmt.Sprintf("Credentials[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateProjectRequestValidationError{
							field:  fmt.Sprintf("Credentials[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateProjectRequestValidationError{
						field:  fmt.Sprintf("Credentials[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return CreateProjectRequestMultiError(errors)
	}

	return nil
}

// CreateProjectRequestMultiError is an error wrapping multiple validation
// errors returned by CreateProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProjectRequestMultiError) AllErrors() []error { return m }

// CreateProjectRequestValidationError is the validation error returned by
// CreateProjectRequest.Validate if the designated constraints aren't met.
type CreateProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProjectRequestValidationError) ErrorName() string {
	return "CreateProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProjectRequestValidationError{}

var _CreateProjectRequest_DeployType_InLookup = map[uint32]struct{}{
	1: {},
	2: {},
}

// Validate checks the field values on CreateProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateProjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProjectResponseMultiError, or nil if none found.
func (m *CreateProjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateProjectResponseMultiError(errors)
	}

	return nil
}

// CreateProjectResponseMultiError is an error wrapping multiple validation
// errors returned by CreateProjectResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateProjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProjectResponseMultiError) AllErrors() []error { return m }

// CreateProjectResponseValidationError is the validation error returned by
// CreateProjectResponse.Validate if the designated constraints aren't met.
type CreateProjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProjectResponseValidationError) ErrorName() string {
	return "CreateProjectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProjectResponseValidationError{}

// Validate checks the field values on UpdateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProjectRequestMultiError, or nil if none found.
func (m *UpdateProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 32 {
		err := UpdateProjectRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateProjectRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProjectType

	if all {
		switch v := interface{}(m.GetUseBKRes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "UseBKRes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "UseBKRes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseBKRes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProjectRequestValidationError{
				field:  "UseBKRes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetIsOffline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "IsOffline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "IsOffline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsOffline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProjectRequestValidationError{
				field:  "IsOffline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Kind

	// no validation rules for DeployType

	// no validation rules for BgID

	// no validation rules for BgName

	// no validation rules for DeptID

	// no validation rules for DeptName

	// no validation rules for CenterID

	// no validation rules for CenterName

	if all {
		switch v := interface{}(m.GetIsSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "IsSecret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "IsSecret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProjectRequestValidationError{
				field:  "IsSecret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetCredentials()))
		i := 0
		for key := range m.GetCredentials() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCredentials()[key]
			_ = val

			// no validation rules for Credentials[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateProjectRequestValidationError{
							field:  fmt.Sprintf("Credentials[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateProjectRequestValidationError{
							field:  fmt.Sprintf("Credentials[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateProjectRequestValidationError{
						field:  fmt.Sprintf("Credentials[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for BusinessID

	if len(errors) > 0 {
		return UpdateProjectRequestMultiError(errors)
	}

	return nil
}

// UpdateProjectRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProjectRequestMultiError) AllErrors() []error { return m }

// UpdateProjectRequestValidationError is the validation error returned by
// UpdateProjectRequest.Validate if the designated constraints aren't met.
type UpdateProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProjectRequestValidationError) ErrorName() string {
	return "UpdateProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProjectRequestValidationError{}

// Validate checks the field values on UpdateProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProjectResponseMultiError, or nil if none found.
func (m *UpdateProjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProjectResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateProjectResponseMultiError(errors)
	}

	return nil
}

// UpdateProjectResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateProjectResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateProjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProjectResponseMultiError) AllErrors() []error { return m }

// UpdateProjectResponseValidationError is the validation error returned by
// UpdateProjectResponse.Validate if the designated constraints aren't met.
type UpdateProjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProjectResponseValidationError) ErrorName() string {
	return "UpdateProjectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProjectResponseValidationError{}

// Validate checks the field values on DeleteProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteProjectRequestMultiError, or nil if none found.
func (m *DeleteProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for IsForce

	if len(errors) > 0 {
		return DeleteProjectRequestMultiError(errors)
	}

	return nil
}

// DeleteProjectRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteProjectRequestMultiError) AllErrors() []error { return m }

// DeleteProjectRequestValidationError is the validation error returned by
// DeleteProjectRequest.Validate if the designated constraints aren't met.
type DeleteProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteProjectRequestValidationError) ErrorName() string {
	return "DeleteProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteProjectRequestValidationError{}

// Validate checks the field values on DeleteProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteProjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteProjectResponseMultiError, or nil if none found.
func (m *DeleteProjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteProjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteProjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteProjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteProjectResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteProjectResponseMultiError(errors)
	}

	return nil
}

// DeleteProjectResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteProjectResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteProjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteProjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteProjectResponseMultiError) AllErrors() []error { return m }

// DeleteProjectResponseValidationError is the validation error returned by
// DeleteProjectResponse.Validate if the designated constraints aren't met.
type DeleteProjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteProjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteProjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteProjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteProjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteProjectResponseValidationError) ErrorName() string {
	return "DeleteProjectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteProjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteProjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteProjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteProjectResponseValidationError{}

// Validate checks the field values on GetProjectRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectRequestMultiError, or nil if none found.
func (m *GetProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 2 || l > 33 {
		err := GetProjectRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be between 2 and 33 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetProjectRequest_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := GetProjectRequestValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetProjectRequestMultiError(errors)
	}

	return nil
}

// GetProjectRequestMultiError is an error wrapping multiple validation errors
// returned by GetProjectRequest.ValidateAll() if the designated constraints
// aren't met.
type GetProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectRequestMultiError) AllErrors() []error { return m }

// GetProjectRequestValidationError is the validation error returned by
// GetProjectRequest.Validate if the designated constraints aren't met.
type GetProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectRequestValidationError) ErrorName() string {
	return "GetProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectRequestValidationError{}

var _GetProjectRequest_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectResponseMultiError, or nil if none found.
func (m *GetProjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProjectResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetProjectResponseMultiError(errors)
	}

	return nil
}

// GetProjectResponseMultiError is an error wrapping multiple validation errors
// returned by GetProjectResponse.ValidateAll() if the designated constraints
// aren't met.
type GetProjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectResponseMultiError) AllErrors() []error { return m }

// GetProjectResponseValidationError is the validation error returned by
// GetProjectResponse.Validate if the designated constraints aren't met.
type GetProjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectResponseValidationError) ErrorName() string {
	return "GetProjectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectResponseValidationError{}

// Validate checks the field values on ListProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectRequestMultiError, or nil if none found.
func (m *ListProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for EnglishName

	// no validation rules for ProjectType

	// no validation rules for UseBKRes

	// no validation rules for IsOffline

	// no validation rules for Kind

	// no validation rules for BusinessID

	// no validation rules for DeployType

	// no validation rules for BgID

	// no validation rules for BgName

	// no validation rules for DeptID

	// no validation rules for DeptName

	// no validation rules for CenterID

	// no validation rules for CenterName

	// no validation rules for IsSecret

	if len(errors) > 0 {
		return ListProjectRequestMultiError(errors)
	}

	return nil
}

// ListProjectRequestMultiError is an error wrapping multiple validation errors
// returned by ListProjectRequest.ValidateAll() if the designated constraints
// aren't met.
type ListProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectRequestMultiError) AllErrors() []error { return m }

// ListProjectRequestValidationError is the validation error returned by
// ListProjectRequest.Validate if the designated constraints aren't met.
type ListProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectRequestValidationError) ErrorName() string {
	return "ListProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectRequestValidationError{}

// Validate checks the field values on ListProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectResponseMultiError, or nil if none found.
func (m *ListProjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListProjectResponseMultiError(errors)
	}

	return nil
}

// ListProjectResponseMultiError is an error wrapping multiple validation
// errors returned by ListProjectResponse.ValidateAll() if the designated
// constraints aren't met.
type ListProjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectResponseMultiError) AllErrors() []error { return m }

// ListProjectResponseValidationError is the validation error returned by
// ListProjectResponse.Validate if the designated constraints aren't met.
type ListProjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectResponseValidationError) ErrorName() string {
	return "ListProjectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectResponseValidationError{}

// Validate checks the field values on CreateCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudRequestMultiError, or nil if none found.
func (m *CreateCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 20 {
		err := CreateCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := CreateCloudRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 64 {
		err := CreateCloudRequestValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Editable

	{
		sorted_keys := make([]string, len(m.GetOpsPlugins()))
		i := 0
		for key := range m.GetOpsPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOpsPlugins()[key]
			_ = val

			// no validation rules for OpsPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateCloudRequestValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateCloudRequestValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateCloudRequestValidationError{
						field:  fmt.Sprintf("OpsPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraPlugins()))
		i := 0
		for key := range m.GetExtraPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraPlugins()[key]
			_ = val

			// no validation rules for ExtraPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateCloudRequestValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateCloudRequestValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateCloudRequestValidationError{
						field:  fmt.Sprintf("ExtraPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetCloudCredential()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudCredential()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "CloudCredential",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOsManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOsManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "OsManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "ClusterManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeGroupManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroupManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "NodeGroupManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateCloudRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudRequest_Creator_Pattern.MatchString(m.GetCreator()) {
		err := CreateCloudRequestValidationError{
			field:  "Creator",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CloudProvider

	// no validation rules for Config

	// no validation rules for Description

	// no validation rules for EngineType

	// no validation rules for Enable

	if all {
		switch v := interface{}(m.GetNetworkInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "NetworkInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "ConfInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlatformInfo

	if len(errors) > 0 {
		return CreateCloudRequestMultiError(errors)
	}

	return nil
}

// CreateCloudRequestMultiError is an error wrapping multiple validation errors
// returned by CreateCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudRequestMultiError) AllErrors() []error { return m }

// CreateCloudRequestValidationError is the validation error returned by
// CreateCloudRequest.Validate if the designated constraints aren't met.
type CreateCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudRequestValidationError) ErrorName() string {
	return "CreateCloudRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudRequestValidationError{}

var _CreateCloudRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudRequest_Creator_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudResponseMultiError, or nil if none found.
func (m *CreateCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateCloudResponseMultiError(errors)
	}

	return nil
}

// CreateCloudResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCloudResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudResponseMultiError) AllErrors() []error { return m }

// CreateCloudResponseValidationError is the validation error returned by
// CreateCloudResponse.Validate if the designated constraints aren't met.
type CreateCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudResponseValidationError) ErrorName() string {
	return "CreateCloudResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudResponseValidationError{}

// Validate checks the field values on UpdateCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudRequestMultiError, or nil if none found.
func (m *UpdateCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 1024 {
		err := UpdateCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) > 1024 {
		err := UpdateCloudRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Editable

	{
		sorted_keys := make([]string, len(m.GetOpsPlugins()))
		i := 0
		for key := range m.GetOpsPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOpsPlugins()[key]
			_ = val

			// no validation rules for OpsPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateCloudRequestValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateCloudRequestValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateCloudRequestValidationError{
						field:  fmt.Sprintf("OpsPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraPlugins()))
		i := 0
		for key := range m.GetExtraPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraPlugins()[key]
			_ = val

			// no validation rules for ExtraPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateCloudRequestValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateCloudRequestValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateCloudRequestValidationError{
						field:  fmt.Sprintf("ExtraPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetCloudCredential()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudCredential()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "CloudCredential",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOsManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOsManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "OsManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "ClusterManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeGroupManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroupManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "NodeGroupManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 1024 {
		err := UpdateCloudRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudRequest_Updater_Pattern.MatchString(m.GetUpdater()) {
		err := UpdateCloudRequestValidationError{
			field:  "Updater",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CloudProvider

	// no validation rules for Config

	// no validation rules for Description

	// no validation rules for EngineType

	// no validation rules for Enable

	if all {
		switch v := interface{}(m.GetNetworkInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "NetworkInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "ConfInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlatformInfo

	if len(errors) > 0 {
		return UpdateCloudRequestMultiError(errors)
	}

	return nil
}

// UpdateCloudRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudRequestMultiError) AllErrors() []error { return m }

// UpdateCloudRequestValidationError is the validation error returned by
// UpdateCloudRequest.Validate if the designated constraints aren't met.
type UpdateCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudRequestValidationError) ErrorName() string {
	return "UpdateCloudRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudRequestValidationError{}

var _UpdateCloudRequest_Updater_Pattern = regexp.MustCompile("^[0-9a-zA-Z]+$")

// Validate checks the field values on UpdateCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudResponseMultiError, or nil if none found.
func (m *UpdateCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCloudResponseMultiError(errors)
	}

	return nil
}

// UpdateCloudResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateCloudResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudResponseMultiError) AllErrors() []error { return m }

// UpdateCloudResponseValidationError is the validation error returned by
// UpdateCloudResponse.Validate if the designated constraints aren't met.
type UpdateCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudResponseValidationError) ErrorName() string {
	return "UpdateCloudResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudResponseValidationError{}

// Validate checks the field values on DeleteCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudRequestMultiError, or nil if none found.
func (m *DeleteCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 20 {
		err := DeleteCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := DeleteCloudRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForce

	if len(errors) > 0 {
		return DeleteCloudRequestMultiError(errors)
	}

	return nil
}

// DeleteCloudRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudRequestMultiError) AllErrors() []error { return m }

// DeleteCloudRequestValidationError is the validation error returned by
// DeleteCloudRequest.Validate if the designated constraints aren't met.
type DeleteCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudRequestValidationError) ErrorName() string {
	return "DeleteCloudRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudRequestValidationError{}

var _DeleteCloudRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudResponseMultiError, or nil if none found.
func (m *DeleteCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteCloudResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteCloudResponseMultiError(errors)
	}

	return nil
}

// DeleteCloudResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCloudResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudResponseMultiError) AllErrors() []error { return m }

// DeleteCloudResponseValidationError is the validation error returned by
// DeleteCloudResponse.Validate if the designated constraints aren't met.
type DeleteCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudResponseValidationError) ErrorName() string {
	return "DeleteCloudResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudResponseValidationError{}

// Validate checks the field values on GetCloudRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRequestMultiError, or nil if none found.
func (m *GetCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 20 {
		err := GetCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetCloudRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := GetCloudRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCloudRequestMultiError(errors)
	}

	return nil
}

// GetCloudRequestMultiError is an error wrapping multiple validation errors
// returned by GetCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type GetCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRequestMultiError) AllErrors() []error { return m }

// GetCloudRequestValidationError is the validation error returned by
// GetCloudRequest.Validate if the designated constraints aren't met.
type GetCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRequestValidationError) ErrorName() string { return "GetCloudRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRequestValidationError{}

var _GetCloudRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetCloudResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudResponseMultiError, or nil if none found.
func (m *GetCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCloudResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCloudResponseMultiError(errors)
	}

	return nil
}

// GetCloudResponseMultiError is an error wrapping multiple validation errors
// returned by GetCloudResponse.ValidateAll() if the designated constraints
// aren't met.
type GetCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudResponseMultiError) AllErrors() []error { return m }

// GetCloudResponseValidationError is the validation error returned by
// GetCloudResponse.Validate if the designated constraints aren't met.
type GetCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudResponseValidationError) ErrorName() string { return "GetCloudResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudResponseValidationError{}

// Validate checks the field values on ListCloudRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudRequestMultiError, or nil if none found.
func (m *ListCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 20 {
		err := ListCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Editable

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CloudProvider

	if len(errors) > 0 {
		return ListCloudRequestMultiError(errors)
	}

	return nil
}

// ListCloudRequestMultiError is an error wrapping multiple validation errors
// returned by ListCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type ListCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRequestMultiError) AllErrors() []error { return m }

// ListCloudRequestValidationError is the validation error returned by
// ListCloudRequest.Validate if the designated constraints aren't met.
type ListCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRequestValidationError) ErrorName() string { return "ListCloudRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRequestValidationError{}

// Validate checks the field values on ListCloudResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudResponseMultiError, or nil if none found.
func (m *ListCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudResponseMultiError(errors)
	}

	return nil
}

// ListCloudResponseMultiError is an error wrapping multiple validation errors
// returned by ListCloudResponse.ValidateAll() if the designated constraints
// aren't met.
type ListCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudResponseMultiError) AllErrors() []error { return m }

// ListCloudResponseValidationError is the validation error returned by
// ListCloudResponse.Validate if the designated constraints aren't met.
type ListCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudResponseValidationError) ErrorName() string {
	return "ListCloudResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudResponseValidationError{}

// Validate checks the field values on CreateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeGroupRequestMultiError, or nil if none found.
func (m *CreateNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := CreateNodeGroupRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := CreateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CreateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateNodeGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CreateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 1 || l > 32 {
		err := CreateNodeGroupRequestValidationError{
			field:  "Region",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateNodeGroupRequest_Region_Pattern.MatchString(m.GetRegion()) {
		err := CreateNodeGroupRequestValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for EnableAutoscale

	if m.GetAutoScaling() == nil {
		err := CreateNodeGroupRequestValidationError{
			field:  "AutoScaling",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAutoScaling()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutoScaling()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupRequestValidationError{
				field:  "AutoScaling",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetLaunchTemplate() == nil {
		err := CreateNodeGroupRequestValidationError{
			field:  "LaunchTemplate",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetLaunchTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLaunchTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupRequestValidationError{
				field:  "LaunchTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	// no validation rules for Taints

	// no validation rules for NodeOS

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateNodeGroupRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateNodeGroupRequest_Creator_Pattern.MatchString(m.GetCreator()) {
		err := CreateNodeGroupRequestValidationError{
			field:  "Creator",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	// no validation rules for ConsumerID

	if m.GetNodeTemplate() == nil {
		err := CreateNodeGroupRequestValidationError{
			field:  "NodeTemplate",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNodeTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupRequestValidationError{
				field:  "NodeTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Tags

	// no validation rules for NodeGroupType

	// no validation rules for BkCloudID

	// no validation rules for CloudAreaName

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupRequestValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NodeRole

	if len(errors) > 0 {
		return CreateNodeGroupRequestMultiError(errors)
	}

	return nil
}

// CreateNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by CreateNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeGroupRequestMultiError) AllErrors() []error { return m }

// CreateNodeGroupRequestValidationError is the validation error returned by
// CreateNodeGroupRequest.Validate if the designated constraints aren't met.
type CreateNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeGroupRequestValidationError) ErrorName() string {
	return "CreateNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeGroupRequestValidationError{}

var _CreateNodeGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateNodeGroupRequest_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateNodeGroupRequest_Creator_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GroupExtraInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GroupExtraInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupExtraInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GroupExtraInfoMultiError,
// or nil if none found.
func (m *GroupExtraInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupExtraInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	// no validation rules for PoolID

	if len(errors) > 0 {
		return GroupExtraInfoMultiError(errors)
	}

	return nil
}

// GroupExtraInfoMultiError is an error wrapping multiple validation errors
// returned by GroupExtraInfo.ValidateAll() if the designated constraints
// aren't met.
type GroupExtraInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupExtraInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupExtraInfoMultiError) AllErrors() []error { return m }

// GroupExtraInfoValidationError is the validation error returned by
// GroupExtraInfo.Validate if the designated constraints aren't met.
type GroupExtraInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupExtraInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupExtraInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupExtraInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupExtraInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupExtraInfoValidationError) ErrorName() string { return "GroupExtraInfoValidationError" }

// Error satisfies the builtin error interface
func (e GroupExtraInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupExtraInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupExtraInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupExtraInfoValidationError{}

// Validate checks the field values on CreateNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeGroupResponseMultiError, or nil if none found.
func (m *CreateNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNodeGroupResponseMultiError(errors)
	}

	return nil
}

// CreateNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by CreateNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeGroupResponseMultiError) AllErrors() []error { return m }

// CreateNodeGroupResponseValidationError is the validation error returned by
// CreateNodeGroupResponse.Validate if the designated constraints aren't met.
type CreateNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeGroupResponseValidationError) ErrorName() string {
	return "CreateNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeGroupResponseValidationError{}

// Validate checks the field values on CreateNodeGroupResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeGroupResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeGroupResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeGroupResponseDataMultiError, or nil if none found.
func (m *CreateNodeGroupResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeGroupResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupResponseDataValidationError{
					field:  "NodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupResponseDataValidationError{
					field:  "NodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupResponseDataValidationError{
				field:  "NodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupResponseDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupResponseDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupResponseDataValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNodeGroupResponseDataMultiError(errors)
	}

	return nil
}

// CreateNodeGroupResponseDataMultiError is an error wrapping multiple
// validation errors returned by CreateNodeGroupResponseData.ValidateAll() if
// the designated constraints aren't met.
type CreateNodeGroupResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeGroupResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeGroupResponseDataMultiError) AllErrors() []error { return m }

// CreateNodeGroupResponseDataValidationError is the validation error returned
// by CreateNodeGroupResponseData.Validate if the designated constraints
// aren't met.
type CreateNodeGroupResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeGroupResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeGroupResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeGroupResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeGroupResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeGroupResponseDataValidationError) ErrorName() string {
	return "CreateNodeGroupResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeGroupResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeGroupResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeGroupResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeGroupResponseDataValidationError{}

// Validate checks the field values on UpdateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeGroupRequestMultiError, or nil if none found.
func (m *UpdateNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetNodeGroupID()) > 20 {
		err := UpdateNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := UpdateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := UpdateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateNodeGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := UpdateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 64 {
		err := UpdateNodeGroupRequestValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	if all {
		switch v := interface{}(m.GetEnableAutoscale()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "EnableAutoscale",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "EnableAutoscale",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnableAutoscale()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "EnableAutoscale",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAutoScaling() == nil {
		err := UpdateNodeGroupRequestValidationError{
			field:  "AutoScaling",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAutoScaling()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutoScaling()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "AutoScaling",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetLaunchTemplate() == nil {
		err := UpdateNodeGroupRequestValidationError{
			field:  "LaunchTemplate",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetLaunchTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLaunchTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "LaunchTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetNodeTemplate() == nil {
		err := UpdateNodeGroupRequestValidationError{
			field:  "NodeTemplate",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNodeTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "NodeTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	// no validation rules for Taints

	// no validation rules for Tags

	// no validation rules for NodeOS

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateNodeGroupRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateNodeGroupRequest_Updater_Pattern.MatchString(m.GetUpdater()) {
		err := UpdateNodeGroupRequestValidationError{
			field:  "Updater",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	// no validation rules for ConsumerID

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetBkCloudID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "BkCloudID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "BkCloudID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBkCloudID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "BkCloudID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCloudAreaName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "CloudAreaName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "CloudAreaName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudAreaName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "CloudAreaName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeGroupRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeGroupRequestMultiError) AllErrors() []error { return m }

// UpdateNodeGroupRequestValidationError is the validation error returned by
// UpdateNodeGroupRequest.Validate if the designated constraints aren't met.
type UpdateNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeGroupRequestValidationError) ErrorName() string {
	return "UpdateNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeGroupRequestValidationError{}

var _UpdateNodeGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateNodeGroupRequest_Updater_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeGroupResponseMultiError, or nil if none found.
func (m *UpdateNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeGroupResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeGroupResponseMultiError) AllErrors() []error { return m }

// UpdateNodeGroupResponseValidationError is the validation error returned by
// UpdateNodeGroupResponse.Validate if the designated constraints aren't met.
type UpdateNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeGroupResponseValidationError) ErrorName() string {
	return "UpdateNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeGroupResponseValidationError{}

// Validate checks the field values on DeleteNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodeGroupRequestMultiError, or nil if none found.
func (m *DeleteNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := DeleteNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteNodeGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := DeleteNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForce

	// no validation rules for ReserveNodesInCluster

	// no validation rules for KeepNodesInstance

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 100 {
		err := DeleteNodeGroupRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteNodeGroupRequestMultiError(errors)
	}

	return nil
}

// DeleteNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeGroupRequestMultiError) AllErrors() []error { return m }

// DeleteNodeGroupRequestValidationError is the validation error returned by
// DeleteNodeGroupRequest.Validate if the designated constraints aren't met.
type DeleteNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeGroupRequestValidationError) ErrorName() string {
	return "DeleteNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeGroupRequestValidationError{}

var _DeleteNodeGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodeGroupResponseMultiError, or nil if none found.
func (m *DeleteNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodeGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNodeGroupResponseMultiError(errors)
	}

	return nil
}

// DeleteNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeGroupResponseMultiError) AllErrors() []error { return m }

// DeleteNodeGroupResponseValidationError is the validation error returned by
// DeleteNodeGroupResponse.Validate if the designated constraints aren't met.
type DeleteNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeGroupResponseValidationError) ErrorName() string {
	return "DeleteNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeGroupResponseValidationError{}

// Validate checks the field values on DeleteNodeGroupResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeGroupResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeGroupResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodeGroupResponseDataMultiError, or nil if none found.
func (m *DeleteNodeGroupResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeGroupResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseDataValidationError{
					field:  "NodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseDataValidationError{
					field:  "NodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodeGroupResponseDataValidationError{
				field:  "NodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodeGroupResponseDataValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNodeGroupResponseDataMultiError(errors)
	}

	return nil
}

// DeleteNodeGroupResponseDataMultiError is an error wrapping multiple
// validation errors returned by DeleteNodeGroupResponseData.ValidateAll() if
// the designated constraints aren't met.
type DeleteNodeGroupResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeGroupResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeGroupResponseDataMultiError) AllErrors() []error { return m }

// DeleteNodeGroupResponseDataValidationError is the validation error returned
// by DeleteNodeGroupResponseData.Validate if the designated constraints
// aren't met.
type DeleteNodeGroupResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeGroupResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeGroupResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeGroupResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeGroupResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeGroupResponseDataValidationError) ErrorName() string {
	return "DeleteNodeGroupResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeGroupResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeGroupResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeGroupResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeGroupResponseDataValidationError{}

// Validate checks the field values on GetNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeGroupRequestMultiError, or nil if none found.
func (m *GetNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := GetNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetNodeGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := GetNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNodeGroupRequestMultiError(errors)
	}

	return nil
}

// GetNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by GetNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type GetNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeGroupRequestMultiError) AllErrors() []error { return m }

// GetNodeGroupRequestValidationError is the validation error returned by
// GetNodeGroupRequest.Validate if the designated constraints aren't met.
type GetNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeGroupRequestValidationError) ErrorName() string {
	return "GetNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeGroupRequestValidationError{}

var _GetNodeGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeGroupResponseMultiError, or nil if none found.
func (m *GetNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNodeGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNodeGroupResponseMultiError(errors)
	}

	return nil
}

// GetNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by GetNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type GetNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeGroupResponseMultiError) AllErrors() []error { return m }

// GetNodeGroupResponseValidationError is the validation error returned by
// GetNodeGroupResponse.Validate if the designated constraints aren't met.
type GetNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeGroupResponseValidationError) ErrorName() string {
	return "GetNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeGroupResponseValidationError{}

// Validate checks the field values on ListNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodeGroupRequestMultiError, or nil if none found.
func (m *ListNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ClusterID

	// no validation rules for Region

	// no validation rules for ProjectID

	if len(errors) > 0 {
		return ListNodeGroupRequestMultiError(errors)
	}

	return nil
}

// ListNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by ListNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type ListNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodeGroupRequestMultiError) AllErrors() []error { return m }

// ListNodeGroupRequestValidationError is the validation error returned by
// ListNodeGroupRequest.Validate if the designated constraints aren't met.
type ListNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodeGroupRequestValidationError) ErrorName() string {
	return "ListNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodeGroupRequestValidationError{}

// Validate checks the field values on ListNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodeGroupResponseMultiError, or nil if none found.
func (m *ListNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodeGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodeGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodeGroupResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNodeGroupResponseMultiError(errors)
	}

	return nil
}

// ListNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by ListNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type ListNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodeGroupResponseMultiError) AllErrors() []error { return m }

// ListNodeGroupResponseValidationError is the validation error returned by
// ListNodeGroupResponse.Validate if the designated constraints aren't met.
type ListNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodeGroupResponseValidationError) ErrorName() string {
	return "ListNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodeGroupResponseValidationError{}

// Validate checks the field values on AddNodesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNodesRequestMultiError, or nil if none found.
func (m *AddNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := AddNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := AddNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_AddNodesRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := AddNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNodes()) < 1 {
		err := AddNodesRequestValidationError{
			field:  "Nodes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_AddNodesRequest_Nodes_Unique := make(map[string]struct{}, len(m.GetNodes()))

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if _, exists := _AddNodesRequest_Nodes_Unique[item]; exists {
			err := AddNodesRequestValidationError{
				field:  fmt.Sprintf("Nodes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_AddNodesRequest_Nodes_Unique[item] = struct{}{}
		}

		// no validation rules for Nodes[idx]
	}

	// no validation rules for InitLoginPassword

	// no validation rules for NodeGroupID

	// no validation rules for OnlyCreateInfo

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := AddNodesRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_AddNodesRequest_Operator_Pattern.MatchString(m.GetOperator()) {
		err := AddNodesRequestValidationError{
			field:  "Operator",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddNodesRequestMultiError(errors)
	}

	return nil
}

// AddNodesRequestMultiError is an error wrapping multiple validation errors
// returned by AddNodesRequest.ValidateAll() if the designated constraints
// aren't met.
type AddNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNodesRequestMultiError) AllErrors() []error { return m }

// AddNodesRequestValidationError is the validation error returned by
// AddNodesRequest.Validate if the designated constraints aren't met.
type AddNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNodesRequestValidationError) ErrorName() string { return "AddNodesRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNodesRequestValidationError{}

var _AddNodesRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _AddNodesRequest_Operator_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on AddNodesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNodesResponseMultiError, or nil if none found.
func (m *AddNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNodesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNodesResponseMultiError(errors)
	}

	return nil
}

// AddNodesResponseMultiError is an error wrapping multiple validation errors
// returned by AddNodesResponse.ValidateAll() if the designated constraints
// aren't met.
type AddNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNodesResponseMultiError) AllErrors() []error { return m }

// AddNodesResponseValidationError is the validation error returned by
// AddNodesResponse.Validate if the designated constraints aren't met.
type AddNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNodesResponseValidationError) ErrorName() string { return "AddNodesResponseValidationError" }

// Error satisfies the builtin error interface
func (e AddNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNodesResponseValidationError{}

// Validate checks the field values on DeleteNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodesRequestMultiError, or nil if none found.
func (m *DeleteNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := DeleteNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := DeleteNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteNodesRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := DeleteNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNodes()) < 1 {
		err := DeleteNodesRequestValidationError{
			field:  "Nodes",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DeleteMode

	// no validation rules for IsForce

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := DeleteNodesRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteNodesRequest_Operator_Pattern.MatchString(m.GetOperator()) {
		err := DeleteNodesRequestValidationError{
			field:  "Operator",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OnlyDeleteInfo

	if len(errors) > 0 {
		return DeleteNodesRequestMultiError(errors)
	}

	return nil
}

// DeleteNodesRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteNodesRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodesRequestMultiError) AllErrors() []error { return m }

// DeleteNodesRequestValidationError is the validation error returned by
// DeleteNodesRequest.Validate if the designated constraints aren't met.
type DeleteNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodesRequestValidationError) ErrorName() string {
	return "DeleteNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodesRequestValidationError{}

var _DeleteNodesRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _DeleteNodesRequest_Operator_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodesResponseMultiError, or nil if none found.
func (m *DeleteNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNodesResponseMultiError(errors)
	}

	return nil
}

// DeleteNodesResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteNodesResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodesResponseMultiError) AllErrors() []error { return m }

// DeleteNodesResponseValidationError is the validation error returned by
// DeleteNodesResponse.Validate if the designated constraints aren't met.
type DeleteNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodesResponseValidationError) ErrorName() string {
	return "DeleteNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodesResponseValidationError{}

// Validate checks the field values on MoveNodesToGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MoveNodesToGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoveNodesToGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MoveNodesToGroupRequestMultiError, or nil if none found.
func (m *MoveNodesToGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MoveNodesToGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := MoveNodesToGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := MoveNodesToGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_MoveNodesToGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := MoveNodesToGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetNodes()); l < 1 || l > 100 {
		err := MoveNodesToGroupRequestValidationError{
			field:  "Nodes",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_MoveNodesToGroupRequest_Nodes_Unique := make(map[string]struct{}, len(m.GetNodes()))

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if _, exists := _MoveNodesToGroupRequest_Nodes_Unique[item]; exists {
			err := MoveNodesToGroupRequestValidationError{
				field:  fmt.Sprintf("Nodes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_MoveNodesToGroupRequest_Nodes_Unique[item] = struct{}{}
		}

		// no validation rules for Nodes[idx]
	}

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := MoveNodesToGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_MoveNodesToGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := MoveNodesToGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MoveNodesToGroupRequestMultiError(errors)
	}

	return nil
}

// MoveNodesToGroupRequestMultiError is an error wrapping multiple validation
// errors returned by MoveNodesToGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type MoveNodesToGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoveNodesToGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoveNodesToGroupRequestMultiError) AllErrors() []error { return m }

// MoveNodesToGroupRequestValidationError is the validation error returned by
// MoveNodesToGroupRequest.Validate if the designated constraints aren't met.
type MoveNodesToGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoveNodesToGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoveNodesToGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoveNodesToGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoveNodesToGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoveNodesToGroupRequestValidationError) ErrorName() string {
	return "MoveNodesToGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MoveNodesToGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoveNodesToGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoveNodesToGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoveNodesToGroupRequestValidationError{}

var _MoveNodesToGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _MoveNodesToGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on MoveNodesToGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MoveNodesToGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoveNodesToGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MoveNodesToGroupResponseMultiError, or nil if none found.
func (m *MoveNodesToGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MoveNodesToGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MoveNodesToGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MoveNodesToGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MoveNodesToGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MoveNodesToGroupResponseMultiError(errors)
	}

	return nil
}

// MoveNodesToGroupResponseMultiError is an error wrapping multiple validation
// errors returned by MoveNodesToGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type MoveNodesToGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoveNodesToGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoveNodesToGroupResponseMultiError) AllErrors() []error { return m }

// MoveNodesToGroupResponseValidationError is the validation error returned by
// MoveNodesToGroupResponse.Validate if the designated constraints aren't met.
type MoveNodesToGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoveNodesToGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoveNodesToGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoveNodesToGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoveNodesToGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoveNodesToGroupResponseValidationError) ErrorName() string {
	return "MoveNodesToGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MoveNodesToGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoveNodesToGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoveNodesToGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoveNodesToGroupResponseValidationError{}

// Validate checks the field values on RemoveNodesFromGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveNodesFromGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveNodesFromGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveNodesFromGroupRequestMultiError, or nil if none found.
func (m *RemoveNodesFromGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveNodesFromGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RemoveNodesFromGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetNodes()); l < 1 || l > 100 {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "Nodes",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_RemoveNodesFromGroupRequest_Nodes_Unique := make(map[string]struct{}, len(m.GetNodes()))

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if _, exists := _RemoveNodesFromGroupRequest_Nodes_Unique[item]; exists {
			err := RemoveNodesFromGroupRequestValidationError{
				field:  fmt.Sprintf("Nodes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_RemoveNodesFromGroupRequest_Nodes_Unique[item] = struct{}{}
		}

		// no validation rules for Nodes[idx]
	}

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RemoveNodesFromGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RemoveNodesFromGroupRequestMultiError(errors)
	}

	return nil
}

// RemoveNodesFromGroupRequestMultiError is an error wrapping multiple
// validation errors returned by RemoveNodesFromGroupRequest.ValidateAll() if
// the designated constraints aren't met.
type RemoveNodesFromGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveNodesFromGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveNodesFromGroupRequestMultiError) AllErrors() []error { return m }

// RemoveNodesFromGroupRequestValidationError is the validation error returned
// by RemoveNodesFromGroupRequest.Validate if the designated constraints
// aren't met.
type RemoveNodesFromGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveNodesFromGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveNodesFromGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveNodesFromGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveNodesFromGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveNodesFromGroupRequestValidationError) ErrorName() string {
	return "RemoveNodesFromGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveNodesFromGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveNodesFromGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveNodesFromGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveNodesFromGroupRequestValidationError{}

var _RemoveNodesFromGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _RemoveNodesFromGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on RemoveNodesFromGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveNodesFromGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveNodesFromGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveNodesFromGroupResponseMultiError, or nil if none found.
func (m *RemoveNodesFromGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveNodesFromGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RemoveNodesFromGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RemoveNodesFromGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RemoveNodesFromGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RemoveNodesFromGroupResponseMultiError(errors)
	}

	return nil
}

// RemoveNodesFromGroupResponseMultiError is an error wrapping multiple
// validation errors returned by RemoveNodesFromGroupResponse.ValidateAll() if
// the designated constraints aren't met.
type RemoveNodesFromGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveNodesFromGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveNodesFromGroupResponseMultiError) AllErrors() []error { return m }

// RemoveNodesFromGroupResponseValidationError is the validation error returned
// by RemoveNodesFromGroupResponse.Validate if the designated constraints
// aren't met.
type RemoveNodesFromGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveNodesFromGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveNodesFromGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveNodesFromGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveNodesFromGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveNodesFromGroupResponseValidationError) ErrorName() string {
	return "RemoveNodesFromGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveNodesFromGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveNodesFromGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveNodesFromGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveNodesFromGroupResponseValidationError{}

// Validate checks the field values on CleanNodesInGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanNodesInGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanNodesInGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanNodesInGroupRequestMultiError, or nil if none found.
func (m *CleanNodesInGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanNodesInGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := CleanNodesInGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CleanNodesInGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CleanNodesInGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetNodes()); l < 1 || l > 100 {
		err := CleanNodesInGroupRequestValidationError{
			field:  "Nodes",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CleanNodesInGroupRequest_Nodes_Unique := make(map[string]struct{}, len(m.GetNodes()))

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if _, exists := _CleanNodesInGroupRequest_Nodes_Unique[item]; exists {
			err := CleanNodesInGroupRequestValidationError{
				field:  fmt.Sprintf("Nodes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CleanNodesInGroupRequest_Nodes_Unique[item] = struct{}{}
		}

		// no validation rules for Nodes[idx]
	}

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := CleanNodesInGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := CleanNodesInGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := CleanNodesInGroupRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupRequest_Operator_Pattern.MatchString(m.GetOperator()) {
		err := CleanNodesInGroupRequestValidationError{
			field:  "Operator",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CleanNodesInGroupRequestMultiError(errors)
	}

	return nil
}

// CleanNodesInGroupRequestMultiError is an error wrapping multiple validation
// errors returned by CleanNodesInGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type CleanNodesInGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanNodesInGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanNodesInGroupRequestMultiError) AllErrors() []error { return m }

// CleanNodesInGroupRequestValidationError is the validation error returned by
// CleanNodesInGroupRequest.Validate if the designated constraints aren't met.
type CleanNodesInGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanNodesInGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanNodesInGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanNodesInGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanNodesInGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanNodesInGroupRequestValidationError) ErrorName() string {
	return "CleanNodesInGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CleanNodesInGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanNodesInGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanNodesInGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanNodesInGroupRequestValidationError{}

var _CleanNodesInGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CleanNodesInGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CleanNodesInGroupRequest_Operator_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CleanNodesInGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanNodesInGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanNodesInGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanNodesInGroupResponseMultiError, or nil if none found.
func (m *CleanNodesInGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanNodesInGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CleanNodesInGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CleanNodesInGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CleanNodesInGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CleanNodesInGroupResponseMultiError(errors)
	}

	return nil
}

// CleanNodesInGroupResponseMultiError is an error wrapping multiple validation
// errors returned by CleanNodesInGroupResponse.ValidateAll() if the
// designated constraints aren't met.
type CleanNodesInGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanNodesInGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanNodesInGroupResponseMultiError) AllErrors() []error { return m }

// CleanNodesInGroupResponseValidationError is the validation error returned by
// CleanNodesInGroupResponse.Validate if the designated constraints aren't met.
type CleanNodesInGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanNodesInGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanNodesInGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanNodesInGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanNodesInGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanNodesInGroupResponseValidationError) ErrorName() string {
	return "CleanNodesInGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CleanNodesInGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanNodesInGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanNodesInGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanNodesInGroupResponseValidationError{}

// Validate checks the field values on CleanNodesInGroupV2Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanNodesInGroupV2Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanNodesInGroupV2Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanNodesInGroupV2RequestMultiError, or nil if none found.
func (m *CleanNodesInGroupV2Request) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanNodesInGroupV2Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupV2Request_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNodes()) < 1 {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "Nodes",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupV2Request_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupV2Request_Operator_Pattern.MatchString(m.GetOperator()) {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "Operator",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CleanNodesInGroupV2RequestMultiError(errors)
	}

	return nil
}

// CleanNodesInGroupV2RequestMultiError is an error wrapping multiple
// validation errors returned by CleanNodesInGroupV2Request.ValidateAll() if
// the designated constraints aren't met.
type CleanNodesInGroupV2RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanNodesInGroupV2RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanNodesInGroupV2RequestMultiError) AllErrors() []error { return m }

// CleanNodesInGroupV2RequestValidationError is the validation error returned
// by CleanNodesInGroupV2Request.Validate if the designated constraints aren't met.
type CleanNodesInGroupV2RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanNodesInGroupV2RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanNodesInGroupV2RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanNodesInGroupV2RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanNodesInGroupV2RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanNodesInGroupV2RequestValidationError) ErrorName() string {
	return "CleanNodesInGroupV2RequestValidationError"
}

// Error satisfies the builtin error interface
func (e CleanNodesInGroupV2RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanNodesInGroupV2Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanNodesInGroupV2RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanNodesInGroupV2RequestValidationError{}

var _CleanNodesInGroupV2Request_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CleanNodesInGroupV2Request_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CleanNodesInGroupV2Request_Operator_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CleanNodesInGroupV2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanNodesInGroupV2Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanNodesInGroupV2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanNodesInGroupV2ResponseMultiError, or nil if none found.
func (m *CleanNodesInGroupV2Response) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanNodesInGroupV2Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CleanNodesInGroupV2ResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CleanNodesInGroupV2ResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CleanNodesInGroupV2ResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CleanNodesInGroupV2ResponseMultiError(errors)
	}

	return nil
}

// CleanNodesInGroupV2ResponseMultiError is an error wrapping multiple
// validation errors returned by CleanNodesInGroupV2Response.ValidateAll() if
// the designated constraints aren't met.
type CleanNodesInGroupV2ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanNodesInGroupV2ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanNodesInGroupV2ResponseMultiError) AllErrors() []error { return m }

// CleanNodesInGroupV2ResponseValidationError is the validation error returned
// by CleanNodesInGroupV2Response.Validate if the designated constraints
// aren't met.
type CleanNodesInGroupV2ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanNodesInGroupV2ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanNodesInGroupV2ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanNodesInGroupV2ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanNodesInGroupV2ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanNodesInGroupV2ResponseValidationError) ErrorName() string {
	return "CleanNodesInGroupV2ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CleanNodesInGroupV2ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanNodesInGroupV2Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanNodesInGroupV2ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanNodesInGroupV2ResponseValidationError{}

// Validate checks the field values on ListNodesInGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInGroupRequestMultiError, or nil if none found.
func (m *ListNodesInGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := ListNodesInGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListNodesInGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := ListNodesInGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Output

	if len(errors) > 0 {
		return ListNodesInGroupRequestMultiError(errors)
	}

	return nil
}

// ListNodesInGroupRequestMultiError is an error wrapping multiple validation
// errors returned by ListNodesInGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type ListNodesInGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInGroupRequestMultiError) AllErrors() []error { return m }

// ListNodesInGroupRequestValidationError is the validation error returned by
// ListNodesInGroupRequest.Validate if the designated constraints aren't met.
type ListNodesInGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInGroupRequestValidationError) ErrorName() string {
	return "ListNodesInGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInGroupRequestValidationError{}

var _ListNodesInGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ListNodesInGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInGroupResponseMultiError, or nil if none found.
func (m *ListNodesInGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodesInGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodesInGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodesInGroupResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNodesInGroupResponseMultiError(errors)
	}

	return nil
}

// ListNodesInGroupResponseMultiError is an error wrapping multiple validation
// errors returned by ListNodesInGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type ListNodesInGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInGroupResponseMultiError) AllErrors() []error { return m }

// ListNodesInGroupResponseValidationError is the validation error returned by
// ListNodesInGroupResponse.Validate if the designated constraints aren't met.
type ListNodesInGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInGroupResponseValidationError) ErrorName() string {
	return "ListNodesInGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInGroupResponseValidationError{}

// Validate checks the field values on NodeGroupNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroupNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupNodeMultiError, or
// nil if none found.
func (m *NodeGroupNode) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeID

	// no validation rules for InnerIP

	// no validation rules for InstanceType

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for Status

	// no validation rules for ZoneID

	// no validation rules for NodeGroupID

	// no validation rules for ClusterID

	// no validation rules for VPC

	// no validation rules for Region

	// no validation rules for Passwd

	// no validation rules for Zone

	// no validation rules for DeviceID

	// no validation rules for InstanceRole

	// no validation rules for UnSchedulable

	if len(errors) > 0 {
		return NodeGroupNodeMultiError(errors)
	}

	return nil
}

// NodeGroupNodeMultiError is an error wrapping multiple validation errors
// returned by NodeGroupNode.ValidateAll() if the designated constraints
// aren't met.
type NodeGroupNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupNodeMultiError) AllErrors() []error { return m }

// NodeGroupNodeValidationError is the validation error returned by
// NodeGroupNode.Validate if the designated constraints aren't met.
type NodeGroupNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupNodeValidationError) ErrorName() string { return "NodeGroupNodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupNodeValidationError{}

// Validate checks the field values on UpdateGroupDesiredSizeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupDesiredSizeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupDesiredSizeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupDesiredSizeRequestMultiError, or nil if none found.
func (m *UpdateGroupDesiredSizeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupDesiredSizeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := UpdateGroupDesiredSizeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateGroupDesiredSizeRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := UpdateGroupDesiredSizeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DesiredSize

	if utf8.RuneCountInString(m.GetOperator()) > 100 {
		err := UpdateGroupDesiredSizeRequestValidationError{
			field:  "Operator",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateGroupDesiredSizeRequestMultiError(errors)
	}

	return nil
}

// UpdateGroupDesiredSizeRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupDesiredSizeRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupDesiredSizeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupDesiredSizeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupDesiredSizeRequestMultiError) AllErrors() []error { return m }

// UpdateGroupDesiredSizeRequestValidationError is the validation error
// returned by UpdateGroupDesiredSizeRequest.Validate if the designated
// constraints aren't met.
type UpdateGroupDesiredSizeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupDesiredSizeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupDesiredSizeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupDesiredSizeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupDesiredSizeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupDesiredSizeRequestValidationError) ErrorName() string {
	return "UpdateGroupDesiredSizeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupDesiredSizeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupDesiredSizeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupDesiredSizeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupDesiredSizeRequestValidationError{}

var _UpdateGroupDesiredSizeRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateGroupDesiredSizeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupDesiredSizeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupDesiredSizeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupDesiredSizeResponseMultiError, or nil if none found.
func (m *UpdateGroupDesiredSizeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupDesiredSizeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateGroupDesiredSizeResponseMultiError(errors)
	}

	return nil
}

// UpdateGroupDesiredSizeResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupDesiredSizeResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupDesiredSizeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupDesiredSizeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupDesiredSizeResponseMultiError) AllErrors() []error { return m }

// UpdateGroupDesiredSizeResponseValidationError is the validation error
// returned by UpdateGroupDesiredSizeResponse.Validate if the designated
// constraints aren't met.
type UpdateGroupDesiredSizeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupDesiredSizeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupDesiredSizeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupDesiredSizeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupDesiredSizeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupDesiredSizeResponseValidationError) ErrorName() string {
	return "UpdateGroupDesiredSizeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupDesiredSizeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupDesiredSizeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupDesiredSizeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupDesiredSizeResponseValidationError{}

// Validate checks the field values on UpdateGroupDesiredNodeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupDesiredNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupDesiredNodeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupDesiredNodeRequestMultiError, or nil if none found.
func (m *UpdateGroupDesiredNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupDesiredNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := UpdateGroupDesiredNodeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateGroupDesiredNodeRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := UpdateGroupDesiredNodeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DesiredNode

	if utf8.RuneCountInString(m.GetOperator()) > 100 {
		err := UpdateGroupDesiredNodeRequestValidationError{
			field:  "Operator",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateGroupDesiredNodeRequestMultiError(errors)
	}

	return nil
}

// UpdateGroupDesiredNodeRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupDesiredNodeRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupDesiredNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupDesiredNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupDesiredNodeRequestMultiError) AllErrors() []error { return m }

// UpdateGroupDesiredNodeRequestValidationError is the validation error
// returned by UpdateGroupDesiredNodeRequest.Validate if the designated
// constraints aren't met.
type UpdateGroupDesiredNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupDesiredNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupDesiredNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupDesiredNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupDesiredNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupDesiredNodeRequestValidationError) ErrorName() string {
	return "UpdateGroupDesiredNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupDesiredNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupDesiredNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupDesiredNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupDesiredNodeRequestValidationError{}

var _UpdateGroupDesiredNodeRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateGroupDesiredNodeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupDesiredNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupDesiredNodeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupDesiredNodeResponseMultiError, or nil if none found.
func (m *UpdateGroupDesiredNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupDesiredNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateGroupDesiredNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateGroupDesiredNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateGroupDesiredNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateGroupDesiredNodeResponseMultiError(errors)
	}

	return nil
}

// UpdateGroupDesiredNodeResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupDesiredNodeResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupDesiredNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupDesiredNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupDesiredNodeResponseMultiError) AllErrors() []error { return m }

// UpdateGroupDesiredNodeResponseValidationError is the validation error
// returned by UpdateGroupDesiredNodeResponse.Validate if the designated
// constraints aren't met.
type UpdateGroupDesiredNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupDesiredNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupDesiredNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupDesiredNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupDesiredNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupDesiredNodeResponseValidationError) ErrorName() string {
	return "UpdateGroupDesiredNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupDesiredNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupDesiredNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupDesiredNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupDesiredNodeResponseValidationError{}

// Validate checks the field values on EnableNodeGroupAutoScaleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnableNodeGroupAutoScaleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableNodeGroupAutoScaleRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EnableNodeGroupAutoScaleRequestMultiError, or nil if none found.
func (m *EnableNodeGroupAutoScaleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableNodeGroupAutoScaleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := EnableNodeGroupAutoScaleRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EnableNodeGroupAutoScaleRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := EnableNodeGroupAutoScaleRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EnableNodeGroupAutoScaleRequestMultiError(errors)
	}

	return nil
}

// EnableNodeGroupAutoScaleRequestMultiError is an error wrapping multiple
// validation errors returned by EnableNodeGroupAutoScaleRequest.ValidateAll()
// if the designated constraints aren't met.
type EnableNodeGroupAutoScaleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableNodeGroupAutoScaleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableNodeGroupAutoScaleRequestMultiError) AllErrors() []error { return m }

// EnableNodeGroupAutoScaleRequestValidationError is the validation error
// returned by EnableNodeGroupAutoScaleRequest.Validate if the designated
// constraints aren't met.
type EnableNodeGroupAutoScaleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableNodeGroupAutoScaleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableNodeGroupAutoScaleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableNodeGroupAutoScaleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableNodeGroupAutoScaleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableNodeGroupAutoScaleRequestValidationError) ErrorName() string {
	return "EnableNodeGroupAutoScaleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EnableNodeGroupAutoScaleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableNodeGroupAutoScaleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableNodeGroupAutoScaleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableNodeGroupAutoScaleRequestValidationError{}

var _EnableNodeGroupAutoScaleRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on EnableNodeGroupAutoScaleResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *EnableNodeGroupAutoScaleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableNodeGroupAutoScaleResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EnableNodeGroupAutoScaleResponseMultiError, or nil if none found.
func (m *EnableNodeGroupAutoScaleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableNodeGroupAutoScaleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return EnableNodeGroupAutoScaleResponseMultiError(errors)
	}

	return nil
}

// EnableNodeGroupAutoScaleResponseMultiError is an error wrapping multiple
// validation errors returned by
// EnableNodeGroupAutoScaleResponse.ValidateAll() if the designated
// constraints aren't met.
type EnableNodeGroupAutoScaleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableNodeGroupAutoScaleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableNodeGroupAutoScaleResponseMultiError) AllErrors() []error { return m }

// EnableNodeGroupAutoScaleResponseValidationError is the validation error
// returned by EnableNodeGroupAutoScaleResponse.Validate if the designated
// constraints aren't met.
type EnableNodeGroupAutoScaleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableNodeGroupAutoScaleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableNodeGroupAutoScaleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableNodeGroupAutoScaleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableNodeGroupAutoScaleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableNodeGroupAutoScaleResponseValidationError) ErrorName() string {
	return "EnableNodeGroupAutoScaleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EnableNodeGroupAutoScaleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableNodeGroupAutoScaleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableNodeGroupAutoScaleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableNodeGroupAutoScaleResponseValidationError{}

// Validate checks the field values on DisableNodeGroupAutoScaleRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DisableNodeGroupAutoScaleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisableNodeGroupAutoScaleRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DisableNodeGroupAutoScaleRequestMultiError, or nil if none found.
func (m *DisableNodeGroupAutoScaleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DisableNodeGroupAutoScaleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := DisableNodeGroupAutoScaleRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DisableNodeGroupAutoScaleRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := DisableNodeGroupAutoScaleRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DisableNodeGroupAutoScaleRequestMultiError(errors)
	}

	return nil
}

// DisableNodeGroupAutoScaleRequestMultiError is an error wrapping multiple
// validation errors returned by
// DisableNodeGroupAutoScaleRequest.ValidateAll() if the designated
// constraints aren't met.
type DisableNodeGroupAutoScaleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisableNodeGroupAutoScaleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisableNodeGroupAutoScaleRequestMultiError) AllErrors() []error { return m }

// DisableNodeGroupAutoScaleRequestValidationError is the validation error
// returned by DisableNodeGroupAutoScaleRequest.Validate if the designated
// constraints aren't met.
type DisableNodeGroupAutoScaleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisableNodeGroupAutoScaleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisableNodeGroupAutoScaleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisableNodeGroupAutoScaleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisableNodeGroupAutoScaleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisableNodeGroupAutoScaleRequestValidationError) ErrorName() string {
	return "DisableNodeGroupAutoScaleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DisableNodeGroupAutoScaleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisableNodeGroupAutoScaleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisableNodeGroupAutoScaleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisableNodeGroupAutoScaleRequestValidationError{}

var _DisableNodeGroupAutoScaleRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DisableNodeGroupAutoScaleResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DisableNodeGroupAutoScaleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisableNodeGroupAutoScaleResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DisableNodeGroupAutoScaleResponseMultiError, or nil if none found.
func (m *DisableNodeGroupAutoScaleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DisableNodeGroupAutoScaleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DisableNodeGroupAutoScaleResponseMultiError(errors)
	}

	return nil
}

// DisableNodeGroupAutoScaleResponseMultiError is an error wrapping multiple
// validation errors returned by
// DisableNodeGroupAutoScaleResponse.ValidateAll() if the designated
// constraints aren't met.
type DisableNodeGroupAutoScaleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisableNodeGroupAutoScaleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisableNodeGroupAutoScaleResponseMultiError) AllErrors() []error { return m }

// DisableNodeGroupAutoScaleResponseValidationError is the validation error
// returned by DisableNodeGroupAutoScaleResponse.Validate if the designated
// constraints aren't met.
type DisableNodeGroupAutoScaleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisableNodeGroupAutoScaleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisableNodeGroupAutoScaleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisableNodeGroupAutoScaleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisableNodeGroupAutoScaleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisableNodeGroupAutoScaleResponseValidationError) ErrorName() string {
	return "DisableNodeGroupAutoScaleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DisableNodeGroupAutoScaleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisableNodeGroupAutoScaleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisableNodeGroupAutoScaleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisableNodeGroupAutoScaleResponseValidationError{}

// Validate checks the field values on CreateTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaskRequestMultiError, or nil if none found.
func (m *CreateTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskType

	if _, ok := _CreateTaskRequest_Status_InLookup[m.GetStatus()]; !ok {
		err := CreateTaskRequestValidationError{
			field:  "Status",
			reason: "value must be in list [INITIALIZING RUNNING SUCCESS FAILED TIMEOUT]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ExecutionTime

	// no validation rules for CurrentStep

	if len(m.GetStepSequence()) < 1 {
		err := CreateTaskRequestValidationError{
			field:  "StepSequence",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetSteps()); l < 1 || l > 20 {
		err := CreateTaskRequestValidationError{
			field:  "Steps",
			reason: "value must contain between 1 and 20 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetSteps()))
		i := 0
		for key := range m.GetSteps() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSteps()[key]
			_ = val

			// no validation rules for Steps[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateTaskRequestValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateTaskRequestValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateTaskRequestValidationError{
						field:  fmt.Sprintf("Steps[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := CreateTaskRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CreateTaskRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateTaskRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CreateTaskRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 2 || l > 32 {
		err := CreateTaskRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be between 2 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateTaskRequest_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := CreateTaskRequestValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateTaskRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for LastUpdate

	if len(errors) > 0 {
		return CreateTaskRequestMultiError(errors)
	}

	return nil
}

// CreateTaskRequestMultiError is an error wrapping multiple validation errors
// returned by CreateTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaskRequestMultiError) AllErrors() []error { return m }

// CreateTaskRequestValidationError is the validation error returned by
// CreateTaskRequest.Validate if the designated constraints aren't met.
type CreateTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaskRequestValidationError) ErrorName() string {
	return "CreateTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaskRequestValidationError{}

var _CreateTaskRequest_Status_InLookup = map[string]struct{}{
	"INITIALIZING": {},
	"RUNNING":      {},
	"SUCCESS":      {},
	"FAILED":       {},
	"TIMEOUT":      {},
}

var _CreateTaskRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateTaskRequest_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaskResponseMultiError, or nil if none found.
func (m *CreateTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTaskResponseMultiError(errors)
	}

	return nil
}

// CreateTaskResponseMultiError is an error wrapping multiple validation errors
// returned by CreateTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaskResponseMultiError) AllErrors() []error { return m }

// CreateTaskResponseValidationError is the validation error returned by
// CreateTaskResponse.Validate if the designated constraints aren't met.
type CreateTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaskResponseValidationError) ErrorName() string {
	return "CreateTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaskResponseValidationError{}

// Validate checks the field values on RetryTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RetryTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryTaskRequestMultiError, or nil if none found.
func (m *RetryTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 1024 {
		err := RetryTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RetryTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := RetryTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 1024 {
		err := RetryTaskRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RetryTaskRequestMultiError(errors)
	}

	return nil
}

// RetryTaskRequestMultiError is an error wrapping multiple validation errors
// returned by RetryTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type RetryTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryTaskRequestMultiError) AllErrors() []error { return m }

// RetryTaskRequestValidationError is the validation error returned by
// RetryTaskRequest.Validate if the designated constraints aren't met.
type RetryTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryTaskRequestValidationError) ErrorName() string { return "RetryTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e RetryTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryTaskRequestValidationError{}

var _RetryTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on RetryTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RetryTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryTaskResponseMultiError, or nil if none found.
func (m *RetryTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RetryTaskResponseMultiError(errors)
	}

	return nil
}

// RetryTaskResponseMultiError is an error wrapping multiple validation errors
// returned by RetryTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type RetryTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryTaskResponseMultiError) AllErrors() []error { return m }

// RetryTaskResponseValidationError is the validation error returned by
// RetryTaskResponse.Validate if the designated constraints aren't met.
type RetryTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryTaskResponseValidationError) ErrorName() string {
	return "RetryTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RetryTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryTaskResponseValidationError{}

// Validate checks the field values on UpdateTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaskRequestMultiError, or nil if none found.
func (m *UpdateTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 36 {
		err := UpdateTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := UpdateTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateTaskRequest_Status_InLookup[m.GetStatus()]; !ok {
		err := UpdateTaskRequestValidationError{
			field:  "Status",
			reason: "value must be in list [INITIALIZING RUNNING SUCCESS FAILED TIMEOUT]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for End

	// no validation rules for ExecutionTime

	// no validation rules for CurrentStep

	if l := len(m.GetSteps()); l < 1 || l > 20 {
		err := UpdateTaskRequestValidationError{
			field:  "Steps",
			reason: "value must contain between 1 and 20 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetSteps()))
		i := 0
		for key := range m.GetSteps() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSteps()[key]
			_ = val

			// no validation rules for Steps[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateTaskRequestValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateTaskRequestValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateTaskRequestValidationError{
						field:  fmt.Sprintf("Steps[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateTaskRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateTaskRequestMultiError(errors)
	}

	return nil
}

// UpdateTaskRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaskRequestMultiError) AllErrors() []error { return m }

// UpdateTaskRequestValidationError is the validation error returned by
// UpdateTaskRequest.Validate if the designated constraints aren't met.
type UpdateTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaskRequestValidationError) ErrorName() string {
	return "UpdateTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaskRequestValidationError{}

var _UpdateTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateTaskRequest_Status_InLookup = map[string]struct{}{
	"INITIALIZING": {},
	"RUNNING":      {},
	"SUCCESS":      {},
	"FAILED":       {},
	"TIMEOUT":      {},
}

// Validate checks the field values on UpdateTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaskResponseMultiError, or nil if none found.
func (m *UpdateTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTaskResponseMultiError(errors)
	}

	return nil
}

// UpdateTaskResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaskResponseMultiError) AllErrors() []error { return m }

// UpdateTaskResponseValidationError is the validation error returned by
// UpdateTaskResponse.Validate if the designated constraints aren't met.
type UpdateTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaskResponseValidationError) ErrorName() string {
	return "UpdateTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaskResponseValidationError{}

// Validate checks the field values on DeleteTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTaskRequestMultiError, or nil if none found.
func (m *DeleteTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 36 {
		err := DeleteTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := DeleteTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForce

	if len(errors) > 0 {
		return DeleteTaskRequestMultiError(errors)
	}

	return nil
}

// DeleteTaskRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskRequestMultiError) AllErrors() []error { return m }

// DeleteTaskRequestValidationError is the validation error returned by
// DeleteTaskRequest.Validate if the designated constraints aren't met.
type DeleteTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskRequestValidationError) ErrorName() string {
	return "DeleteTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskRequestValidationError{}

var _DeleteTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTaskResponseMultiError, or nil if none found.
func (m *DeleteTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteTaskResponseMultiError(errors)
	}

	return nil
}

// DeleteTaskResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskResponseMultiError) AllErrors() []error { return m }

// DeleteTaskResponseValidationError is the validation error returned by
// DeleteTaskResponse.Validate if the designated constraints aren't met.
type DeleteTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskResponseValidationError) ErrorName() string {
	return "DeleteTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskResponseValidationError{}

// Validate checks the field values on GetTaskRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskRequestMultiError,
// or nil if none found.
func (m *GetTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 36 {
		err := GetTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := GetTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTaskRequestMultiError(errors)
	}

	return nil
}

// GetTaskRequestMultiError is an error wrapping multiple validation errors
// returned by GetTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type GetTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskRequestMultiError) AllErrors() []error { return m }

// GetTaskRequestValidationError is the validation error returned by
// GetTaskRequest.Validate if the designated constraints aren't met.
type GetTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskRequestValidationError) ErrorName() string { return "GetTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskRequestValidationError{}

var _GetTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaskResponseMultiError, or nil if none found.
func (m *GetTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTaskResponseMultiError(errors)
	}

	return nil
}

// GetTaskResponseMultiError is an error wrapping multiple validation errors
// returned by GetTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type GetTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskResponseMultiError) AllErrors() []error { return m }

// GetTaskResponseValidationError is the validation error returned by
// GetTaskResponse.Validate if the designated constraints aren't met.
type GetTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskResponseValidationError) ErrorName() string { return "GetTaskResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskResponseValidationError{}

// Validate checks the field values on ListTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTaskRequestMultiError, or nil if none found.
func (m *ListTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := ListTaskRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 32 {
		err := ListTaskRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) > 20 {
		err := ListTaskRequestValidationError{
			field:  "Creator",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUpdater()) > 20 {
		err := ListTaskRequestValidationError{
			field:  "Updater",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TaskType

	// no validation rules for Status

	// no validation rules for NodeIP

	if len(errors) > 0 {
		return ListTaskRequestMultiError(errors)
	}

	return nil
}

// ListTaskRequestMultiError is an error wrapping multiple validation errors
// returned by ListTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type ListTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTaskRequestMultiError) AllErrors() []error { return m }

// ListTaskRequestValidationError is the validation error returned by
// ListTaskRequest.Validate if the designated constraints aren't met.
type ListTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTaskRequestValidationError) ErrorName() string { return "ListTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTaskRequestValidationError{}

// Validate checks the field values on ListTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTaskResponseMultiError, or nil if none found.
func (m *ListTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTaskResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTaskResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTaskResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLatestTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListTaskResponseValidationError{
					field:  "LatestTask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListTaskResponseValidationError{
					field:  "LatestTask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatestTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListTaskResponseValidationError{
				field:  "LatestTask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListTaskResponseMultiError(errors)
	}

	return nil
}

// ListTaskResponseMultiError is an error wrapping multiple validation errors
// returned by ListTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type ListTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTaskResponseMultiError) AllErrors() []error { return m }

// ListTaskResponseValidationError is the validation error returned by
// ListTaskResponse.Validate if the designated constraints aren't met.
type ListTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTaskResponseValidationError) ErrorName() string { return "ListTaskResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTaskResponseValidationError{}

// Validate checks the field values on CreateAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAutoScalingOptionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAutoScalingOptionRequestMultiError, or nil if none found.
func (m *CreateAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsScaleDownEnable

	// no validation rules for Expander

	// no validation rules for MaxEmptyBulkDelete

	// no validation rules for ScaleDownDelay

	// no validation rules for ScaleDownUnneededTime

	// no validation rules for ScaleDownUtilizationThreahold

	// no validation rules for SkipNodesWithLocalStorage

	// no validation rules for SkipNodesWithSystemPods

	// no validation rules for IgnoreDaemonSetsUtilization

	// no validation rules for OkTotalUnreadyCount

	// no validation rules for MaxTotalUnreadyPercentage

	// no validation rules for ScaleDownUnreadyTime

	// no validation rules for UnregisteredNodeRemovalTime

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := CreateAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CreateAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateAutoScalingOptionRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CreateAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateAutoScalingOptionRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	// no validation rules for EnableAutoscale

	// no validation rules for BufferResourceRatio

	// no validation rules for MaxGracefulTerminationSec

	// no validation rules for ScanInterval

	// no validation rules for MaxNodeProvisionTime

	// no validation rules for ScaleUpFromZero

	// no validation rules for ScaleDownDelayAfterAdd

	// no validation rules for ScaleDownDelayAfterDelete

	// no validation rules for ScaleDownDelayAfterFailure

	// no validation rules for ScaleDownGpuUtilizationThreshold

	if len(errors) > 0 {
		return CreateAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// CreateAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by CreateAutoScalingOptionRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// CreateAutoScalingOptionRequestValidationError is the validation error
// returned by CreateAutoScalingOptionRequest.Validate if the designated
// constraints aren't met.
type CreateAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAutoScalingOptionRequestValidationError) ErrorName() string {
	return "CreateAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAutoScalingOptionRequestValidationError{}

var _CreateAutoScalingOptionRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAutoScalingOptionResponseMultiError, or nil if none found.
func (m *CreateAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// CreateAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by CreateAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// CreateAutoScalingOptionResponseValidationError is the validation error
// returned by CreateAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type CreateAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAutoScalingOptionResponseValidationError) ErrorName() string {
	return "CreateAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAutoScalingOptionResponseValidationError{}

// Validate checks the field values on UpdateAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAutoScalingOptionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateAutoScalingOptionRequestMultiError, or nil if none found.
func (m *UpdateAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsScaleDownEnable

	if _, ok := _UpdateAutoScalingOptionRequest_Expander_InLookup[m.GetExpander()]; !ok {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "Expander",
			reason: "value must be in list [random least-waste most-pod priority]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxEmptyBulkDelete(); val < 1 || val > 320000 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "MaxEmptyBulkDelete",
			reason: "value must be inside range [1, 320000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownDelay(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelay",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUnneededTime(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUnneededTime",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUtilizationThreahold(); val < 1 || val > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUtilizationThreahold",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SkipNodesWithLocalStorage

	// no validation rules for SkipNodesWithSystemPods

	// no validation rules for IgnoreDaemonSetsUtilization

	if val := m.GetOkTotalUnreadyCount(); val < 0 || val > 320000 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "OkTotalUnreadyCount",
			reason: "value must be inside range [0, 320000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxTotalUnreadyPercentage(); val < 0 || val > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "MaxTotalUnreadyPercentage",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUnreadyTime(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUnreadyTime",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for UnregisteredNodeRemovalTime

	if utf8.RuneCountInString(m.GetProjectID()) > 32 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	if val := m.GetScaleDownGpuUtilizationThreshold(); val < 1 || val > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownGpuUtilizationThreshold",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetBufferResourceRatio(); val < 1 || val > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "BufferResourceRatio",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxGracefulTerminationSec(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "MaxGracefulTerminationSec",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScanInterval(); val < 5 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScanInterval",
			reason: "value must be inside range [5, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxNodeProvisionTime(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "MaxNodeProvisionTime",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ScaleUpFromZero

	if val := m.GetScaleDownDelayAfterAdd(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelayAfterAdd",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownDelayAfterDelete(); val < 0 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelayAfterDelete",
			reason: "value must be inside range [0, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownDelayAfterFailure(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelayAfterFailure",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// UpdateAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateAutoScalingOptionRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// UpdateAutoScalingOptionRequestValidationError is the validation error
// returned by UpdateAutoScalingOptionRequest.Validate if the designated
// constraints aren't met.
type UpdateAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAutoScalingOptionRequestValidationError) ErrorName() string {
	return "UpdateAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAutoScalingOptionRequestValidationError{}

var _UpdateAutoScalingOptionRequest_Expander_InLookup = map[string]struct{}{
	"random":      {},
	"least-waste": {},
	"most-pod":    {},
	"priority":    {},
}

// Validate checks the field values on UpdateAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateAutoScalingOptionResponseMultiError, or nil if none found.
func (m *UpdateAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// UpdateAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// UpdateAutoScalingOptionResponseValidationError is the validation error
// returned by UpdateAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type UpdateAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAutoScalingOptionResponseValidationError) ErrorName() string {
	return "UpdateAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAutoScalingOptionResponseValidationError{}

// Validate checks the field values on DeleteAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAutoScalingOptionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteAutoScalingOptionRequestMultiError, or nil if none found.
func (m *DeleteAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := DeleteAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := DeleteAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteAutoScalingOptionRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := DeleteAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForce

	if len(errors) > 0 {
		return DeleteAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// DeleteAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteAutoScalingOptionRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// DeleteAutoScalingOptionRequestValidationError is the validation error
// returned by DeleteAutoScalingOptionRequest.Validate if the designated
// constraints aren't met.
type DeleteAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAutoScalingOptionRequestValidationError) ErrorName() string {
	return "DeleteAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAutoScalingOptionRequestValidationError{}

var _DeleteAutoScalingOptionRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteAutoScalingOptionResponseMultiError, or nil if none found.
func (m *DeleteAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// DeleteAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// DeleteAutoScalingOptionResponseValidationError is the validation error
// returned by DeleteAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type DeleteAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAutoScalingOptionResponseValidationError) ErrorName() string {
	return "DeleteAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAutoScalingOptionResponseValidationError{}

// Validate checks the field values on GetAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAutoScalingOptionRequestMultiError, or nil if none found.
func (m *GetAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := GetAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := GetAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetAutoScalingOptionRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := GetAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	if len(errors) > 0 {
		return GetAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// GetAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by GetAutoScalingOptionRequest.ValidateAll() if
// the designated constraints aren't met.
type GetAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// GetAutoScalingOptionRequestValidationError is the validation error returned
// by GetAutoScalingOptionRequest.Validate if the designated constraints
// aren't met.
type GetAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAutoScalingOptionRequestValidationError) ErrorName() string {
	return "GetAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAutoScalingOptionRequestValidationError{}

var _GetAutoScalingOptionRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAutoScalingOptionResponseMultiError, or nil if none found.
func (m *GetAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// GetAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by GetAutoScalingOptionResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// GetAutoScalingOptionResponseValidationError is the validation error returned
// by GetAutoScalingOptionResponse.Validate if the designated constraints
// aren't met.
type GetAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAutoScalingOptionResponseValidationError) ErrorName() string {
	return "GetAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAutoScalingOptionResponseValidationError{}

// Validate checks the field values on ListAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAutoScalingOptionRequestMultiError, or nil if none found.
func (m *ListAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := ListAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 32 {
		err := ListAutoScalingOptionRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) > 20 {
		err := ListAutoScalingOptionRequestValidationError{
			field:  "Creator",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUpdater()) > 20 {
		err := ListAutoScalingOptionRequestValidationError{
			field:  "Updater",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// ListAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by ListAutoScalingOptionRequest.ValidateAll() if
// the designated constraints aren't met.
type ListAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// ListAutoScalingOptionRequestValidationError is the validation error returned
// by ListAutoScalingOptionRequest.Validate if the designated constraints
// aren't met.
type ListAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAutoScalingOptionRequestValidationError) ErrorName() string {
	return "ListAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAutoScalingOptionRequestValidationError{}

// Validate checks the field values on ListAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListAutoScalingOptionResponseMultiError, or nil if none found.
func (m *ListAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAutoScalingOptionResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAutoScalingOptionResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAutoScalingOptionResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// ListAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by ListAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type ListAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// ListAutoScalingOptionResponseValidationError is the validation error
// returned by ListAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type ListAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAutoScalingOptionResponseValidationError) ErrorName() string {
	return "ListAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAutoScalingOptionResponseValidationError{}

// Validate checks the field values on UpdateAutoScalingStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAutoScalingStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAutoScalingStatusRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateAutoScalingStatusRequestMultiError, or nil if none found.
func (m *UpdateAutoScalingStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAutoScalingStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enable

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := UpdateAutoScalingStatusRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateAutoScalingStatusRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	if len(errors) > 0 {
		return UpdateAutoScalingStatusRequestMultiError(errors)
	}

	return nil
}

// UpdateAutoScalingStatusRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateAutoScalingStatusRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateAutoScalingStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAutoScalingStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAutoScalingStatusRequestMultiError) AllErrors() []error { return m }

// UpdateAutoScalingStatusRequestValidationError is the validation error
// returned by UpdateAutoScalingStatusRequest.Validate if the designated
// constraints aren't met.
type UpdateAutoScalingStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAutoScalingStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAutoScalingStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAutoScalingStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAutoScalingStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAutoScalingStatusRequestValidationError) ErrorName() string {
	return "UpdateAutoScalingStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAutoScalingStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAutoScalingStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAutoScalingStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAutoScalingStatusRequestValidationError{}

// Validate checks the field values on UpdateAutoScalingStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAutoScalingStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAutoScalingStatusResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateAutoScalingStatusResponseMultiError, or nil if none found.
func (m *UpdateAutoScalingStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAutoScalingStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateAutoScalingStatusResponseMultiError(errors)
	}

	return nil
}

// UpdateAutoScalingStatusResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateAutoScalingStatusResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateAutoScalingStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAutoScalingStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAutoScalingStatusResponseMultiError) AllErrors() []error { return m }

// UpdateAutoScalingStatusResponseValidationError is the validation error
// returned by UpdateAutoScalingStatusResponse.Validate if the designated
// constraints aren't met.
type UpdateAutoScalingStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAutoScalingStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAutoScalingStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAutoScalingStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAutoScalingStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAutoScalingStatusResponseValidationError) ErrorName() string {
	return "UpdateAutoScalingStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAutoScalingStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAutoScalingStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAutoScalingStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAutoScalingStatusResponseValidationError{}

// Validate checks the field values on RegionInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegionInfoMultiError, or
// nil if none found.
func (m *RegionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for RegionName

	// no validation rules for RegionState

	if len(errors) > 0 {
		return RegionInfoMultiError(errors)
	}

	return nil
}

// RegionInfoMultiError is an error wrapping multiple validation errors
// returned by RegionInfo.ValidateAll() if the designated constraints aren't met.
type RegionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionInfoMultiError) AllErrors() []error { return m }

// RegionInfoValidationError is the validation error returned by
// RegionInfo.Validate if the designated constraints aren't met.
type RegionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionInfoValidationError) ErrorName() string { return "RegionInfoValidationError" }

// Error satisfies the builtin error interface
func (e RegionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionInfoValidationError{}

// Validate checks the field values on GetCloudRegionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRegionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRegionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRegionsRequestMultiError, or nil if none found.
func (m *GetCloudRegionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRegionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := GetCloudRegionsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountID()) < 2 {
		err := GetCloudRegionsRequestValidationError{
			field:  "AccountID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCloudRegionsRequestMultiError(errors)
	}

	return nil
}

// GetCloudRegionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetCloudRegionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCloudRegionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRegionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRegionsRequestMultiError) AllErrors() []error { return m }

// GetCloudRegionsRequestValidationError is the validation error returned by
// GetCloudRegionsRequest.Validate if the designated constraints aren't met.
type GetCloudRegionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRegionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRegionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRegionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRegionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRegionsRequestValidationError) ErrorName() string {
	return "GetCloudRegionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudRegionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRegionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRegionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRegionsRequestValidationError{}

// Validate checks the field values on GetCloudRegionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRegionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRegionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRegionsResponseMultiError, or nil if none found.
func (m *GetCloudRegionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRegionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCloudRegionsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCloudRegionsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCloudRegionsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCloudRegionsResponseMultiError(errors)
	}

	return nil
}

// GetCloudRegionsResponseMultiError is an error wrapping multiple validation
// errors returned by GetCloudRegionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCloudRegionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRegionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRegionsResponseMultiError) AllErrors() []error { return m }

// GetCloudRegionsResponseValidationError is the validation error returned by
// GetCloudRegionsResponse.Validate if the designated constraints aren't met.
type GetCloudRegionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRegionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRegionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRegionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRegionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRegionsResponseValidationError) ErrorName() string {
	return "GetCloudRegionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudRegionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRegionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRegionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRegionsResponseValidationError{}

// Validate checks the field values on ZoneInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ZoneInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ZoneInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ZoneInfoMultiError, or nil
// if none found.
func (m *ZoneInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ZoneInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ZoneID

	// no validation rules for Zone

	// no validation rules for ZoneName

	// no validation rules for ZoneState

	if len(errors) > 0 {
		return ZoneInfoMultiError(errors)
	}

	return nil
}

// ZoneInfoMultiError is an error wrapping multiple validation errors returned
// by ZoneInfo.ValidateAll() if the designated constraints aren't met.
type ZoneInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZoneInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZoneInfoMultiError) AllErrors() []error { return m }

// ZoneInfoValidationError is the validation error returned by
// ZoneInfo.Validate if the designated constraints aren't met.
type ZoneInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZoneInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZoneInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZoneInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZoneInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZoneInfoValidationError) ErrorName() string { return "ZoneInfoValidationError" }

// Error satisfies the builtin error interface
func (e ZoneInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZoneInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZoneInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZoneInfoValidationError{}

// Validate checks the field values on CloudClusterInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudClusterInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudClusterInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudClusterInfoMultiError, or nil if none found.
func (m *CloudClusterInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudClusterInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	// no validation rules for ClusterName

	// no validation rules for ClusterDescription

	// no validation rules for ClusterVersion

	// no validation rules for ClusterOS

	// no validation rules for ClusterType

	// no validation rules for ClusterStatus

	if len(errors) > 0 {
		return CloudClusterInfoMultiError(errors)
	}

	return nil
}

// CloudClusterInfoMultiError is an error wrapping multiple validation errors
// returned by CloudClusterInfo.ValidateAll() if the designated constraints
// aren't met.
type CloudClusterInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudClusterInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudClusterInfoMultiError) AllErrors() []error { return m }

// CloudClusterInfoValidationError is the validation error returned by
// CloudClusterInfo.Validate if the designated constraints aren't met.
type CloudClusterInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudClusterInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudClusterInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudClusterInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudClusterInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudClusterInfoValidationError) ErrorName() string { return "CloudClusterInfoValidationError" }

// Error satisfies the builtin error interface
func (e CloudClusterInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudClusterInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudClusterInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudClusterInfoValidationError{}

// Validate checks the field values on ListCloudRegionClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRegionClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRegionClusterRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudRegionClusterRequestMultiError, or nil if none found.
func (m *ListCloudRegionClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRegionClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudRegionClusterRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) < 2 {
		err := ListCloudRegionClusterRequestValidationError{
			field:  "Region",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountID()) < 2 {
		err := ListCloudRegionClusterRequestValidationError{
			field:  "AccountID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCloudRegionClusterRequestMultiError(errors)
	}

	return nil
}

// ListCloudRegionClusterRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudRegionClusterRequest.ValidateAll()
// if the designated constraints aren't met.
type ListCloudRegionClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRegionClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRegionClusterRequestMultiError) AllErrors() []error { return m }

// ListCloudRegionClusterRequestValidationError is the validation error
// returned by ListCloudRegionClusterRequest.Validate if the designated
// constraints aren't met.
type ListCloudRegionClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRegionClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRegionClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRegionClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRegionClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRegionClusterRequestValidationError) ErrorName() string {
	return "ListCloudRegionClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRegionClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRegionClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRegionClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRegionClusterRequestValidationError{}

// Validate checks the field values on ListCloudRegionClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRegionClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRegionClusterResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudRegionClusterResponseMultiError, or nil if none found.
func (m *ListCloudRegionClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRegionClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudRegionClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudRegionClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudRegionClusterResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudRegionClusterResponseMultiError(errors)
	}

	return nil
}

// ListCloudRegionClusterResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudRegionClusterResponse.ValidateAll()
// if the designated constraints aren't met.
type ListCloudRegionClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRegionClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRegionClusterResponseMultiError) AllErrors() []error { return m }

// ListCloudRegionClusterResponseValidationError is the validation error
// returned by ListCloudRegionClusterResponse.Validate if the designated
// constraints aren't met.
type ListCloudRegionClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRegionClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRegionClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRegionClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRegionClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRegionClusterResponseValidationError) ErrorName() string {
	return "ListCloudRegionClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRegionClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRegionClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRegionClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRegionClusterResponseValidationError{}

// Validate checks the field values on GetCloudRegionZonesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRegionZonesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRegionZonesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRegionZonesRequestMultiError, or nil if none found.
func (m *GetCloudRegionZonesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRegionZonesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := GetCloudRegionZonesRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	if utf8.RuneCountInString(m.GetAccountID()) < 2 {
		err := GetCloudRegionZonesRequestValidationError{
			field:  "AccountID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCloudRegionZonesRequestMultiError(errors)
	}

	return nil
}

// GetCloudRegionZonesRequestMultiError is an error wrapping multiple
// validation errors returned by GetCloudRegionZonesRequest.ValidateAll() if
// the designated constraints aren't met.
type GetCloudRegionZonesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRegionZonesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRegionZonesRequestMultiError) AllErrors() []error { return m }

// GetCloudRegionZonesRequestValidationError is the validation error returned
// by GetCloudRegionZonesRequest.Validate if the designated constraints aren't met.
type GetCloudRegionZonesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRegionZonesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRegionZonesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRegionZonesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRegionZonesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRegionZonesRequestValidationError) ErrorName() string {
	return "GetCloudRegionZonesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudRegionZonesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRegionZonesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRegionZonesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRegionZonesRequestValidationError{}

// Validate checks the field values on GetCloudRegionZonesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRegionZonesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRegionZonesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRegionZonesResponseMultiError, or nil if none found.
func (m *GetCloudRegionZonesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRegionZonesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCloudRegionZonesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCloudRegionZonesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCloudRegionZonesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCloudRegionZonesResponseMultiError(errors)
	}

	return nil
}

// GetCloudRegionZonesResponseMultiError is an error wrapping multiple
// validation errors returned by GetCloudRegionZonesResponse.ValidateAll() if
// the designated constraints aren't met.
type GetCloudRegionZonesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRegionZonesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRegionZonesResponseMultiError) AllErrors() []error { return m }

// GetCloudRegionZonesResponseValidationError is the validation error returned
// by GetCloudRegionZonesResponse.Validate if the designated constraints
// aren't met.
type GetCloudRegionZonesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRegionZonesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRegionZonesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRegionZonesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRegionZonesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRegionZonesResponseValidationError) ErrorName() string {
	return "GetCloudRegionZonesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudRegionZonesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRegionZonesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRegionZonesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRegionZonesResponseValidationError{}

// Validate checks the field values on OperationLog with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperationLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationLogMultiError, or
// nil if none found.
func (m *OperationLog) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceType

	// no validation rules for ResourceID

	// no validation rules for TaskID

	// no validation rules for Message

	// no validation rules for OpUser

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return OperationLogMultiError(errors)
	}

	return nil
}

// OperationLogMultiError is an error wrapping multiple validation errors
// returned by OperationLog.ValidateAll() if the designated constraints aren't met.
type OperationLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationLogMultiError) AllErrors() []error { return m }

// OperationLogValidationError is the validation error returned by
// OperationLog.Validate if the designated constraints aren't met.
type OperationLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationLogValidationError) ErrorName() string { return "OperationLogValidationError" }

// Error satisfies the builtin error interface
func (e OperationLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationLogValidationError{}

// Validate checks the field values on ListCloudInstanceTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudInstanceTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudInstanceTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudInstanceTypeRequestMultiError, or nil if none found.
func (m *ListCloudInstanceTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudInstanceTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudInstanceTypeRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	if utf8.RuneCountInString(m.GetZone()) > 32 {
		err := ListCloudInstanceTypeRequestValidationError{
			field:  "Zone",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNodeFamily()) > 32 {
		err := ListCloudInstanceTypeRequestValidationError{
			field:  "NodeFamily",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Cpu

	// no validation rules for Memory

	if len(errors) > 0 {
		return ListCloudInstanceTypeRequestMultiError(errors)
	}

	return nil
}

// ListCloudInstanceTypeRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudInstanceTypeRequest.ValidateAll() if
// the designated constraints aren't met.
type ListCloudInstanceTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudInstanceTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudInstanceTypeRequestMultiError) AllErrors() []error { return m }

// ListCloudInstanceTypeRequestValidationError is the validation error returned
// by ListCloudInstanceTypeRequest.Validate if the designated constraints
// aren't met.
type ListCloudInstanceTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudInstanceTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudInstanceTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudInstanceTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudInstanceTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudInstanceTypeRequestValidationError) ErrorName() string {
	return "ListCloudInstanceTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudInstanceTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudInstanceTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudInstanceTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudInstanceTypeRequestValidationError{}

// Validate checks the field values on ListCloudInstanceTypeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudInstanceTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudInstanceTypeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudInstanceTypeResponseMultiError, or nil if none found.
func (m *ListCloudInstanceTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudInstanceTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudInstanceTypeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudInstanceTypeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudInstanceTypeResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudInstanceTypeResponseMultiError(errors)
	}

	return nil
}

// ListCloudInstanceTypeResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudInstanceTypeResponse.ValidateAll()
// if the designated constraints aren't met.
type ListCloudInstanceTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudInstanceTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudInstanceTypeResponseMultiError) AllErrors() []error { return m }

// ListCloudInstanceTypeResponseValidationError is the validation error
// returned by ListCloudInstanceTypeResponse.Validate if the designated
// constraints aren't met.
type ListCloudInstanceTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudInstanceTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudInstanceTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudInstanceTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudInstanceTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudInstanceTypeResponseValidationError) ErrorName() string {
	return "ListCloudInstanceTypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudInstanceTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudInstanceTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudInstanceTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudInstanceTypeResponseValidationError{}

// Validate checks the field values on InstanceType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceTypeMultiError, or
// nil if none found.
func (m *InstanceType) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeType

	// no validation rules for TypeName

	// no validation rules for NodeFamily

	// no validation rules for Cpu

	// no validation rules for Memory

	// no validation rules for Gpu

	// no validation rules for Status

	// no validation rules for UnitPrice

	if len(errors) > 0 {
		return InstanceTypeMultiError(errors)
	}

	return nil
}

// InstanceTypeMultiError is an error wrapping multiple validation errors
// returned by InstanceType.ValidateAll() if the designated constraints aren't met.
type InstanceTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTypeMultiError) AllErrors() []error { return m }

// InstanceTypeValidationError is the validation error returned by
// InstanceType.Validate if the designated constraints aren't met.
type InstanceTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTypeValidationError) ErrorName() string { return "InstanceTypeValidationError" }

// Error satisfies the builtin error interface
func (e InstanceTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTypeValidationError{}

// Validate checks the field values on ListCloudOsImageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudOsImageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudOsImageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudOsImageRequestMultiError, or nil if none found.
func (m *ListCloudOsImageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudOsImageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudOsImageRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	if utf8.RuneCountInString(m.GetAccountID()) < 2 {
		err := ListCloudOsImageRequestValidationError{
			field:  "AccountID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	if len(errors) > 0 {
		return ListCloudOsImageRequestMultiError(errors)
	}

	return nil
}

// ListCloudOsImageRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudOsImageRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudOsImageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudOsImageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudOsImageRequestMultiError) AllErrors() []error { return m }

// ListCloudOsImageRequestValidationError is the validation error returned by
// ListCloudOsImageRequest.Validate if the designated constraints aren't met.
type ListCloudOsImageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudOsImageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudOsImageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudOsImageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudOsImageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudOsImageRequestValidationError) ErrorName() string {
	return "ListCloudOsImageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudOsImageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudOsImageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudOsImageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudOsImageRequestValidationError{}

// Validate checks the field values on ListCloudOsImageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudOsImageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudOsImageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudOsImageResponseMultiError, or nil if none found.
func (m *ListCloudOsImageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudOsImageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudOsImageResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudOsImageResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudOsImageResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudOsImageResponseMultiError(errors)
	}

	return nil
}

// ListCloudOsImageResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudOsImageResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudOsImageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudOsImageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudOsImageResponseMultiError) AllErrors() []error { return m }

// ListCloudOsImageResponseValidationError is the validation error returned by
// ListCloudOsImageResponse.Validate if the designated constraints aren't met.
type ListCloudOsImageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudOsImageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudOsImageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudOsImageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudOsImageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudOsImageResponseValidationError) ErrorName() string {
	return "ListCloudOsImageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudOsImageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudOsImageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudOsImageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudOsImageResponseValidationError{}

// Validate checks the field values on OsImage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OsImage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OsImage with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OsImageMultiError, or nil if none found.
func (m *OsImage) ValidateAll() error {
	return m.validate(true)
}

func (m *OsImage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ImageID

	// no validation rules for Alias

	// no validation rules for Arch

	// no validation rules for OsCustomizeType

	// no validation rules for OsName

	// no validation rules for SeriesName

	// no validation rules for Status

	// no validation rules for Provider

	if len(errors) > 0 {
		return OsImageMultiError(errors)
	}

	return nil
}

// OsImageMultiError is an error wrapping multiple validation errors returned
// by OsImage.ValidateAll() if the designated constraints aren't met.
type OsImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OsImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OsImageMultiError) AllErrors() []error { return m }

// OsImageValidationError is the validation error returned by OsImage.Validate
// if the designated constraints aren't met.
type OsImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OsImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OsImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OsImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OsImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OsImageValidationError) ErrorName() string { return "OsImageValidationError" }

// Error satisfies the builtin error interface
func (e OsImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOsImage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OsImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OsImageValidationError{}

// Validate checks the field values on ListCloudSubnetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudSubnetsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudSubnetsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudSubnetsRequestMultiError, or nil if none found.
func (m *ListCloudSubnetsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudSubnetsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudSubnetsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	if utf8.RuneCountInString(m.GetAccountID()) < 2 {
		err := ListCloudSubnetsRequestValidationError{
			field:  "AccountID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for VpcID

	// no validation rules for Zone

	// no validation rules for SubnetID

	if len(errors) > 0 {
		return ListCloudSubnetsRequestMultiError(errors)
	}

	return nil
}

// ListCloudSubnetsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudSubnetsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudSubnetsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudSubnetsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudSubnetsRequestMultiError) AllErrors() []error { return m }

// ListCloudSubnetsRequestValidationError is the validation error returned by
// ListCloudSubnetsRequest.Validate if the designated constraints aren't met.
type ListCloudSubnetsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudSubnetsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudSubnetsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudSubnetsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudSubnetsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudSubnetsRequestValidationError) ErrorName() string {
	return "ListCloudSubnetsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudSubnetsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudSubnetsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudSubnetsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudSubnetsRequestValidationError{}

// Validate checks the field values on ListCloudSubnetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudSubnetsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudSubnetsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudSubnetsResponseMultiError, or nil if none found.
func (m *ListCloudSubnetsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudSubnetsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudSubnetsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudSubnetsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudSubnetsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudSubnetsResponseMultiError(errors)
	}

	return nil
}

// ListCloudSubnetsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudSubnetsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudSubnetsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudSubnetsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudSubnetsResponseMultiError) AllErrors() []error { return m }

// ListCloudSubnetsResponseValidationError is the validation error returned by
// ListCloudSubnetsResponse.Validate if the designated constraints aren't met.
type ListCloudSubnetsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudSubnetsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudSubnetsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudSubnetsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudSubnetsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudSubnetsResponseValidationError) ErrorName() string {
	return "ListCloudSubnetsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudSubnetsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudSubnetsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudSubnetsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudSubnetsResponseValidationError{}

// Validate checks the field values on Subnet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subnet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subnet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SubnetMultiError, or nil if none found.
func (m *Subnet) ValidateAll() error {
	return m.validate(true)
}

func (m *Subnet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VpcID

	// no validation rules for SubnetID

	// no validation rules for SubnetName

	// no validation rules for CidrRange

	// no validation rules for Ipv6CidrRange

	// no validation rules for Zone

	// no validation rules for AvailableIPAddressCount

	if len(errors) > 0 {
		return SubnetMultiError(errors)
	}

	return nil
}

// SubnetMultiError is an error wrapping multiple validation errors returned by
// Subnet.ValidateAll() if the designated constraints aren't met.
type SubnetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubnetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubnetMultiError) AllErrors() []error { return m }

// SubnetValidationError is the validation error returned by Subnet.Validate if
// the designated constraints aren't met.
type SubnetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubnetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubnetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubnetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubnetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubnetValidationError) ErrorName() string { return "SubnetValidationError" }

// Error satisfies the builtin error interface
func (e SubnetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubnet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubnetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubnetValidationError{}

// Validate checks the field values on ListCloudSecurityGroupsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudSecurityGroupsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudSecurityGroupsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudSecurityGroupsRequestMultiError, or nil if none found.
func (m *ListCloudSecurityGroupsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudSecurityGroupsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudSecurityGroupsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	if len(errors) > 0 {
		return ListCloudSecurityGroupsRequestMultiError(errors)
	}

	return nil
}

// ListCloudSecurityGroupsRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudSecurityGroupsRequest.ValidateAll()
// if the designated constraints aren't met.
type ListCloudSecurityGroupsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudSecurityGroupsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudSecurityGroupsRequestMultiError) AllErrors() []error { return m }

// ListCloudSecurityGroupsRequestValidationError is the validation error
// returned by ListCloudSecurityGroupsRequest.Validate if the designated
// constraints aren't met.
type ListCloudSecurityGroupsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudSecurityGroupsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudSecurityGroupsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudSecurityGroupsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudSecurityGroupsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudSecurityGroupsRequestValidationError) ErrorName() string {
	return "ListCloudSecurityGroupsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudSecurityGroupsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudSecurityGroupsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudSecurityGroupsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudSecurityGroupsRequestValidationError{}

// Validate checks the field values on ListCloudSecurityGroupsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudSecurityGroupsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudSecurityGroupsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudSecurityGroupsResponseMultiError, or nil if none found.
func (m *ListCloudSecurityGroupsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudSecurityGroupsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudSecurityGroupsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudSecurityGroupsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudSecurityGroupsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudSecurityGroupsResponseMultiError(errors)
	}

	return nil
}

// ListCloudSecurityGroupsResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudSecurityGroupsResponse.ValidateAll()
// if the designated constraints aren't met.
type ListCloudSecurityGroupsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudSecurityGroupsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudSecurityGroupsResponseMultiError) AllErrors() []error { return m }

// ListCloudSecurityGroupsResponseValidationError is the validation error
// returned by ListCloudSecurityGroupsResponse.Validate if the designated
// constraints aren't met.
type ListCloudSecurityGroupsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudSecurityGroupsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudSecurityGroupsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudSecurityGroupsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudSecurityGroupsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudSecurityGroupsResponseValidationError) ErrorName() string {
	return "ListCloudSecurityGroupsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudSecurityGroupsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudSecurityGroupsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudSecurityGroupsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudSecurityGroupsResponseValidationError{}

// Validate checks the field values on SecurityGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecurityGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecurityGroupMultiError, or
// nil if none found.
func (m *SecurityGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityGroupID

	// no validation rules for SecurityGroupName

	// no validation rules for Description

	if len(errors) > 0 {
		return SecurityGroupMultiError(errors)
	}

	return nil
}

// SecurityGroupMultiError is an error wrapping multiple validation errors
// returned by SecurityGroup.ValidateAll() if the designated constraints
// aren't met.
type SecurityGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityGroupMultiError) AllErrors() []error { return m }

// SecurityGroupValidationError is the validation error returned by
// SecurityGroup.Validate if the designated constraints aren't met.
type SecurityGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityGroupValidationError) ErrorName() string { return "SecurityGroupValidationError" }

// Error satisfies the builtin error interface
func (e SecurityGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityGroupValidationError{}

// Validate checks the field values on ListOperationLogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperationLogsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperationLogsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOperationLogsRequestMultiError, or nil if none found.
func (m *ListOperationLogsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperationLogsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ListOperationLogsRequest_ResourceType_InLookup[m.GetResourceType()]; !ok {
		err := ListOperationLogsRequestValidationError{
			field:  "ResourceType",
			reason: "value must be in list [cluster autoscalingoption cloud cloudvpc nodegroup task]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceID

	if m.GetStartTime() <= 0 {
		err := ListOperationLogsRequestValidationError{
			field:  "StartTime",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetEndTime() <= 0 {
		err := ListOperationLogsRequestValidationError{
			field:  "EndTime",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := ListOperationLogsRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPage() <= 0 {
		err := ListOperationLogsRequestValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Simple

	if len(errors) > 0 {
		return ListOperationLogsRequestMultiError(errors)
	}

	return nil
}

// ListOperationLogsRequestMultiError is an error wrapping multiple validation
// errors returned by ListOperationLogsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListOperationLogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperationLogsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperationLogsRequestMultiError) AllErrors() []error { return m }

// ListOperationLogsRequestValidationError is the validation error returned by
// ListOperationLogsRequest.Validate if the designated constraints aren't met.
type ListOperationLogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperationLogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperationLogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperationLogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperationLogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperationLogsRequestValidationError) ErrorName() string {
	return "ListOperationLogsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperationLogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperationLogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperationLogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperationLogsRequestValidationError{}

var _ListOperationLogsRequest_ResourceType_InLookup = map[string]struct{}{
	"cluster":           {},
	"autoscalingoption": {},
	"cloud":             {},
	"cloudvpc":          {},
	"nodegroup":         {},
	"task":              {},
}

// Validate checks the field values on ListOperationLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperationLogsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperationLogsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOperationLogsResponseMultiError, or nil if none found.
func (m *ListOperationLogsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperationLogsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOperationLogsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOperationLogsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOperationLogsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListOperationLogsResponseMultiError(errors)
	}

	return nil
}

// ListOperationLogsResponseMultiError is an error wrapping multiple validation
// errors returned by ListOperationLogsResponse.ValidateAll() if the
// designated constraints aren't met.
type ListOperationLogsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperationLogsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperationLogsResponseMultiError) AllErrors() []error { return m }

// ListOperationLogsResponseValidationError is the validation error returned by
// ListOperationLogsResponse.Validate if the designated constraints aren't met.
type ListOperationLogsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperationLogsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperationLogsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperationLogsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperationLogsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperationLogsResponseValidationError) ErrorName() string {
	return "ListOperationLogsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperationLogsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperationLogsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperationLogsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperationLogsResponseValidationError{}

// Validate checks the field values on ListOperationLogsResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperationLogsResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperationLogsResponseData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListOperationLogsResponseDataMultiError, or nil if none found.
func (m *ListOperationLogsResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperationLogsResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperationLogsResponseDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperationLogsResponseDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperationLogsResponseDataValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListOperationLogsResponseDataMultiError(errors)
	}

	return nil
}

// ListOperationLogsResponseDataMultiError is an error wrapping multiple
// validation errors returned by ListOperationLogsResponseData.ValidateAll()
// if the designated constraints aren't met.
type ListOperationLogsResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperationLogsResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperationLogsResponseDataMultiError) AllErrors() []error { return m }

// ListOperationLogsResponseDataValidationError is the validation error
// returned by ListOperationLogsResponseData.Validate if the designated
// constraints aren't met.
type ListOperationLogsResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperationLogsResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperationLogsResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperationLogsResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperationLogsResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperationLogsResponseDataValidationError) ErrorName() string {
	return "ListOperationLogsResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperationLogsResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperationLogsResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperationLogsResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperationLogsResponseDataValidationError{}

// Validate checks the field values on OperationLogDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationLogDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationLogDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationLogDetailMultiError, or nil if none found.
func (m *OperationLogDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationLogDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceType

	// no validation rules for ResourceID

	// no validation rules for TaskID

	// no validation rules for Message

	// no validation rules for OpUser

	// no validation rules for CreateTime

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationLogDetailValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationLogDetailValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationLogDetailValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationLogDetailMultiError(errors)
	}

	return nil
}

// OperationLogDetailMultiError is an error wrapping multiple validation errors
// returned by OperationLogDetail.ValidateAll() if the designated constraints
// aren't met.
type OperationLogDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationLogDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationLogDetailMultiError) AllErrors() []error { return m }

// OperationLogDetailValidationError is the validation error returned by
// OperationLogDetail.Validate if the designated constraints aren't met.
type OperationLogDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationLogDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationLogDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationLogDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationLogDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationLogDetailValidationError) ErrorName() string {
	return "OperationLogDetailValidationError"
}

// Error satisfies the builtin error interface
func (e OperationLogDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationLogDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationLogDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationLogDetailValidationError{}

// Validate checks the field values on NodeOperationStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeOperationStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeOperationStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeOperationStatusMultiError, or nil if none found.
func (m *NodeOperationStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeOperationStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFail() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeOperationStatusValidationError{
						field:  fmt.Sprintf("Fail[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeOperationStatusValidationError{
						field:  fmt.Sprintf("Fail[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeOperationStatusValidationError{
					field:  fmt.Sprintf("Fail[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSuccess() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeOperationStatusValidationError{
						field:  fmt.Sprintf("Success[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeOperationStatusValidationError{
						field:  fmt.Sprintf("Success[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeOperationStatusValidationError{
					field:  fmt.Sprintf("Success[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeOperationStatusMultiError(errors)
	}

	return nil
}

// NodeOperationStatusMultiError is an error wrapping multiple validation
// errors returned by NodeOperationStatus.ValidateAll() if the designated
// constraints aren't met.
type NodeOperationStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeOperationStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeOperationStatusMultiError) AllErrors() []error { return m }

// NodeOperationStatusValidationError is the validation error returned by
// NodeOperationStatus.Validate if the designated constraints aren't met.
type NodeOperationStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeOperationStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeOperationStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeOperationStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeOperationStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeOperationStatusValidationError) ErrorName() string {
	return "NodeOperationStatusValidationError"
}

// Error satisfies the builtin error interface
func (e NodeOperationStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeOperationStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeOperationStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeOperationStatusValidationError{}

// Validate checks the field values on NodeOperationStatusInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeOperationStatusInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeOperationStatusInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeOperationStatusInfoMultiError, or nil if none found.
func (m *NodeOperationStatusInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeOperationStatusInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeName

	// no validation rules for Message

	if len(errors) > 0 {
		return NodeOperationStatusInfoMultiError(errors)
	}

	return nil
}

// NodeOperationStatusInfoMultiError is an error wrapping multiple validation
// errors returned by NodeOperationStatusInfo.ValidateAll() if the designated
// constraints aren't met.
type NodeOperationStatusInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeOperationStatusInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeOperationStatusInfoMultiError) AllErrors() []error { return m }

// NodeOperationStatusInfoValidationError is the validation error returned by
// NodeOperationStatusInfo.Validate if the designated constraints aren't met.
type NodeOperationStatusInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeOperationStatusInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeOperationStatusInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeOperationStatusInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeOperationStatusInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeOperationStatusInfoValidationError) ErrorName() string {
	return "NodeOperationStatusInfoValidationError"
}

// Error satisfies the builtin error interface
func (e NodeOperationStatusInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeOperationStatusInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeOperationStatusInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeOperationStatusInfoValidationError{}

// Validate checks the field values on DrainNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DrainNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DrainNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DrainNodeRequestMultiError, or nil if none found.
func (m *DrainNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DrainNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClusterID()) < 1 {
		err := DrainNodeRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Force

	// no validation rules for GracePeriodSeconds

	// no validation rules for IgnoreAllDaemonSets

	// no validation rules for Timeout

	// no validation rules for DeleteLocalData

	// no validation rules for Selector

	// no validation rules for PodSelector

	// no validation rules for DisableEviction

	// no validation rules for SkipWaitForDeleteTimeoutSeconds

	// no validation rules for DryRun

	if len(errors) > 0 {
		return DrainNodeRequestMultiError(errors)
	}

	return nil
}

// DrainNodeRequestMultiError is an error wrapping multiple validation errors
// returned by DrainNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type DrainNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DrainNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DrainNodeRequestMultiError) AllErrors() []error { return m }

// DrainNodeRequestValidationError is the validation error returned by
// DrainNodeRequest.Validate if the designated constraints aren't met.
type DrainNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DrainNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DrainNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DrainNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DrainNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DrainNodeRequestValidationError) ErrorName() string { return "DrainNodeRequestValidationError" }

// Error satisfies the builtin error interface
func (e DrainNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDrainNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DrainNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DrainNodeRequestValidationError{}

// Validate checks the field values on DrainNodeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DrainNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DrainNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DrainNodeResponseMultiError, or nil if none found.
func (m *DrainNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DrainNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DrainNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DrainNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DrainNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DrainNodeResponseMultiError(errors)
	}

	return nil
}

// DrainNodeResponseMultiError is an error wrapping multiple validation errors
// returned by DrainNodeResponse.ValidateAll() if the designated constraints
// aren't met.
type DrainNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DrainNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DrainNodeResponseMultiError) AllErrors() []error { return m }

// DrainNodeResponseValidationError is the validation error returned by
// DrainNodeResponse.Validate if the designated constraints aren't met.
type DrainNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DrainNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DrainNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DrainNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DrainNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DrainNodeResponseValidationError) ErrorName() string {
	return "DrainNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DrainNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDrainNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DrainNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DrainNodeResponseValidationError{}

// Validate checks the field values on NodeLabel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeLabel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeLabel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeLabelMultiError, or nil
// if none found.
func (m *NodeLabel) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeLabel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNodeName()) < 1 {
		err := NodeLabelValidationError{
			field:  "NodeName",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Labels

	if len(errors) > 0 {
		return NodeLabelMultiError(errors)
	}

	return nil
}

// NodeLabelMultiError is an error wrapping multiple validation errors returned
// by NodeLabel.ValidateAll() if the designated constraints aren't met.
type NodeLabelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeLabelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeLabelMultiError) AllErrors() []error { return m }

// NodeLabelValidationError is the validation error returned by
// NodeLabel.Validate if the designated constraints aren't met.
type NodeLabelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeLabelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeLabelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeLabelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeLabelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeLabelValidationError) ErrorName() string { return "NodeLabelValidationError" }

// Error satisfies the builtin error interface
func (e NodeLabelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeLabel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeLabelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeLabelValidationError{}

// Validate checks the field values on UpdateNodeLabelsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeLabelsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeLabelsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeLabelsRequestMultiError, or nil if none found.
func (m *UpdateNodeLabelsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeLabelsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeLabelsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeLabelsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeLabelsRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetClusterID()) < 1 {
		err := UpdateNodeLabelsRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateNodeLabelsRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeLabelsRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeLabelsRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeLabelsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeLabelsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeLabelsRequestMultiError) AllErrors() []error { return m }

// UpdateNodeLabelsRequestValidationError is the validation error returned by
// UpdateNodeLabelsRequest.Validate if the designated constraints aren't met.
type UpdateNodeLabelsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeLabelsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeLabelsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeLabelsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeLabelsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeLabelsRequestValidationError) ErrorName() string {
	return "UpdateNodeLabelsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeLabelsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeLabelsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeLabelsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeLabelsRequestValidationError{}

// Validate checks the field values on UpdateNodeLabelsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeLabelsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeLabelsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeLabelsResponseMultiError, or nil if none found.
func (m *UpdateNodeLabelsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeLabelsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeLabelsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeLabelsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeLabelsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeLabelsResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeLabelsResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeLabelsResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeLabelsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeLabelsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeLabelsResponseMultiError) AllErrors() []error { return m }

// UpdateNodeLabelsResponseValidationError is the validation error returned by
// UpdateNodeLabelsResponse.Validate if the designated constraints aren't met.
type UpdateNodeLabelsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeLabelsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeLabelsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeLabelsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeLabelsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeLabelsResponseValidationError) ErrorName() string {
	return "UpdateNodeLabelsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeLabelsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeLabelsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeLabelsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeLabelsResponseValidationError{}

// Validate checks the field values on NodeTaint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeTaint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeTaint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeTaintMultiError, or nil
// if none found.
func (m *NodeTaint) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeTaint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNodeName()) < 1 {
		err := NodeTaintValidationError{
			field:  "NodeName",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeTaintValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeTaintValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeTaintValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeTaintMultiError(errors)
	}

	return nil
}

// NodeTaintMultiError is an error wrapping multiple validation errors returned
// by NodeTaint.ValidateAll() if the designated constraints aren't met.
type NodeTaintMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeTaintMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeTaintMultiError) AllErrors() []error { return m }

// NodeTaintValidationError is the validation error returned by
// NodeTaint.Validate if the designated constraints aren't met.
type NodeTaintValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeTaintValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeTaintValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeTaintValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeTaintValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeTaintValidationError) ErrorName() string { return "NodeTaintValidationError" }

// Error satisfies the builtin error interface
func (e NodeTaintValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeTaint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeTaintValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeTaintValidationError{}

// Validate checks the field values on UpdateNodeTaintsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeTaintsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeTaintsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeTaintsRequestMultiError, or nil if none found.
func (m *UpdateNodeTaintsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeTaintsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeTaintsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeTaintsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeTaintsRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetClusterID()) < 1 {
		err := UpdateNodeTaintsRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateNodeTaintsRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeTaintsRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeTaintsRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeTaintsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeTaintsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeTaintsRequestMultiError) AllErrors() []error { return m }

// UpdateNodeTaintsRequestValidationError is the validation error returned by
// UpdateNodeTaintsRequest.Validate if the designated constraints aren't met.
type UpdateNodeTaintsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeTaintsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeTaintsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeTaintsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeTaintsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeTaintsRequestValidationError) ErrorName() string {
	return "UpdateNodeTaintsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeTaintsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeTaintsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeTaintsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeTaintsRequestValidationError{}

// Validate checks the field values on UpdateNodeTaintsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeTaintsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeTaintsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeTaintsResponseMultiError, or nil if none found.
func (m *UpdateNodeTaintsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeTaintsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTaintsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTaintsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTaintsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeTaintsResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeTaintsResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeTaintsResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeTaintsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeTaintsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeTaintsResponseMultiError) AllErrors() []error { return m }

// UpdateNodeTaintsResponseValidationError is the validation error returned by
// UpdateNodeTaintsResponse.Validate if the designated constraints aren't met.
type UpdateNodeTaintsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeTaintsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeTaintsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeTaintsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeTaintsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeTaintsResponseValidationError) ErrorName() string {
	return "UpdateNodeTaintsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeTaintsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeTaintsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeTaintsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeTaintsResponseValidationError{}

// Validate checks the field values on ListResourceSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListResourceSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResourceSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResourceSchemaRequestMultiError, or nil if none found.
func (m *ListResourceSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResourceSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	if len(errors) > 0 {
		return ListResourceSchemaRequestMultiError(errors)
	}

	return nil
}

// ListResourceSchemaRequestMultiError is an error wrapping multiple validation
// errors returned by ListResourceSchemaRequest.ValidateAll() if the
// designated constraints aren't met.
type ListResourceSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResourceSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResourceSchemaRequestMultiError) AllErrors() []error { return m }

// ListResourceSchemaRequestValidationError is the validation error returned by
// ListResourceSchemaRequest.Validate if the designated constraints aren't met.
type ListResourceSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResourceSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResourceSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResourceSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResourceSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResourceSchemaRequestValidationError) ErrorName() string {
	return "ListResourceSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListResourceSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResourceSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResourceSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResourceSchemaRequestValidationError{}

// Validate checks the field values on GetResourceSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetResourceSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResourceSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetResourceSchemaRequestMultiError, or nil if none found.
func (m *GetResourceSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResourceSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Name

	if len(errors) > 0 {
		return GetResourceSchemaRequestMultiError(errors)
	}

	return nil
}

// GetResourceSchemaRequestMultiError is an error wrapping multiple validation
// errors returned by GetResourceSchemaRequest.ValidateAll() if the designated
// constraints aren't met.
type GetResourceSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResourceSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResourceSchemaRequestMultiError) AllErrors() []error { return m }

// GetResourceSchemaRequestValidationError is the validation error returned by
// GetResourceSchemaRequest.Validate if the designated constraints aren't met.
type GetResourceSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResourceSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResourceSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResourceSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResourceSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResourceSchemaRequestValidationError) ErrorName() string {
	return "GetResourceSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetResourceSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResourceSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResourceSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResourceSchemaRequestValidationError{}

// Validate checks the field values on QueryPermByActionIDReqData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryPermByActionIDReqData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryPermByActionIDReqData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryPermByActionIDReqDataMultiError, or nil if none found.
func (m *QueryPermByActionIDReqData) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryPermByActionIDReqData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for ClusterId

	// no validation rules for Name

	// no validation rules for TemplateId

	// no validation rules for AccountId

	if utf8.RuneCountInString(m.GetOperator()) < 1 {
		err := QueryPermByActionIDReqDataValidationError{
			field:  "Operator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QueryPermByActionIDReqDataMultiError(errors)
	}

	return nil
}

// QueryPermByActionIDReqDataMultiError is an error wrapping multiple
// validation errors returned by QueryPermByActionIDReqData.ValidateAll() if
// the designated constraints aren't met.
type QueryPermByActionIDReqDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryPermByActionIDReqDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryPermByActionIDReqDataMultiError) AllErrors() []error { return m }

// QueryPermByActionIDReqDataValidationError is the validation error returned
// by QueryPermByActionIDReqData.Validate if the designated constraints aren't met.
type QueryPermByActionIDReqDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryPermByActionIDReqDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryPermByActionIDReqDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryPermByActionIDReqDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryPermByActionIDReqDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryPermByActionIDReqDataValidationError) ErrorName() string {
	return "QueryPermByActionIDReqDataValidationError"
}

// Error satisfies the builtin error interface
func (e QueryPermByActionIDReqDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryPermByActionIDReqData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryPermByActionIDReqDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryPermByActionIDReqDataValidationError{}

// Validate checks the field values on QueryPermByActionIDRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryPermByActionIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryPermByActionIDRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryPermByActionIDRequestMultiError, or nil if none found.
func (m *QueryPermByActionIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryPermByActionIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActionID

	if all {
		switch v := interface{}(m.GetPermCtx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryPermByActionIDRequestValidationError{
					field:  "PermCtx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryPermByActionIDRequestValidationError{
					field:  "PermCtx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPermCtx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryPermByActionIDRequestValidationError{
				field:  "PermCtx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryPermByActionIDRequestMultiError(errors)
	}

	return nil
}

// QueryPermByActionIDRequestMultiError is an error wrapping multiple
// validation errors returned by QueryPermByActionIDRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryPermByActionIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryPermByActionIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryPermByActionIDRequestMultiError) AllErrors() []error { return m }

// QueryPermByActionIDRequestValidationError is the validation error returned
// by QueryPermByActionIDRequest.Validate if the designated constraints aren't met.
type QueryPermByActionIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryPermByActionIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryPermByActionIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryPermByActionIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryPermByActionIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryPermByActionIDRequestValidationError) ErrorName() string {
	return "QueryPermByActionIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryPermByActionIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryPermByActionIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryPermByActionIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryPermByActionIDRequestValidationError{}

// Validate checks the field values on Perms with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Perms) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Perms with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PermsMultiError, or nil if none found.
func (m *Perms) ValidateAll() error {
	return m.validate(true)
}

func (m *Perms) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetPerms()))
		i := 0
		for key := range m.GetPerms() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPerms()[key]
			_ = val

			// no validation rules for Perms[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PermsValidationError{
							field:  fmt.Sprintf("Perms[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PermsValidationError{
							field:  fmt.Sprintf("Perms[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PermsValidationError{
						field:  fmt.Sprintf("Perms[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return PermsMultiError(errors)
	}

	return nil
}

// PermsMultiError is an error wrapping multiple validation errors returned by
// Perms.ValidateAll() if the designated constraints aren't met.
type PermsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermsMultiError) AllErrors() []error { return m }

// PermsValidationError is the validation error returned by Perms.Validate if
// the designated constraints aren't met.
type PermsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermsValidationError) ErrorName() string { return "PermsValidationError" }

// Error satisfies the builtin error interface
func (e PermsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPerms.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermsValidationError{}

// Validate checks the field values on QueryPermByActionIDResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryPermByActionIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryPermByActionIDResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryPermByActionIDResponseMultiError, or nil if none found.
func (m *QueryPermByActionIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryPermByActionIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryPermByActionIDResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryPermByActionIDResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryPermByActionIDResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryPermByActionIDResponseMultiError(errors)
	}

	return nil
}

// QueryPermByActionIDResponseMultiError is an error wrapping multiple
// validation errors returned by QueryPermByActionIDResponse.ValidateAll() if
// the designated constraints aren't met.
type QueryPermByActionIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryPermByActionIDResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryPermByActionIDResponseMultiError) AllErrors() []error { return m }

// QueryPermByActionIDResponseValidationError is the validation error returned
// by QueryPermByActionIDResponse.Validate if the designated constraints
// aren't met.
type QueryPermByActionIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryPermByActionIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryPermByActionIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryPermByActionIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryPermByActionIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryPermByActionIDResponseValidationError) ErrorName() string {
	return "QueryPermByActionIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryPermByActionIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryPermByActionIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryPermByActionIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryPermByActionIDResponseValidationError{}

// Validate checks the field values on CommonResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonRespMultiError, or
// nil if none found.
func (m *CommonResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommonRespMultiError(errors)
	}

	return nil
}

// CommonRespMultiError is an error wrapping multiple validation errors
// returned by CommonResp.ValidateAll() if the designated constraints aren't met.
type CommonRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonRespMultiError) AllErrors() []error { return m }

// CommonRespValidationError is the validation error returned by
// CommonResp.Validate if the designated constraints aren't met.
type CommonRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonRespValidationError) ErrorName() string { return "CommonRespValidationError" }

// Error satisfies the builtin error interface
func (e CommonRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonRespValidationError{}

// Validate checks the field values on CommonListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonListRespMultiError,
// or nil if none found.
func (m *CommonListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommonListRespMultiError(errors)
	}

	return nil
}

// CommonListRespMultiError is an error wrapping multiple validation errors
// returned by CommonListResp.ValidateAll() if the designated constraints
// aren't met.
type CommonListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonListRespMultiError) AllErrors() []error { return m }

// CommonListRespValidationError is the validation error returned by
// CommonListResp.Validate if the designated constraints aren't met.
type CommonListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonListRespValidationError) ErrorName() string { return "CommonListRespValidationError" }

// Error satisfies the builtin error interface
func (e CommonListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonListRespValidationError{}

// Validate checks the field values on ListBKCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBKCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBKCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBKCloudRequestMultiError, or nil if none found.
func (m *ListBKCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBKCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListBKCloudRequestMultiError(errors)
	}

	return nil
}

// ListBKCloudRequestMultiError is an error wrapping multiple validation errors
// returned by ListBKCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type ListBKCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBKCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBKCloudRequestMultiError) AllErrors() []error { return m }

// ListBKCloudRequestValidationError is the validation error returned by
// ListBKCloudRequest.Validate if the designated constraints aren't met.
type ListBKCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBKCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBKCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBKCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBKCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBKCloudRequestValidationError) ErrorName() string {
	return "ListBKCloudRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBKCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBKCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBKCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBKCloudRequestValidationError{}

// Validate checks the field values on ListCCTopologyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCCTopologyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCCTopologyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCCTopologyRequestMultiError, or nil if none found.
func (m *ListCCTopologyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCCTopologyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := ListCCTopologyRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := ListCCTopologyRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListCCTopologyRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := ListCCTopologyRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCCTopologyRequestMultiError(errors)
	}

	return nil
}

// ListCCTopologyRequestMultiError is an error wrapping multiple validation
// errors returned by ListCCTopologyRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCCTopologyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCCTopologyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCCTopologyRequestMultiError) AllErrors() []error { return m }

// ListCCTopologyRequestValidationError is the validation error returned by
// ListCCTopologyRequest.Validate if the designated constraints aren't met.
type ListCCTopologyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCCTopologyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCCTopologyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCCTopologyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCCTopologyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCCTopologyRequestValidationError) ErrorName() string {
	return "ListCCTopologyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCCTopologyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCCTopologyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCCTopologyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCCTopologyRequestValidationError{}

var _ListCCTopologyRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on
// CreateNamespaceQuotaResp_CreateNamespaceQuotaRespData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceQuotaResp_CreateNamespaceQuotaRespData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateNamespaceQuotaResp_CreateNamespaceQuotaRespData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataMultiError, or nil if
// none found.
func (m *CreateNamespaceQuotaResp_CreateNamespaceQuotaRespData) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceQuotaResp_CreateNamespaceQuotaRespData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataMultiError(errors)
	}

	return nil
}

// CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataMultiError is an error
// wrapping multiple validation errors returned by
// CreateNamespaceQuotaResp_CreateNamespaceQuotaRespData.ValidateAll() if the
// designated constraints aren't met.
type CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataMultiError) AllErrors() []error {
	return m
}

// CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError is the
// validation error returned by
// CreateNamespaceQuotaResp_CreateNamespaceQuotaRespData.Validate if the
// designated constraints aren't met.
type CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError) ErrorName() string {
	return "CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceQuotaResp_CreateNamespaceQuotaRespData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceQuotaResp_CreateNamespaceQuotaRespDataValidationError{}

// Validate checks the field values on
// CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataMultiError, or
// nil if none found.
func (m *CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespData) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataMultiError(errors)
	}

	return nil
}

// CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataMultiError is
// an error wrapping multiple validation errors returned by
// CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespData.ValidateAll()
// if the designated constraints aren't met.
type CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataMultiError) AllErrors() []error {
	return m
}

// CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError
// is the validation error returned by
// CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespData.Validate if
// the designated constraints aren't met.
type CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError) ErrorName() string {
	return "CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceWithQuotaResp_CreateNamespaceWithQuotaRespDataValidationError{}
