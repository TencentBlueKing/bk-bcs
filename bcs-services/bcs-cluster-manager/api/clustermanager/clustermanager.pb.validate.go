// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: clustermanager.proto

package clustermanager

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClusterMultiError, or nil if none found.
func (m *Cluster) ValidateAll() error {
	return m.validate(true)
}

func (m *Cluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	// no validation rules for ClusterName

	// no validation rules for FederationClusterID

	// no validation rules for Provider

	// no validation rules for Region

	// no validation rules for VpcID

	// no validation rules for ProjectID

	// no validation rules for BusinessID

	// no validation rules for Environment

	// no validation rules for EngineType

	// no validation rules for IsExclusive

	// no validation rules for ClusterType

	// no validation rules for Labels

	// no validation rules for Creator

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	{
		sorted_keys := make([]string, len(m.GetBcsAddons()))
		i := 0
		for key := range m.GetBcsAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetBcsAddons()[key]
			_ = val

			// no validation rules for BcsAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClusterValidationError{
						field:  fmt.Sprintf("BcsAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraAddons()))
		i := 0
		for key := range m.GetExtraAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraAddons()[key]
			_ = val

			// no validation rules for ExtraAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClusterValidationError{
						field:  fmt.Sprintf("ExtraAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for SystemID

	// no validation rules for ManageType

	{
		sorted_keys := make([]string, len(m.GetMaster()))
		i := 0
		for key := range m.GetMaster() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMaster()[key]
			_ = val

			// no validation rules for Master[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("Master[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClusterValidationError{
							field:  fmt.Sprintf("Master[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClusterValidationError{
						field:  fmt.Sprintf("Master[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetNetworkSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "NetworkSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterBasicSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterBasicSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "ClusterBasicSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterAdvanceSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAdvanceSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "ClusterAdvanceSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "NodeSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _Cluster_Status_InLookup[m.GetStatus()]; !ok {
		err := ClusterValidationError{
			field:  "Status",
			reason: "value must be in list [CREATING RUNNING DELETING FALURE INITIALIZATION]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Updater

	if _, ok := _Cluster_NetworkType_InLookup[m.GetNetworkType()]; !ok {
		err := ClusterValidationError{
			field:  "NetworkType",
			reason: "value must be in list [underlay overlay ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AutoGenerateMasterNodes

	for idx, item := range m.GetTemplate() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterValidationError{
						field:  fmt.Sprintf("Template[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterValidationError{
						field:  fmt.Sprintf("Template[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterValidationError{
					field:  fmt.Sprintf("Template[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtraInfo

	// no validation rules for ModuleID

	// no validation rules for ExtraClusterID

	// no validation rules for IsCommonCluster

	// no validation rules for Description

	// no validation rules for ClusterCategory

	// no validation rules for IsShared

	// no validation rules for KubeConfig

	// no validation rules for ImportCategory

	// no validation rules for CloudAccountID

	// no validation rules for Message

	// no validation rules for IsMixed

	if len(errors) > 0 {
		return ClusterMultiError(errors)
	}

	return nil
}

// ClusterMultiError is an error wrapping multiple validation errors returned
// by Cluster.ValidateAll() if the designated constraints aren't met.
type ClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMultiError) AllErrors() []error { return m }

// ClusterValidationError is the validation error returned by Cluster.Validate
// if the designated constraints aren't met.
type ClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterValidationError) ErrorName() string { return "ClusterValidationError" }

// Error satisfies the builtin error interface
func (e ClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterValidationError{}

var _Cluster_Status_InLookup = map[string]struct{}{
	"CREATING":       {},
	"RUNNING":        {},
	"DELETING":       {},
	"FALURE":         {},
	"INITIALIZATION": {},
}

var _Cluster_NetworkType_InLookup = map[string]struct{}{
	"underlay": {},
	"overlay":  {},
	"":         {},
}

// Validate checks the field values on Node with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Node) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Node with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NodeMultiError, or nil if none found.
func (m *Node) ValidateAll() error {
	return m.validate(true)
}

func (m *Node) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeID

	// no validation rules for InnerIP

	// no validation rules for InstanceType

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for Status

	// no validation rules for ZoneID

	// no validation rules for NodeGroupID

	// no validation rules for ClusterID

	// no validation rules for VPC

	// no validation rules for Region

	// no validation rules for Passwd

	// no validation rules for Zone

	// no validation rules for DeviceID

	// no validation rules for NodeTemplateID

	// no validation rules for NodeType

	// no validation rules for NodeName

	// no validation rules for InnerIPv6

	// no validation rules for ZoneName

	// no validation rules for TaskID

	// no validation rules for FailedReason

	// no validation rules for ChargeType

	if len(errors) > 0 {
		return NodeMultiError(errors)
	}

	return nil
}

// NodeMultiError is an error wrapping multiple validation errors returned by
// Node.ValidateAll() if the designated constraints aren't met.
type NodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeMultiError) AllErrors() []error { return m }

// NodeValidationError is the validation error returned by Node.Validate if the
// designated constraints aren't met.
type NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeValidationError) ErrorName() string { return "NodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeValidationError{}

// Validate checks the field values on NetworkSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NetworkSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkSetting with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetworkSettingMultiError,
// or nil if none found.
func (m *NetworkSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterIPv4CIDR

	// no validation rules for ServiceIPv4CIDR

	// no validation rules for MaxNodePodNum

	// no validation rules for MaxServiceNum

	// no validation rules for EnableVPCCni

	if all {
		switch v := interface{}(m.GetSubnetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetworkSettingValidationError{
					field:  "SubnetSource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetworkSettingValidationError{
					field:  "SubnetSource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubnetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetworkSettingValidationError{
				field:  "SubnetSource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsStaticIpMode

	// no validation rules for ClaimExpiredSeconds

	// no validation rules for CidrStep

	// no validation rules for ClusterIpType

	// no validation rules for ClusterIPv6CIDR

	// no validation rules for ServiceIPv6CIDR

	if len(errors) > 0 {
		return NetworkSettingMultiError(errors)
	}

	return nil
}

// NetworkSettingMultiError is an error wrapping multiple validation errors
// returned by NetworkSetting.ValidateAll() if the designated constraints
// aren't met.
type NetworkSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkSettingMultiError) AllErrors() []error { return m }

// NetworkSettingValidationError is the validation error returned by
// NetworkSetting.Validate if the designated constraints aren't met.
type NetworkSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkSettingValidationError) ErrorName() string { return "NetworkSettingValidationError" }

// Error satisfies the builtin error interface
func (e NetworkSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkSettingValidationError{}

// Validate checks the field values on SubnetSource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubnetSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubnetSource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubnetSourceMultiError, or
// nil if none found.
func (m *SubnetSource) ValidateAll() error {
	return m.validate(true)
}

func (m *SubnetSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNew() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubnetSourceValidationError{
						field:  fmt.Sprintf("New[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubnetSourceValidationError{
						field:  fmt.Sprintf("New[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubnetSourceValidationError{
					field:  fmt.Sprintf("New[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetExisted()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubnetSourceValidationError{
					field:  "Existed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubnetSourceValidationError{
					field:  "Existed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExisted()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubnetSourceValidationError{
				field:  "Existed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubnetSourceMultiError(errors)
	}

	return nil
}

// SubnetSourceMultiError is an error wrapping multiple validation errors
// returned by SubnetSource.ValidateAll() if the designated constraints aren't met.
type SubnetSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubnetSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubnetSourceMultiError) AllErrors() []error { return m }

// SubnetSourceValidationError is the validation error returned by
// SubnetSource.Validate if the designated constraints aren't met.
type SubnetSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubnetSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubnetSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubnetSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubnetSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubnetSourceValidationError) ErrorName() string { return "SubnetSourceValidationError" }

// Error satisfies the builtin error interface
func (e SubnetSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubnetSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubnetSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubnetSourceValidationError{}

// Validate checks the field values on ExistedSubnetIDs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExistedSubnetIDs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExistedSubnetIDs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExistedSubnetIDsMultiError, or nil if none found.
func (m *ExistedSubnetIDs) ValidateAll() error {
	return m.validate(true)
}

func (m *ExistedSubnetIDs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExistedSubnetIDsMultiError(errors)
	}

	return nil
}

// ExistedSubnetIDsMultiError is an error wrapping multiple validation errors
// returned by ExistedSubnetIDs.ValidateAll() if the designated constraints
// aren't met.
type ExistedSubnetIDsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistedSubnetIDsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistedSubnetIDsMultiError) AllErrors() []error { return m }

// ExistedSubnetIDsValidationError is the validation error returned by
// ExistedSubnetIDs.Validate if the designated constraints aren't met.
type ExistedSubnetIDsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistedSubnetIDsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistedSubnetIDsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistedSubnetIDsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistedSubnetIDsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistedSubnetIDsValidationError) ErrorName() string { return "ExistedSubnetIDsValidationError" }

// Error satisfies the builtin error interface
func (e ExistedSubnetIDsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistedSubnetIDs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistedSubnetIDsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistedSubnetIDsValidationError{}

// Validate checks the field values on NewSubnet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NewSubnet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NewSubnet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NewSubnetMultiError, or nil
// if none found.
func (m *NewSubnet) ValidateAll() error {
	return m.validate(true)
}

func (m *NewSubnet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mask

	// no validation rules for Zone

	// no validation rules for IpCnt

	if len(errors) > 0 {
		return NewSubnetMultiError(errors)
	}

	return nil
}

// NewSubnetMultiError is an error wrapping multiple validation errors returned
// by NewSubnet.ValidateAll() if the designated constraints aren't met.
type NewSubnetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NewSubnetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NewSubnetMultiError) AllErrors() []error { return m }

// NewSubnetValidationError is the validation error returned by
// NewSubnet.Validate if the designated constraints aren't met.
type NewSubnetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NewSubnetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NewSubnetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NewSubnetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NewSubnetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NewSubnetValidationError) ErrorName() string { return "NewSubnetValidationError" }

// Error satisfies the builtin error interface
func (e NewSubnetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNewSubnet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NewSubnetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NewSubnetValidationError{}

// Validate checks the field values on ClusterBasicSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterBasicSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterBasicSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterBasicSettingMultiError, or nil if none found.
func (m *ClusterBasicSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterBasicSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OS

	// no validation rules for Version

	// no validation rules for ClusterTags

	// no validation rules for VersionName

	// no validation rules for SubnetID

	// no validation rules for ClusterLevel

	// no validation rules for IsAutoUpgradeClusterLevel

	if all {
		switch v := interface{}(m.GetArea()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterBasicSettingValidationError{
					field:  "Area",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterBasicSettingValidationError{
					field:  "Area",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArea()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterBasicSettingValidationError{
				field:  "Area",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterBasicSettingValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterBasicSettingValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterBasicSettingValidationError{
				field:  "Module",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterBasicSettingMultiError(errors)
	}

	return nil
}

// ClusterBasicSettingMultiError is an error wrapping multiple validation
// errors returned by ClusterBasicSetting.ValidateAll() if the designated
// constraints aren't met.
type ClusterBasicSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterBasicSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterBasicSettingMultiError) AllErrors() []error { return m }

// ClusterBasicSettingValidationError is the validation error returned by
// ClusterBasicSetting.Validate if the designated constraints aren't met.
type ClusterBasicSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterBasicSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterBasicSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterBasicSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterBasicSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterBasicSettingValidationError) ErrorName() string {
	return "ClusterBasicSettingValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterBasicSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterBasicSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterBasicSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterBasicSettingValidationError{}

// Validate checks the field values on ClusterAdvanceSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAdvanceSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAdvanceSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterAdvanceSettingMultiError, or nil if none found.
func (m *ClusterAdvanceSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAdvanceSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IPVS

	// no validation rules for ContainerRuntime

	// no validation rules for RuntimeVersion

	// no validation rules for ExtraArgs

	// no validation rules for NetworkType

	// no validation rules for DeletionProtection

	// no validation rules for AuditEnabled

	// no validation rules for EnableHa

	if all {
		switch v := interface{}(m.GetClusterConnectSetting()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterAdvanceSettingValidationError{
					field:  "ClusterConnectSetting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterAdvanceSettingValidationError{
					field:  "ClusterConnectSetting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterConnectSetting()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterAdvanceSettingValidationError{
				field:  "ClusterConnectSetting",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterAdvanceSettingMultiError(errors)
	}

	return nil
}

// ClusterAdvanceSettingMultiError is an error wrapping multiple validation
// errors returned by ClusterAdvanceSetting.ValidateAll() if the designated
// constraints aren't met.
type ClusterAdvanceSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAdvanceSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAdvanceSettingMultiError) AllErrors() []error { return m }

// ClusterAdvanceSettingValidationError is the validation error returned by
// ClusterAdvanceSetting.Validate if the designated constraints aren't met.
type ClusterAdvanceSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAdvanceSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAdvanceSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAdvanceSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAdvanceSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAdvanceSettingValidationError) ErrorName() string {
	return "ClusterAdvanceSettingValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAdvanceSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAdvanceSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAdvanceSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAdvanceSettingValidationError{}

// Validate checks the field values on ClusterConnectSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConnectSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConnectSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConnectSettingMultiError, or nil if none found.
func (m *ClusterConnectSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConnectSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsExtranet

	// no validation rules for SubnetId

	// no validation rules for Domain

	// no validation rules for SecurityGroup

	if all {
		switch v := interface{}(m.GetInternet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConnectSettingValidationError{
					field:  "Internet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConnectSettingValidationError{
					field:  "Internet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInternet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConnectSettingValidationError{
				field:  "Internet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterConnectSettingMultiError(errors)
	}

	return nil
}

// ClusterConnectSettingMultiError is an error wrapping multiple validation
// errors returned by ClusterConnectSetting.ValidateAll() if the designated
// constraints aren't met.
type ClusterConnectSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConnectSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConnectSettingMultiError) AllErrors() []error { return m }

// ClusterConnectSettingValidationError is the validation error returned by
// ClusterConnectSetting.Validate if the designated constraints aren't met.
type ClusterConnectSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConnectSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConnectSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConnectSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConnectSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConnectSettingValidationError) ErrorName() string {
	return "ClusterConnectSettingValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConnectSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConnectSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConnectSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConnectSettingValidationError{}

// Validate checks the field values on NodeSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeSettingMultiError, or
// nil if none found.
func (m *NodeSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DockerGraphPath

	// no validation rules for MountTarget

	// no validation rules for UnSchedulable

	// no validation rules for Labels

	// no validation rules for ExtraArgs

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeSettingValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeSettingValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeSettingValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetMasterLogin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSettingValidationError{
					field:  "MasterLogin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSettingValidationError{
					field:  "MasterLogin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMasterLogin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSettingValidationError{
				field:  "MasterLogin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWorkerLogin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSettingValidationError{
					field:  "WorkerLogin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSettingValidationError{
					field:  "WorkerLogin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkerLogin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSettingValidationError{
				field:  "WorkerLogin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeSettingMultiError(errors)
	}

	return nil
}

// NodeSettingMultiError is an error wrapping multiple validation errors
// returned by NodeSetting.ValidateAll() if the designated constraints aren't met.
type NodeSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSettingMultiError) AllErrors() []error { return m }

// NodeSettingValidationError is the validation error returned by
// NodeSetting.Validate if the designated constraints aren't met.
type NodeSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSettingValidationError) ErrorName() string { return "NodeSettingValidationError" }

// Error satisfies the builtin error interface
func (e NodeSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSettingValidationError{}

// Validate checks the field values on NodeLoginInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeLoginInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeLoginInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeLoginInfoMultiError, or
// nil if none found.
func (m *NodeLoginInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeLoginInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InitLoginUsername

	// no validation rules for InitLoginPassword

	if all {
		switch v := interface{}(m.GetKeyPair()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeLoginInfoValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeLoginInfoValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyPair()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeLoginInfoValidationError{
				field:  "KeyPair",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeLoginInfoMultiError(errors)
	}

	return nil
}

// NodeLoginInfoMultiError is an error wrapping multiple validation errors
// returned by NodeLoginInfo.ValidateAll() if the designated constraints
// aren't met.
type NodeLoginInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeLoginInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeLoginInfoMultiError) AllErrors() []error { return m }

// NodeLoginInfoValidationError is the validation error returned by
// NodeLoginInfo.Validate if the designated constraints aren't met.
type NodeLoginInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeLoginInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeLoginInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeLoginInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeLoginInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeLoginInfoValidationError) ErrorName() string { return "NodeLoginInfoValidationError" }

// Error satisfies the builtin error interface
func (e NodeLoginInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeLoginInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeLoginInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeLoginInfoValidationError{}

// Validate checks the field values on ClusterCredential with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClusterCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterCredentialMultiError, or nil if none found.
func (m *ClusterCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerKey

	// no validation rules for ClusterID

	// no validation rules for ClientModule

	// no validation rules for ServerAddress

	// no validation rules for CaCertData

	// no validation rules for UserToken

	// no validation rules for ClusterDomain

	// no validation rules for ConnectMode

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for ClientCert

	// no validation rules for ClientKey

	if len(errors) > 0 {
		return ClusterCredentialMultiError(errors)
	}

	return nil
}

// ClusterCredentialMultiError is an error wrapping multiple validation errors
// returned by ClusterCredential.ValidateAll() if the designated constraints
// aren't met.
type ClusterCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterCredentialMultiError) AllErrors() []error { return m }

// ClusterCredentialValidationError is the validation error returned by
// ClusterCredential.Validate if the designated constraints aren't met.
type ClusterCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterCredentialValidationError) ErrorName() string {
	return "ClusterCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterCredentialValidationError{}

// Validate checks the field values on Namespace with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Namespace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Namespace with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamespaceMultiError, or nil
// if none found.
func (m *Namespace) ValidateAll() error {
	return m.validate(true)
}

func (m *Namespace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for FederationClusterID

	// no validation rules for ProjectID

	// no validation rules for BusinessID

	// no validation rules for Labels

	// no validation rules for MaxQuota

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	for idx, item := range m.GetQuotaList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NamespaceValidationError{
						field:  fmt.Sprintf("QuotaList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NamespaceValidationError{
						field:  fmt.Sprintf("QuotaList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NamespaceValidationError{
					field:  fmt.Sprintf("QuotaList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NamespaceMultiError(errors)
	}

	return nil
}

// NamespaceMultiError is an error wrapping multiple validation errors returned
// by Namespace.ValidateAll() if the designated constraints aren't met.
type NamespaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceMultiError) AllErrors() []error { return m }

// NamespaceValidationError is the validation error returned by
// Namespace.Validate if the designated constraints aren't met.
type NamespaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceValidationError) ErrorName() string { return "NamespaceValidationError" }

// Error satisfies the builtin error interface
func (e NamespaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceValidationError{}

// Validate checks the field values on ResourceQuota with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceQuota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceQuota with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceQuotaMultiError, or
// nil if none found.
func (m *ResourceQuota) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceQuota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	// no validation rules for FederationClusterID

	// no validation rules for ClusterID

	// no validation rules for ResourceQuota

	// no validation rules for Region

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for Status

	// no validation rules for Message

	if len(errors) > 0 {
		return ResourceQuotaMultiError(errors)
	}

	return nil
}

// ResourceQuotaMultiError is an error wrapping multiple validation errors
// returned by ResourceQuota.ValidateAll() if the designated constraints
// aren't met.
type ResourceQuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceQuotaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceQuotaMultiError) AllErrors() []error { return m }

// ResourceQuotaValidationError is the validation error returned by
// ResourceQuota.Validate if the designated constraints aren't met.
type ResourceQuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceQuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceQuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceQuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceQuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceQuotaValidationError) ErrorName() string { return "ResourceQuotaValidationError" }

// Error satisfies the builtin error interface
func (e ResourceQuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceQuota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceQuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceQuotaValidationError{}

// Validate checks the field values on Credential with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Credential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Credential with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CredentialMultiError, or
// nil if none found.
func (m *Credential) ValidateAll() error {
	return m.validate(true)
}

func (m *Credential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Secret

	// no validation rules for SubscriptionID

	// no validation rules for TenantID

	// no validation rules for ResourceGroupName

	// no validation rules for ClientID

	// no validation rules for ClientSecret

	// no validation rules for ServiceAccountSecret

	// no validation rules for GkeProjectID

	if len(errors) > 0 {
		return CredentialMultiError(errors)
	}

	return nil
}

// CredentialMultiError is an error wrapping multiple validation errors
// returned by Credential.ValidateAll() if the designated constraints aren't met.
type CredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialMultiError) AllErrors() []error { return m }

// CredentialValidationError is the validation error returned by
// Credential.Validate if the designated constraints aren't met.
type CredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialValidationError) ErrorName() string { return "CredentialValidationError" }

// Error satisfies the builtin error interface
func (e CredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialValidationError{}

// Validate checks the field values on BKOpsPlugin with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BKOpsPlugin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BKOpsPlugin with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BKOpsPluginMultiError, or
// nil if none found.
func (m *BKOpsPlugin) ValidateAll() error {
	return m.validate(true)
}

func (m *BKOpsPlugin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for System

	// no validation rules for Link

	// no validation rules for Params

	// no validation rules for AllowSkipWhenFailed

	if len(errors) > 0 {
		return BKOpsPluginMultiError(errors)
	}

	return nil
}

// BKOpsPluginMultiError is an error wrapping multiple validation errors
// returned by BKOpsPlugin.ValidateAll() if the designated constraints aren't met.
type BKOpsPluginMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BKOpsPluginMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BKOpsPluginMultiError) AllErrors() []error { return m }

// BKOpsPluginValidationError is the validation error returned by
// BKOpsPlugin.Validate if the designated constraints aren't met.
type BKOpsPluginValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BKOpsPluginValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BKOpsPluginValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BKOpsPluginValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BKOpsPluginValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BKOpsPluginValidationError) ErrorName() string { return "BKOpsPluginValidationError" }

// Error satisfies the builtin error interface
func (e BKOpsPluginValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBKOpsPlugin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BKOpsPluginValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BKOpsPluginValidationError{}

// Validate checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Action) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ActionMultiError, or nil if none found.
func (m *Action) ValidateAll() error {
	return m.validate(true)
}

func (m *Action) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetPlugins()))
		i := 0
		for key := range m.GetPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPlugins()[key]
			_ = val

			// no validation rules for Plugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ActionValidationError{
							field:  fmt.Sprintf("Plugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ActionValidationError{
							field:  fmt.Sprintf("Plugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ActionValidationError{
						field:  fmt.Sprintf("Plugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ActionMultiError(errors)
	}

	return nil
}

// ActionMultiError is an error wrapping multiple validation errors returned by
// Action.ValidateAll() if the designated constraints aren't met.
type ActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionMultiError) AllErrors() []error { return m }

// ActionValidationError is the validation error returned by Action.Validate if
// the designated constraints aren't met.
type ActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionValidationError) ErrorName() string { return "ActionValidationError" }

// Error satisfies the builtin error interface
func (e ActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionValidationError{}

// Validate checks the field values on ClusterMgr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterMgr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterMgr with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterMgrMultiError, or
// nil if none found.
func (m *ClusterMgr) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterMgr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "CreateCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "CreateCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "CreateCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "DeleteCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "DeleteCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "DeleteCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAddNodesToCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "AddNodesToCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "AddNodesToCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddNodesToCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "AddNodesToCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteNodesFromCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "DeleteNodesFromCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "DeleteNodesFromCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteNodesFromCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "DeleteNodesFromCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetImportCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "ImportCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "ImportCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImportCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "ImportCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCommonMixedAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "CommonMixedAction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "CommonMixedAction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonMixedAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "CommonMixedAction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCheckExternalNodeEmptyAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "CheckExternalNodeEmptyAction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterMgrValidationError{
					field:  "CheckExternalNodeEmptyAction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckExternalNodeEmptyAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterMgrValidationError{
				field:  "CheckExternalNodeEmptyAction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterMgrMultiError(errors)
	}

	return nil
}

// ClusterMgrMultiError is an error wrapping multiple validation errors
// returned by ClusterMgr.ValidateAll() if the designated constraints aren't met.
type ClusterMgrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMgrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMgrMultiError) AllErrors() []error { return m }

// ClusterMgrValidationError is the validation error returned by
// ClusterMgr.Validate if the designated constraints aren't met.
type ClusterMgrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterMgrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterMgrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterMgrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterMgrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterMgrValidationError) ErrorName() string { return "ClusterMgrValidationError" }

// Error satisfies the builtin error interface
func (e ClusterMgrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterMgr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterMgrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterMgrValidationError{}

// Validate checks the field values on NodeGroupMgr with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroupMgr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupMgr with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupMgrMultiError, or
// nil if none found.
func (m *NodeGroupMgr) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupMgr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "CreateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "CreateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "CreateNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "DeleteNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "DeleteNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "DeleteNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMoveNodesToGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "MoveNodesToGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "MoveNodesToGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMoveNodesToGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "MoveNodesToGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoveNodesFromGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "RemoveNodesFromGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "RemoveNodesFromGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoveNodesFromGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "RemoveNodesFromGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCleanNodesInGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "CleanNodesInGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "CleanNodesInGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCleanNodesInGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "CleanNodesInGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateDesiredNodes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "UpdateDesiredNodes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "UpdateDesiredNodes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateDesiredNodes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "UpdateDesiredNodes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAddExternalNodesToCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "AddExternalNodesToCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "AddExternalNodesToCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddExternalNodesToCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "AddExternalNodesToCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteExternalNodesFromCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "DeleteExternalNodesFromCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupMgrValidationError{
					field:  "DeleteExternalNodesFromCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteExternalNodesFromCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupMgrValidationError{
				field:  "DeleteExternalNodesFromCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeGroupMgrMultiError(errors)
	}

	return nil
}

// NodeGroupMgrMultiError is an error wrapping multiple validation errors
// returned by NodeGroupMgr.ValidateAll() if the designated constraints aren't met.
type NodeGroupMgrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupMgrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupMgrMultiError) AllErrors() []error { return m }

// NodeGroupMgrValidationError is the validation error returned by
// NodeGroupMgr.Validate if the designated constraints aren't met.
type NodeGroupMgrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupMgrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupMgrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupMgrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupMgrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupMgrValidationError) ErrorName() string { return "NodeGroupMgrValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupMgrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupMgr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupMgrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupMgrValidationError{}

// Validate checks the field values on OSInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OSInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OSInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OSInfoMultiError, or nil if none found.
func (m *OSInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OSInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Regions

	if len(errors) > 0 {
		return OSInfoMultiError(errors)
	}

	return nil
}

// OSInfoMultiError is an error wrapping multiple validation errors returned by
// OSInfo.ValidateAll() if the designated constraints aren't met.
type OSInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OSInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OSInfoMultiError) AllErrors() []error { return m }

// OSInfoValidationError is the validation error returned by OSInfo.Validate if
// the designated constraints aren't met.
type OSInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OSInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OSInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OSInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OSInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OSInfoValidationError) ErrorName() string { return "OSInfoValidationError" }

// Error satisfies the builtin error interface
func (e OSInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOSInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OSInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OSInfoValidationError{}

// Validate checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Account) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AccountMultiError, or nil if none found.
func (m *Account) ValidateAll() error {
	return m.validate(true)
}

func (m *Account) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecretID

	// no validation rules for SecretKey

	// no validation rules for SubscriptionID

	// no validation rules for TenantID

	// no validation rules for ResourceGroupName

	// no validation rules for ClientID

	// no validation rules for ClientSecret

	// no validation rules for ServiceAccountSecret

	// no validation rules for GkeProjectID

	if len(errors) > 0 {
		return AccountMultiError(errors)
	}

	return nil
}

// AccountMultiError is an error wrapping multiple validation errors returned
// by Account.ValidateAll() if the designated constraints aren't met.
type AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountMultiError) AllErrors() []error { return m }

// AccountValidationError is the validation error returned by Account.Validate
// if the designated constraints aren't met.
type AccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountValidationError) ErrorName() string { return "AccountValidationError" }

// Error satisfies the builtin error interface
func (e AccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountValidationError{}

// Validate checks the field values on CloudAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudAccountMultiError, or
// nil if none found.
func (m *CloudAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for ProjectID

	// no validation rules for AccountID

	// no validation rules for AccountName

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudAccountValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudAccountValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudAccountValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Enable

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return CloudAccountMultiError(errors)
	}

	return nil
}

// CloudAccountMultiError is an error wrapping multiple validation errors
// returned by CloudAccount.ValidateAll() if the designated constraints aren't met.
type CloudAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAccountMultiError) AllErrors() []error { return m }

// CloudAccountValidationError is the validation error returned by
// CloudAccount.Validate if the designated constraints aren't met.
type CloudAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAccountValidationError) ErrorName() string { return "CloudAccountValidationError" }

// Error satisfies the builtin error interface
func (e CloudAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAccountValidationError{}

// Validate checks the field values on CreateCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudAccountRequestMultiError, or nil if none found.
func (m *CreateCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 1024 {
		err := CreateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudAccountRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := CreateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountName()) < 1 {
		err := CreateCloudAccountRequestValidationError{
			field:  "AccountName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudAccountRequestValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudAccountRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudAccountRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudAccountRequestValidationError{
				field:  "Enable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 1024 {
		err := CreateCloudAccountRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 2 {
		err := CreateCloudAccountRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateCloudAccountRequestMultiError(errors)
	}

	return nil
}

// CreateCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by CreateCloudAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudAccountRequestMultiError) AllErrors() []error { return m }

// CreateCloudAccountRequestValidationError is the validation error returned by
// CreateCloudAccountRequest.Validate if the designated constraints aren't met.
type CreateCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudAccountRequestValidationError) ErrorName() string {
	return "CreateCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudAccountRequestValidationError{}

var _CreateCloudAccountRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudAccountResponseMultiError, or nil if none found.
func (m *CreateCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudAccountResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudAccountResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudAccountResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCloudAccountResponseMultiError(errors)
	}

	return nil
}

// CreateCloudAccountResponseMultiError is an error wrapping multiple
// validation errors returned by CreateCloudAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudAccountResponseMultiError) AllErrors() []error { return m }

// CreateCloudAccountResponseValidationError is the validation error returned
// by CreateCloudAccountResponse.Validate if the designated constraints aren't met.
type CreateCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudAccountResponseValidationError) ErrorName() string {
	return "CreateCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudAccountResponseValidationError{}

// Validate checks the field values on UpdateCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudAccountRequestMultiError, or nil if none found.
func (m *UpdateCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 1024 {
		err := UpdateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudAccountRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := UpdateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAccountID()); l < 2 || l > 1024 {
		err := UpdateCloudAccountRequestValidationError{
			field:  "AccountID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudAccountRequest_AccountID_Pattern.MatchString(m.GetAccountID()) {
		err := UpdateCloudAccountRequestValidationError{
			field:  "AccountID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountName

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetEnable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudAccountRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudAccountRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudAccountRequestValidationError{
				field:  "Enable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProjectID

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 1024 {
		err := UpdateCloudAccountRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudAccountRequestValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCloudAccountRequestMultiError(errors)
	}

	return nil
}

// UpdateCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateCloudAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudAccountRequestMultiError) AllErrors() []error { return m }

// UpdateCloudAccountRequestValidationError is the validation error returned by
// UpdateCloudAccountRequest.Validate if the designated constraints aren't met.
type UpdateCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudAccountRequestValidationError) ErrorName() string {
	return "UpdateCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudAccountRequestValidationError{}

var _UpdateCloudAccountRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateCloudAccountRequest_AccountID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudAccountResponseMultiError, or nil if none found.
func (m *UpdateCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateCloudAccountResponseMultiError(errors)
	}

	return nil
}

// UpdateCloudAccountResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateCloudAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudAccountResponseMultiError) AllErrors() []error { return m }

// UpdateCloudAccountResponseValidationError is the validation error returned
// by UpdateCloudAccountResponse.Validate if the designated constraints aren't met.
type UpdateCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudAccountResponseValidationError) ErrorName() string {
	return "UpdateCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudAccountResponseValidationError{}

// Validate checks the field values on MigrateCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MigrateCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MigrateCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MigrateCloudAccountRequestMultiError, or nil if none found.
func (m *MigrateCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MigrateCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 1024 {
		err := MigrateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_MigrateCloudAccountRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := MigrateCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountIDs

	if all {
		switch v := interface{}(m.GetEncrypt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MigrateCloudAccountRequestValidationError{
					field:  "Encrypt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MigrateCloudAccountRequestValidationError{
					field:  "Encrypt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEncrypt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MigrateCloudAccountRequestValidationError{
				field:  "Encrypt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for All

	if len(errors) > 0 {
		return MigrateCloudAccountRequestMultiError(errors)
	}

	return nil
}

// MigrateCloudAccountRequestMultiError is an error wrapping multiple
// validation errors returned by MigrateCloudAccountRequest.ValidateAll() if
// the designated constraints aren't met.
type MigrateCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MigrateCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MigrateCloudAccountRequestMultiError) AllErrors() []error { return m }

// MigrateCloudAccountRequestValidationError is the validation error returned
// by MigrateCloudAccountRequest.Validate if the designated constraints aren't met.
type MigrateCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MigrateCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MigrateCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MigrateCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MigrateCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MigrateCloudAccountRequestValidationError) ErrorName() string {
	return "MigrateCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MigrateCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMigrateCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MigrateCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MigrateCloudAccountRequestValidationError{}

var _MigrateCloudAccountRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on OriginEncrypt with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OriginEncrypt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OriginEncrypt with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OriginEncryptMultiError, or
// nil if none found.
func (m *OriginEncrypt) ValidateAll() error {
	return m.validate(true)
}

func (m *OriginEncrypt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EncryptType

	// no validation rules for Kv

	// no validation rules for Iv

	if len(errors) > 0 {
		return OriginEncryptMultiError(errors)
	}

	return nil
}

// OriginEncryptMultiError is an error wrapping multiple validation errors
// returned by OriginEncrypt.ValidateAll() if the designated constraints
// aren't met.
type OriginEncryptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OriginEncryptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OriginEncryptMultiError) AllErrors() []error { return m }

// OriginEncryptValidationError is the validation error returned by
// OriginEncrypt.Validate if the designated constraints aren't met.
type OriginEncryptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OriginEncryptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OriginEncryptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OriginEncryptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OriginEncryptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OriginEncryptValidationError) ErrorName() string { return "OriginEncryptValidationError" }

// Error satisfies the builtin error interface
func (e OriginEncryptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOriginEncrypt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OriginEncryptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OriginEncryptValidationError{}

// Validate checks the field values on MigrateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MigrateCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MigrateCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MigrateCloudAccountResponseMultiError, or nil if none found.
func (m *MigrateCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MigrateCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return MigrateCloudAccountResponseMultiError(errors)
	}

	return nil
}

// MigrateCloudAccountResponseMultiError is an error wrapping multiple
// validation errors returned by MigrateCloudAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type MigrateCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MigrateCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MigrateCloudAccountResponseMultiError) AllErrors() []error { return m }

// MigrateCloudAccountResponseValidationError is the validation error returned
// by MigrateCloudAccountResponse.Validate if the designated constraints
// aren't met.
type MigrateCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MigrateCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MigrateCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MigrateCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MigrateCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MigrateCloudAccountResponseValidationError) ErrorName() string {
	return "MigrateCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MigrateCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMigrateCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MigrateCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MigrateCloudAccountResponseValidationError{}

// Validate checks the field values on DeleteCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudAccountRequestMultiError, or nil if none found.
func (m *DeleteCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 1024 {
		err := DeleteCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudAccountRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := DeleteCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAccountID()); l < 2 || l > 1024 {
		err := DeleteCloudAccountRequestValidationError{
			field:  "AccountID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudAccountRequest_AccountID_Pattern.MatchString(m.GetAccountID()) {
		err := DeleteCloudAccountRequestValidationError{
			field:  "AccountID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteCloudAccountRequestMultiError(errors)
	}

	return nil
}

// DeleteCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCloudAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudAccountRequestMultiError) AllErrors() []error { return m }

// DeleteCloudAccountRequestValidationError is the validation error returned by
// DeleteCloudAccountRequest.Validate if the designated constraints aren't met.
type DeleteCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudAccountRequestValidationError) ErrorName() string {
	return "DeleteCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudAccountRequestValidationError{}

var _DeleteCloudAccountRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _DeleteCloudAccountRequest_AccountID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudAccountResponseMultiError, or nil if none found.
func (m *DeleteCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DeleteCloudAccountResponseMultiError(errors)
	}

	return nil
}

// DeleteCloudAccountResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteCloudAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudAccountResponseMultiError) AllErrors() []error { return m }

// DeleteCloudAccountResponseValidationError is the validation error returned
// by DeleteCloudAccountResponse.Validate if the designated constraints aren't met.
type DeleteCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudAccountResponseValidationError) ErrorName() string {
	return "DeleteCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudAccountResponseValidationError{}

// Validate checks the field values on ListCloudAccountPermRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudAccountPermRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudAccountPermRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudAccountPermRequestMultiError, or nil if none found.
func (m *ListCloudAccountPermRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudAccountPermRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for AccountName

	if len(errors) > 0 {
		return ListCloudAccountPermRequestMultiError(errors)
	}

	return nil
}

// ListCloudAccountPermRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudAccountPermRequest.ValidateAll() if
// the designated constraints aren't met.
type ListCloudAccountPermRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudAccountPermRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudAccountPermRequestMultiError) AllErrors() []error { return m }

// ListCloudAccountPermRequestValidationError is the validation error returned
// by ListCloudAccountPermRequest.Validate if the designated constraints
// aren't met.
type ListCloudAccountPermRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudAccountPermRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudAccountPermRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudAccountPermRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudAccountPermRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudAccountPermRequestValidationError) ErrorName() string {
	return "ListCloudAccountPermRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudAccountPermRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudAccountPermRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudAccountPermRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudAccountPermRequestValidationError{}

// Validate checks the field values on ListCloudAccountPermResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudAccountPermResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudAccountPermResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudAccountPermResponseMultiError, or nil if none found.
func (m *ListCloudAccountPermResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudAccountPermResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudAccountPermResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudAccountPermResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudAccountPermResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudAccountPermResponseMultiError(errors)
	}

	return nil
}

// ListCloudAccountPermResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudAccountPermResponse.ValidateAll() if
// the designated constraints aren't met.
type ListCloudAccountPermResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudAccountPermResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudAccountPermResponseMultiError) AllErrors() []error { return m }

// ListCloudAccountPermResponseValidationError is the validation error returned
// by ListCloudAccountPermResponse.Validate if the designated constraints
// aren't met.
type ListCloudAccountPermResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudAccountPermResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudAccountPermResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudAccountPermResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudAccountPermResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudAccountPermResponseValidationError) ErrorName() string {
	return "ListCloudAccountPermResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudAccountPermResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudAccountPermResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudAccountPermResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudAccountPermResponseValidationError{}

// Validate checks the field values on ListCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudAccountRequestMultiError, or nil if none found.
func (m *ListCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 1024 {
		err := ListCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountID

	// no validation rules for ProjectID

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListCloudAccountRequestMultiError(errors)
	}

	return nil
}

// ListCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudAccountRequestMultiError) AllErrors() []error { return m }

// ListCloudAccountRequestValidationError is the validation error returned by
// ListCloudAccountRequest.Validate if the designated constraints aren't met.
type ListCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudAccountRequestValidationError) ErrorName() string {
	return "ListCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudAccountRequestValidationError{}

// Validate checks the field values on VerifyCloudAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerifyCloudAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyCloudAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerifyCloudAccountRequestMultiError, or nil if none found.
func (m *VerifyCloudAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyCloudAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 1024 {
		err := VerifyCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_VerifyCloudAccountRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := VerifyCloudAccountRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifyCloudAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifyCloudAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifyCloudAccountRequestValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VerifyCloudAccountRequestMultiError(errors)
	}

	return nil
}

// VerifyCloudAccountRequestMultiError is an error wrapping multiple validation
// errors returned by VerifyCloudAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type VerifyCloudAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyCloudAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyCloudAccountRequestMultiError) AllErrors() []error { return m }

// VerifyCloudAccountRequestValidationError is the validation error returned by
// VerifyCloudAccountRequest.Validate if the designated constraints aren't met.
type VerifyCloudAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyCloudAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyCloudAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyCloudAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyCloudAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyCloudAccountRequestValidationError) ErrorName() string {
	return "VerifyCloudAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e VerifyCloudAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyCloudAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyCloudAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyCloudAccountRequestValidationError{}

var _VerifyCloudAccountRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on VerifyCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerifyCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerifyCloudAccountResponseMultiError, or nil if none found.
func (m *VerifyCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return VerifyCloudAccountResponseMultiError(errors)
	}

	return nil
}

// VerifyCloudAccountResponseMultiError is an error wrapping multiple
// validation errors returned by VerifyCloudAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type VerifyCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyCloudAccountResponseMultiError) AllErrors() []error { return m }

// VerifyCloudAccountResponseValidationError is the validation error returned
// by VerifyCloudAccountResponse.Validate if the designated constraints aren't met.
type VerifyCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyCloudAccountResponseValidationError) ErrorName() string {
	return "VerifyCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e VerifyCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyCloudAccountResponseValidationError{}

// Validate checks the field values on CloudAccountInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudAccountInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudAccountInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudAccountInfoMultiError, or nil if none found.
func (m *CloudAccountInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudAccountInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudAccountInfoValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudAccountInfoValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudAccountInfoValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CloudAccountInfoMultiError(errors)
	}

	return nil
}

// CloudAccountInfoMultiError is an error wrapping multiple validation errors
// returned by CloudAccountInfo.ValidateAll() if the designated constraints
// aren't met.
type CloudAccountInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAccountInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAccountInfoMultiError) AllErrors() []error { return m }

// CloudAccountInfoValidationError is the validation error returned by
// CloudAccountInfo.Validate if the designated constraints aren't met.
type CloudAccountInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAccountInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAccountInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAccountInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAccountInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAccountInfoValidationError) ErrorName() string { return "CloudAccountInfoValidationError" }

// Error satisfies the builtin error interface
func (e CloudAccountInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudAccountInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAccountInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAccountInfoValidationError{}

// Validate checks the field values on ListCloudAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudAccountResponseMultiError, or nil if none found.
func (m *ListCloudAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudAccountResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudAccountResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudAccountResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCloudAccountResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCloudAccountResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCloudAccountResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCloudAccountResponseMultiError(errors)
	}

	return nil
}

// ListCloudAccountResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudAccountResponseMultiError) AllErrors() []error { return m }

// ListCloudAccountResponseValidationError is the validation error returned by
// ListCloudAccountResponse.Validate if the designated constraints aren't met.
type ListCloudAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudAccountResponseValidationError) ErrorName() string {
	return "ListCloudAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudAccountResponseValidationError{}

// Validate checks the field values on CloudVPC with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudVPC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudVPC with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudVPCMultiError, or nil
// if none found.
func (m *CloudVPC) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudVPC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Region

	// no validation rules for RegionName

	// no validation rules for NetworkType

	// no validation rules for VpcID

	// no validation rules for VpcName

	// no validation rules for Available

	// no validation rules for Extra

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	// no validation rules for ReservedIPNum

	// no validation rules for BusinessID

	if all {
		switch v := interface{}(m.GetOverlay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudVPCValidationError{
					field:  "Overlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudVPCValidationError{
					field:  "Overlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverlay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudVPCValidationError{
				field:  "Overlay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUnderlay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudVPCValidationError{
					field:  "Underlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudVPCValidationError{
					field:  "Underlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnderlay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudVPCValidationError{
				field:  "Underlay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CloudVPCMultiError(errors)
	}

	return nil
}

// CloudVPCMultiError is an error wrapping multiple validation errors returned
// by CloudVPC.ValidateAll() if the designated constraints aren't met.
type CloudVPCMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudVPCMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudVPCMultiError) AllErrors() []error { return m }

// CloudVPCValidationError is the validation error returned by
// CloudVPC.Validate if the designated constraints aren't met.
type CloudVPCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudVPCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudVPCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudVPCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudVPCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudVPCValidationError) ErrorName() string { return "CloudVPCValidationError" }

// Error satisfies the builtin error interface
func (e CloudVPCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudVPC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudVPCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudVPCValidationError{}

// Validate checks the field values on Cidr with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Cidr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cidr with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CidrMultiError, or nil if none found.
func (m *Cidr) ValidateAll() error {
	return m.validate(true)
}

func (m *Cidr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCidrs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CidrValidationError{
						field:  fmt.Sprintf("Cidrs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CidrValidationError{
						field:  fmt.Sprintf("Cidrs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CidrValidationError{
					field:  fmt.Sprintf("Cidrs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReservedIPNum

	if len(errors) > 0 {
		return CidrMultiError(errors)
	}

	return nil
}

// CidrMultiError is an error wrapping multiple validation errors returned by
// Cidr.ValidateAll() if the designated constraints aren't met.
type CidrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CidrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CidrMultiError) AllErrors() []error { return m }

// CidrValidationError is the validation error returned by Cidr.Validate if the
// designated constraints aren't met.
type CidrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CidrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CidrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CidrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CidrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CidrValidationError) ErrorName() string { return "CidrValidationError" }

// Error satisfies the builtin error interface
func (e CidrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCidr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CidrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CidrValidationError{}

// Validate checks the field values on CidrState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CidrState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CidrState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CidrStateMultiError, or nil
// if none found.
func (m *CidrState) ValidateAll() error {
	return m.validate(true)
}

func (m *CidrState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cidr

	// no validation rules for Block

	if len(errors) > 0 {
		return CidrStateMultiError(errors)
	}

	return nil
}

// CidrStateMultiError is an error wrapping multiple validation errors returned
// by CidrState.ValidateAll() if the designated constraints aren't met.
type CidrStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CidrStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CidrStateMultiError) AllErrors() []error { return m }

// CidrStateValidationError is the validation error returned by
// CidrState.Validate if the designated constraints aren't met.
type CidrStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CidrStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CidrStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CidrStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CidrStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CidrStateValidationError) ErrorName() string { return "CidrStateValidationError" }

// Error satisfies the builtin error interface
func (e CidrStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCidrState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CidrStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CidrStateValidationError{}

// Validate checks the field values on CreateCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudVPCRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudVPCRequestMultiError, or nil if none found.
func (m *CreateCloudVPCRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudVPCRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateCloudVPCRequest_NetworkType_InLookup[m.GetNetworkType()]; !ok {
		err := CreateCloudVPCRequestValidationError{
			field:  "NetworkType",
			reason: "value must be in list [overlay underlay]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "Region",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_Region_Pattern.MatchString(m.GetRegion()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RegionName

	if l := utf8.RuneCountInString(m.GetVpcName()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "VpcName",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_VpcName_Pattern.MatchString(m.GetVpcName()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "VpcName",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVpcID()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudVPCRequest_VpcID_Pattern.MatchString(m.GetVpcID()) {
		err := CreateCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateCloudVPCRequest_Available_InLookup[m.GetAvailable()]; !ok {
		err := CreateCloudVPCRequestValidationError{
			field:  "Available",
			reason: "value must be in list [true false]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 100 {
		err := CreateCloudVPCRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ReservedIPNum

	// no validation rules for BusinessID

	if all {
		switch v := interface{}(m.GetOverlay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudVPCRequestValidationError{
					field:  "Overlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudVPCRequestValidationError{
					field:  "Overlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverlay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudVPCRequestValidationError{
				field:  "Overlay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUnderlay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudVPCRequestValidationError{
					field:  "Underlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudVPCRequestValidationError{
					field:  "Underlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnderlay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudVPCRequestValidationError{
				field:  "Underlay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCloudVPCRequestMultiError(errors)
	}

	return nil
}

// CreateCloudVPCRequestMultiError is an error wrapping multiple validation
// errors returned by CreateCloudVPCRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateCloudVPCRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudVPCRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudVPCRequestMultiError) AllErrors() []error { return m }

// CreateCloudVPCRequestValidationError is the validation error returned by
// CreateCloudVPCRequest.Validate if the designated constraints aren't met.
type CreateCloudVPCRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudVPCRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudVPCRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudVPCRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudVPCRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudVPCRequestValidationError) ErrorName() string {
	return "CreateCloudVPCRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudVPCRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudVPCRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudVPCRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudVPCRequestValidationError{}

var _CreateCloudVPCRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudVPCRequest_NetworkType_InLookup = map[string]struct{}{
	"overlay":  {},
	"underlay": {},
}

var _CreateCloudVPCRequest_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudVPCRequest_VpcName_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudVPCRequest_VpcID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateCloudVPCRequest_Available_InLookup = map[string]struct{}{
	"true":  {},
	"false": {},
}

// Validate checks the field values on CreateCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudVPCResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudVPCResponseMultiError, or nil if none found.
func (m *CreateCloudVPCResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudVPCResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateCloudVPCResponseMultiError(errors)
	}

	return nil
}

// CreateCloudVPCResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCloudVPCResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCloudVPCResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudVPCResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudVPCResponseMultiError) AllErrors() []error { return m }

// CreateCloudVPCResponseValidationError is the validation error returned by
// CreateCloudVPCResponse.Validate if the designated constraints aren't met.
type CreateCloudVPCResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudVPCResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudVPCResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudVPCResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudVPCResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudVPCResponseValidationError) ErrorName() string {
	return "CreateCloudVPCResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudVPCResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudVPCResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudVPCResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudVPCResponseValidationError{}

// Validate checks the field values on UpdateCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudVPCRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudVPCRequestMultiError, or nil if none found.
func (m *UpdateCloudVPCRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudVPCRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 100 {
		err := UpdateCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudVPCRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := UpdateCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NetworkType

	// no validation rules for Region

	// no validation rules for RegionName

	// no validation rules for VpcName

	if l := utf8.RuneCountInString(m.GetVpcID()); l < 2 || l > 100 {
		err := UpdateCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateCloudVPCRequest_VpcID_Pattern.MatchString(m.GetVpcID()) {
		err := UpdateCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateCloudVPCRequest_Available_InLookup[m.GetAvailable()]; !ok {
		err := UpdateCloudVPCRequestValidationError{
			field:  "Available",
			reason: "value must be in list [ true false]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 100 {
		err := UpdateCloudVPCRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetReservedIPNum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudVPCRequestValidationError{
					field:  "ReservedIPNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudVPCRequestValidationError{
					field:  "ReservedIPNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReservedIPNum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudVPCRequestValidationError{
				field:  "ReservedIPNum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBusinessID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudVPCRequestValidationError{
					field:  "BusinessID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudVPCRequestValidationError{
					field:  "BusinessID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBusinessID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudVPCRequestValidationError{
				field:  "BusinessID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOverlay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudVPCRequestValidationError{
					field:  "Overlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudVPCRequestValidationError{
					field:  "Overlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverlay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudVPCRequestValidationError{
				field:  "Overlay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUnderlay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudVPCRequestValidationError{
					field:  "Underlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudVPCRequestValidationError{
					field:  "Underlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnderlay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudVPCRequestValidationError{
				field:  "Underlay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCloudVPCRequestMultiError(errors)
	}

	return nil
}

// UpdateCloudVPCRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateCloudVPCRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateCloudVPCRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudVPCRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudVPCRequestMultiError) AllErrors() []error { return m }

// UpdateCloudVPCRequestValidationError is the validation error returned by
// UpdateCloudVPCRequest.Validate if the designated constraints aren't met.
type UpdateCloudVPCRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudVPCRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudVPCRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudVPCRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudVPCRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudVPCRequestValidationError) ErrorName() string {
	return "UpdateCloudVPCRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudVPCRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudVPCRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudVPCRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudVPCRequestValidationError{}

var _UpdateCloudVPCRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateCloudVPCRequest_VpcID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateCloudVPCRequest_Available_InLookup = map[string]struct{}{
	"":      {},
	"true":  {},
	"false": {},
}

// Validate checks the field values on UpdateCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudVPCResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudVPCResponseMultiError, or nil if none found.
func (m *UpdateCloudVPCResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudVPCResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudVPCResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudVPCResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudVPCResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCloudVPCResponseMultiError(errors)
	}

	return nil
}

// UpdateCloudVPCResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateCloudVPCResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateCloudVPCResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudVPCResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudVPCResponseMultiError) AllErrors() []error { return m }

// UpdateCloudVPCResponseValidationError is the validation error returned by
// UpdateCloudVPCResponse.Validate if the designated constraints aren't met.
type UpdateCloudVPCResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudVPCResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudVPCResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudVPCResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudVPCResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudVPCResponseValidationError) ErrorName() string {
	return "UpdateCloudVPCResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudVPCResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudVPCResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudVPCResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudVPCResponseValidationError{}

// Validate checks the field values on DeleteCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudVPCRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudVPCRequestMultiError, or nil if none found.
func (m *DeleteCloudVPCRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudVPCRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 100 {
		err := DeleteCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudVPCRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := DeleteCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVpcID()); l < 2 || l > 100 {
		err := DeleteCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudVPCRequest_VpcID_Pattern.MatchString(m.GetVpcID()) {
		err := DeleteCloudVPCRequestValidationError{
			field:  "VpcID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteCloudVPCRequestMultiError(errors)
	}

	return nil
}

// DeleteCloudVPCRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCloudVPCRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteCloudVPCRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudVPCRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudVPCRequestMultiError) AllErrors() []error { return m }

// DeleteCloudVPCRequestValidationError is the validation error returned by
// DeleteCloudVPCRequest.Validate if the designated constraints aren't met.
type DeleteCloudVPCRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudVPCRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudVPCRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudVPCRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudVPCRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudVPCRequestValidationError) ErrorName() string {
	return "DeleteCloudVPCRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudVPCRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudVPCRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudVPCRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudVPCRequestValidationError{}

var _DeleteCloudVPCRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _DeleteCloudVPCRequest_VpcID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudVPCResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudVPCResponseMultiError, or nil if none found.
func (m *DeleteCloudVPCResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudVPCResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteCloudVPCResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteCloudVPCResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteCloudVPCResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteCloudVPCResponseMultiError(errors)
	}

	return nil
}

// DeleteCloudVPCResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCloudVPCResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteCloudVPCResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudVPCResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudVPCResponseMultiError) AllErrors() []error { return m }

// DeleteCloudVPCResponseValidationError is the validation error returned by
// DeleteCloudVPCResponse.Validate if the designated constraints aren't met.
type DeleteCloudVPCResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudVPCResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudVPCResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudVPCResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudVPCResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudVPCResponseValidationError) ErrorName() string {
	return "DeleteCloudVPCResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudVPCResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudVPCResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudVPCResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudVPCResponseValidationError{}

// Validate checks the field values on ListCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudVPCRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudVPCRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudVPCRequestMultiError, or nil if none found.
func (m *ListCloudVPCRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudVPCRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 20 {
		err := ListCloudVPCRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for VpcID

	if _, ok := _ListCloudVPCRequest_NetworkType_InLookup[m.GetNetworkType()]; !ok {
		err := ListCloudVPCRequestValidationError{
			field:  "NetworkType",
			reason: "value must be in list [overlay underlay]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for BusinessID

	if len(errors) > 0 {
		return ListCloudVPCRequestMultiError(errors)
	}

	return nil
}

// ListCloudVPCRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudVPCRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudVPCRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudVPCRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudVPCRequestMultiError) AllErrors() []error { return m }

// ListCloudVPCRequestValidationError is the validation error returned by
// ListCloudVPCRequest.Validate if the designated constraints aren't met.
type ListCloudVPCRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudVPCRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudVPCRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudVPCRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudVPCRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudVPCRequestValidationError) ErrorName() string {
	return "ListCloudVPCRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudVPCRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudVPCRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudVPCRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudVPCRequestValidationError{}

var _ListCloudVPCRequest_NetworkType_InLookup = map[string]struct{}{
	"overlay":  {},
	"underlay": {},
}

// Validate checks the field values on ListCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudVPCResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudVPCResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudVPCResponseMultiError, or nil if none found.
func (m *ListCloudVPCResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudVPCResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudVPCResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudVPCResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudVPCResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudVPCResponseMultiError(errors)
	}

	return nil
}

// ListCloudVPCResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudVPCResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudVPCResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudVPCResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudVPCResponseMultiError) AllErrors() []error { return m }

// ListCloudVPCResponseValidationError is the validation error returned by
// ListCloudVPCResponse.Validate if the designated constraints aren't met.
type ListCloudVPCResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudVPCResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudVPCResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudVPCResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudVPCResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudVPCResponseValidationError) ErrorName() string {
	return "ListCloudVPCResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudVPCResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudVPCResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudVPCResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudVPCResponseValidationError{}

// Validate checks the field values on CloudVPCResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudVPCResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudVPCResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudVPCRespMultiError, or
// nil if none found.
func (m *CloudVPCResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudVPCResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Region

	// no validation rules for RegionName

	// no validation rules for NetworkType

	// no validation rules for VpcID

	// no validation rules for VpcName

	// no validation rules for Available

	// no validation rules for Extra

	// no validation rules for ReservedIPNum

	// no validation rules for AvailableIPNum

	if all {
		switch v := interface{}(m.GetOverlay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudVPCRespValidationError{
					field:  "Overlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudVPCRespValidationError{
					field:  "Overlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverlay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudVPCRespValidationError{
				field:  "Overlay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUnderlay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudVPCRespValidationError{
					field:  "Underlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudVPCRespValidationError{
					field:  "Underlay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnderlay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudVPCRespValidationError{
				field:  "Underlay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BusinessID

	if len(errors) > 0 {
		return CloudVPCRespMultiError(errors)
	}

	return nil
}

// CloudVPCRespMultiError is an error wrapping multiple validation errors
// returned by CloudVPCResp.ValidateAll() if the designated constraints aren't met.
type CloudVPCRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudVPCRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudVPCRespMultiError) AllErrors() []error { return m }

// CloudVPCRespValidationError is the validation error returned by
// CloudVPCResp.Validate if the designated constraints aren't met.
type CloudVPCRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudVPCRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudVPCRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudVPCRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudVPCRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudVPCRespValidationError) ErrorName() string { return "CloudVPCRespValidationError" }

// Error satisfies the builtin error interface
func (e CloudVPCRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudVPCResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudVPCRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudVPCRespValidationError{}

// Validate checks the field values on CidrDetailInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CidrDetailInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CidrDetailInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CidrDetailInfoMultiError,
// or nil if none found.
func (m *CidrDetailInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CidrDetailInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCidrs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CidrDetailInfoValidationError{
						field:  fmt.Sprintf("Cidrs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CidrDetailInfoValidationError{
						field:  fmt.Sprintf("Cidrs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CidrDetailInfoValidationError{
					field:  fmt.Sprintf("Cidrs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReservedIPNum

	// no validation rules for AvailableIPNum

	if len(errors) > 0 {
		return CidrDetailInfoMultiError(errors)
	}

	return nil
}

// CidrDetailInfoMultiError is an error wrapping multiple validation errors
// returned by CidrDetailInfo.ValidateAll() if the designated constraints
// aren't met.
type CidrDetailInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CidrDetailInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CidrDetailInfoMultiError) AllErrors() []error { return m }

// CidrDetailInfoValidationError is the validation error returned by
// CidrDetailInfo.Validate if the designated constraints aren't met.
type CidrDetailInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CidrDetailInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CidrDetailInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CidrDetailInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CidrDetailInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CidrDetailInfoValidationError) ErrorName() string { return "CidrDetailInfoValidationError" }

// Error satisfies the builtin error interface
func (e CidrDetailInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCidrDetailInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CidrDetailInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CidrDetailInfoValidationError{}

// Validate checks the field values on ListCloudRegionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRegionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRegionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudRegionsRequestMultiError, or nil if none found.
func (m *ListCloudRegionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRegionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 20 {
		err := ListCloudRegionsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCloudRegionsRequestMultiError(errors)
	}

	return nil
}

// ListCloudRegionsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudRegionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudRegionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRegionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRegionsRequestMultiError) AllErrors() []error { return m }

// ListCloudRegionsRequestValidationError is the validation error returned by
// ListCloudRegionsRequest.Validate if the designated constraints aren't met.
type ListCloudRegionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRegionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRegionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRegionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRegionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRegionsRequestValidationError) ErrorName() string {
	return "ListCloudRegionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRegionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRegionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRegionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRegionsRequestValidationError{}

// Validate checks the field values on ListCloudRegionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRegionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRegionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudRegionsResponseMultiError, or nil if none found.
func (m *ListCloudRegionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRegionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudRegionsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudRegionsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudRegionsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudRegionsResponseMultiError(errors)
	}

	return nil
}

// ListCloudRegionsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudRegionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudRegionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRegionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRegionsResponseMultiError) AllErrors() []error { return m }

// ListCloudRegionsResponseValidationError is the validation error returned by
// ListCloudRegionsResponse.Validate if the designated constraints aren't met.
type ListCloudRegionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRegionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRegionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRegionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRegionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRegionsResponseValidationError) ErrorName() string {
	return "ListCloudRegionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRegionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRegionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRegionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRegionsResponseValidationError{}

// Validate checks the field values on CloudRegion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudRegion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudRegion with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudRegionMultiError, or
// nil if none found.
func (m *CloudRegion) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudRegion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for RegionName

	// no validation rules for Region

	if len(errors) > 0 {
		return CloudRegionMultiError(errors)
	}

	return nil
}

// CloudRegionMultiError is an error wrapping multiple validation errors
// returned by CloudRegion.ValidateAll() if the designated constraints aren't met.
type CloudRegionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudRegionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudRegionMultiError) AllErrors() []error { return m }

// CloudRegionValidationError is the validation error returned by
// CloudRegion.Validate if the designated constraints aren't met.
type CloudRegionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudRegionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudRegionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudRegionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudRegionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudRegionValidationError) ErrorName() string { return "CloudRegionValidationError" }

// Error satisfies the builtin error interface
func (e CloudRegionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudRegion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudRegionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudRegionValidationError{}

// Validate checks the field values on GetVPCCidrRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetVPCCidrRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVPCCidrRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVPCCidrRequestMultiError, or nil if none found.
func (m *GetVPCCidrRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVPCCidrRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VpcID

	if len(errors) > 0 {
		return GetVPCCidrRequestMultiError(errors)
	}

	return nil
}

// GetVPCCidrRequestMultiError is an error wrapping multiple validation errors
// returned by GetVPCCidrRequest.ValidateAll() if the designated constraints
// aren't met.
type GetVPCCidrRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVPCCidrRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVPCCidrRequestMultiError) AllErrors() []error { return m }

// GetVPCCidrRequestValidationError is the validation error returned by
// GetVPCCidrRequest.Validate if the designated constraints aren't met.
type GetVPCCidrRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVPCCidrRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVPCCidrRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVPCCidrRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVPCCidrRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVPCCidrRequestValidationError) ErrorName() string {
	return "GetVPCCidrRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetVPCCidrRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVPCCidrRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVPCCidrRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVPCCidrRequestValidationError{}

// Validate checks the field values on GetVPCCidrResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVPCCidrResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVPCCidrResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVPCCidrResponseMultiError, or nil if none found.
func (m *GetVPCCidrResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVPCCidrResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetVPCCidrResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetVPCCidrResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetVPCCidrResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetVPCCidrResponseMultiError(errors)
	}

	return nil
}

// GetVPCCidrResponseMultiError is an error wrapping multiple validation errors
// returned by GetVPCCidrResponse.ValidateAll() if the designated constraints
// aren't met.
type GetVPCCidrResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVPCCidrResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVPCCidrResponseMultiError) AllErrors() []error { return m }

// GetVPCCidrResponseValidationError is the validation error returned by
// GetVPCCidrResponse.Validate if the designated constraints aren't met.
type GetVPCCidrResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVPCCidrResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVPCCidrResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVPCCidrResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVPCCidrResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVPCCidrResponseValidationError) ErrorName() string {
	return "GetVPCCidrResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetVPCCidrResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVPCCidrResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVPCCidrResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVPCCidrResponseValidationError{}

// Validate checks the field values on VPCCidr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VPCCidr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VPCCidr with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VPCCidrMultiError, or nil if none found.
func (m *VPCCidr) ValidateAll() error {
	return m.validate(true)
}

func (m *VPCCidr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Vpc

	// no validation rules for Cidr

	// no validation rules for IPNumber

	// no validation rules for Status

	if len(errors) > 0 {
		return VPCCidrMultiError(errors)
	}

	return nil
}

// VPCCidrMultiError is an error wrapping multiple validation errors returned
// by VPCCidr.ValidateAll() if the designated constraints aren't met.
type VPCCidrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VPCCidrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VPCCidrMultiError) AllErrors() []error { return m }

// VPCCidrValidationError is the validation error returned by VPCCidr.Validate
// if the designated constraints aren't met.
type VPCCidrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VPCCidrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VPCCidrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VPCCidrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VPCCidrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VPCCidrValidationError) ErrorName() string { return "VPCCidrValidationError" }

// Error satisfies the builtin error interface
func (e VPCCidrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVPCCidr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VPCCidrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VPCCidrValidationError{}

// Validate checks the field values on Cloud with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cloud) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cloud with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CloudMultiError, or nil if none found.
func (m *Cloud) ValidateAll() error {
	return m.validate(true)
}

func (m *Cloud) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Name

	// no validation rules for Editable

	{
		sorted_keys := make([]string, len(m.GetOpsPlugins()))
		i := 0
		for key := range m.GetOpsPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOpsPlugins()[key]
			_ = val

			// no validation rules for OpsPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CloudValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CloudValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CloudValidationError{
						field:  fmt.Sprintf("OpsPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraPlugins()))
		i := 0
		for key := range m.GetExtraPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraPlugins()[key]
			_ = val

			// no validation rules for ExtraPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CloudValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CloudValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CloudValidationError{
						field:  fmt.Sprintf("ExtraPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetCloudCredential()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudCredential()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "CloudCredential",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOsManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOsManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "OsManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "ClusterManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeGroupManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroupManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "NodeGroupManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	// no validation rules for CloudProvider

	// no validation rules for Config

	// no validation rules for Description

	// no validation rules for EngineType

	// no validation rules for Enable

	if all {
		switch v := interface{}(m.GetNetworkInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "NetworkInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudValidationError{
				field:  "ConfInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlatformInfo

	if len(errors) > 0 {
		return CloudMultiError(errors)
	}

	return nil
}

// CloudMultiError is an error wrapping multiple validation errors returned by
// Cloud.ValidateAll() if the designated constraints aren't met.
type CloudMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudMultiError) AllErrors() []error { return m }

// CloudValidationError is the validation error returned by Cloud.Validate if
// the designated constraints aren't met.
type CloudValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudValidationError) ErrorName() string { return "CloudValidationError" }

// Error satisfies the builtin error interface
func (e CloudValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloud.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudValidationError{}

// Validate checks the field values on CloudConfigInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudConfigInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudConfigInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudConfigInfoMultiError, or nil if none found.
func (m *CloudConfigInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudConfigInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudInternalEnable

	// no validation rules for CloudDomain

	// no validation rules for MachineDomain

	// no validation rules for DisableCreateCluster

	// no validation rules for DisableImportCluster

	// no validation rules for DisableNodeGroup

	// no validation rules for VpcDomain

	if len(errors) > 0 {
		return CloudConfigInfoMultiError(errors)
	}

	return nil
}

// CloudConfigInfoMultiError is an error wrapping multiple validation errors
// returned by CloudConfigInfo.ValidateAll() if the designated constraints
// aren't met.
type CloudConfigInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudConfigInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudConfigInfoMultiError) AllErrors() []error { return m }

// CloudConfigInfoValidationError is the validation error returned by
// CloudConfigInfo.Validate if the designated constraints aren't met.
type CloudConfigInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudConfigInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudConfigInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudConfigInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudConfigInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudConfigInfoValidationError) ErrorName() string { return "CloudConfigInfoValidationError" }

// Error satisfies the builtin error interface
func (e CloudConfigInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudConfigInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudConfigInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudConfigInfoValidationError{}

// Validate checks the field values on CloudNetworkInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudNetworkInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudNetworkInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudNetworkInfoMultiError, or nil if none found.
func (m *CloudNetworkInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudNetworkInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CloudNetworkInfoMultiError(errors)
	}

	return nil
}

// CloudNetworkInfoMultiError is an error wrapping multiple validation errors
// returned by CloudNetworkInfo.ValidateAll() if the designated constraints
// aren't met.
type CloudNetworkInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudNetworkInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudNetworkInfoMultiError) AllErrors() []error { return m }

// CloudNetworkInfoValidationError is the validation error returned by
// CloudNetworkInfo.Validate if the designated constraints aren't met.
type CloudNetworkInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudNetworkInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudNetworkInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudNetworkInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudNetworkInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudNetworkInfoValidationError) ErrorName() string { return "CloudNetworkInfoValidationError" }

// Error satisfies the builtin error interface
func (e CloudNetworkInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudNetworkInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudNetworkInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudNetworkInfoValidationError{}

// Validate checks the field values on NodeGroup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupMultiError, or nil
// if none found.
func (m *NodeGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeGroupID

	// no validation rules for Name

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := NodeGroupValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := NodeGroupValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_NodeGroup_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := NodeGroupValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for EnableAutoscale

	if all {
		switch v := interface{}(m.GetAutoScaling()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutoScaling()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "AutoScaling",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLaunchTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLaunchTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "LaunchTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	// no validation rules for Taints

	// no validation rules for NodeOS

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for ProjectID

	// no validation rules for Provider

	if _, ok := _NodeGroup_Status_InLookup[m.GetStatus()]; !ok {
		err := NodeGroupValidationError{
			field:  "Status",
			reason: "value must be in list [CREATING RUNNING DELETING FALURE INITIALIZATION DELETED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ConsumerID

	if m.GetNodeTemplate() == nil {
		err := NodeGroupValidationError{
			field:  "NodeTemplate",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNodeTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "NodeTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CloudNodeGroupID

	// no validation rules for Tags

	// no validation rules for NodeGroupType

	if all {
		switch v := interface{}(m.GetArea()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "Area",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupValidationError{
					field:  "Area",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArea()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupValidationError{
				field:  "Area",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExtraInfo

	if len(errors) > 0 {
		return NodeGroupMultiError(errors)
	}

	return nil
}

// NodeGroupMultiError is an error wrapping multiple validation errors returned
// by NodeGroup.ValidateAll() if the designated constraints aren't met.
type NodeGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupMultiError) AllErrors() []error { return m }

// NodeGroupValidationError is the validation error returned by
// NodeGroup.Validate if the designated constraints aren't met.
type NodeGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupValidationError) ErrorName() string { return "NodeGroupValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupValidationError{}

var _NodeGroup_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _NodeGroup_Status_InLookup = map[string]struct{}{
	"CREATING":       {},
	"RUNNING":        {},
	"DELETING":       {},
	"FALURE":         {},
	"INITIALIZATION": {},
	"DELETED":        {},
}

// Validate checks the field values on CloudArea with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudArea) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudArea with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudAreaMultiError, or nil
// if none found.
func (m *CloudArea) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudArea) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BkCloudID

	// no validation rules for BkCloudName

	if len(errors) > 0 {
		return CloudAreaMultiError(errors)
	}

	return nil
}

// CloudAreaMultiError is an error wrapping multiple validation errors returned
// by CloudArea.ValidateAll() if the designated constraints aren't met.
type CloudAreaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAreaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAreaMultiError) AllErrors() []error { return m }

// CloudAreaValidationError is the validation error returned by
// CloudArea.Validate if the designated constraints aren't met.
type CloudAreaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAreaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAreaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAreaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAreaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAreaValidationError) ErrorName() string { return "CloudAreaValidationError" }

// Error satisfies the builtin error interface
func (e CloudAreaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudArea.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAreaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAreaValidationError{}

// Validate checks the field values on AutoScalingGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AutoScalingGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoScalingGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutoScalingGroupMultiError, or nil if none found.
func (m *AutoScalingGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoScalingGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AutoScalingID

	// no validation rules for AutoScalingName

	if val := m.GetMinSize(); val < 0 || val > 1000 {
		err := AutoScalingGroupValidationError{
			field:  "MinSize",
			reason: "value must be inside range [0, 1000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxSize(); val < 0 || val > 1000 {
		err := AutoScalingGroupValidationError{
			field:  "MaxSize",
			reason: "value must be inside range [0, 1000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DesiredSize

	// no validation rules for VpcID

	// no validation rules for DefaultCooldown

	// no validation rules for RetryPolicy

	// no validation rules for MultiZoneSubnetPolicy

	// no validation rules for ReplaceUnhealthy

	// no validation rules for ScalingMode

	for idx, item := range m.GetTimeRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoScalingGroupValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoScalingGroupValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoScalingGroupValidationError{
					field:  fmt.Sprintf("TimeRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AutoUpgrade

	// no validation rules for NodeRole

	if len(errors) > 0 {
		return AutoScalingGroupMultiError(errors)
	}

	return nil
}

// AutoScalingGroupMultiError is an error wrapping multiple validation errors
// returned by AutoScalingGroup.ValidateAll() if the designated constraints
// aren't met.
type AutoScalingGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoScalingGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoScalingGroupMultiError) AllErrors() []error { return m }

// AutoScalingGroupValidationError is the validation error returned by
// AutoScalingGroup.Validate if the designated constraints aren't met.
type AutoScalingGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoScalingGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoScalingGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoScalingGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoScalingGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoScalingGroupValidationError) ErrorName() string { return "AutoScalingGroupValidationError" }

// Error satisfies the builtin error interface
func (e AutoScalingGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoScalingGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoScalingGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoScalingGroupValidationError{}

// Validate checks the field values on TimeRange with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeRange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeRangeMultiError, or nil
// if none found.
func (m *TimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 1024 {
		err := TimeRangeValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSchedule()); l < 2 || l > 1024 {
		err := TimeRangeValidationError{
			field:  "Schedule",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Zone

	// no validation rules for DesiredNum

	if len(errors) > 0 {
		return TimeRangeMultiError(errors)
	}

	return nil
}

// TimeRangeMultiError is an error wrapping multiple validation errors returned
// by TimeRange.ValidateAll() if the designated constraints aren't met.
type TimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeRangeMultiError) AllErrors() []error { return m }

// TimeRangeValidationError is the validation error returned by
// TimeRange.Validate if the designated constraints aren't met.
type TimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeRangeValidationError) ErrorName() string { return "TimeRangeValidationError" }

// Error satisfies the builtin error interface
func (e TimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeRangeValidationError{}

// Validate checks the field values on DataDisk with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataDisk) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataDisk with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataDiskMultiError, or nil
// if none found.
func (m *DataDisk) ValidateAll() error {
	return m.validate(true)
}

func (m *DataDisk) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DiskType

	// no validation rules for DiskSize

	if len(errors) > 0 {
		return DataDiskMultiError(errors)
	}

	return nil
}

// DataDiskMultiError is an error wrapping multiple validation errors returned
// by DataDisk.ValidateAll() if the designated constraints aren't met.
type DataDiskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataDiskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataDiskMultiError) AllErrors() []error { return m }

// DataDiskValidationError is the validation error returned by
// DataDisk.Validate if the designated constraints aren't met.
type DataDiskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataDiskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataDiskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataDiskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataDiskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataDiskValidationError) ErrorName() string { return "DataDiskValidationError" }

// Error satisfies the builtin error interface
func (e DataDiskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataDisk.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataDiskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataDiskValidationError{}

// Validate checks the field values on CloudDataDisk with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudDataDisk) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudDataDisk with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudDataDiskMultiError, or
// nil if none found.
func (m *CloudDataDisk) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudDataDisk) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DiskType

	// no validation rules for DiskSize

	// no validation rules for FileSystem

	// no validation rules for AutoFormatAndMount

	// no validation rules for MountTarget

	// no validation rules for DiskPartition

	if len(errors) > 0 {
		return CloudDataDiskMultiError(errors)
	}

	return nil
}

// CloudDataDiskMultiError is an error wrapping multiple validation errors
// returned by CloudDataDisk.ValidateAll() if the designated constraints
// aren't met.
type CloudDataDiskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudDataDiskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudDataDiskMultiError) AllErrors() []error { return m }

// CloudDataDiskValidationError is the validation error returned by
// CloudDataDisk.Validate if the designated constraints aren't met.
type CloudDataDiskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudDataDiskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudDataDiskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudDataDiskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudDataDiskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudDataDiskValidationError) ErrorName() string { return "CloudDataDiskValidationError" }

// Error satisfies the builtin error interface
func (e CloudDataDiskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudDataDisk.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudDataDiskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudDataDiskValidationError{}

// Validate checks the field values on InternetAccessible with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InternetAccessible) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InternetAccessible with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InternetAccessibleMultiError, or nil if none found.
func (m *InternetAccessible) ValidateAll() error {
	return m.validate(true)
}

func (m *InternetAccessible) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InternetChargeType

	// no validation rules for InternetMaxBandwidth

	// no validation rules for PublicIPAssigned

	// no validation rules for BandwidthPackageId

	if len(errors) > 0 {
		return InternetAccessibleMultiError(errors)
	}

	return nil
}

// InternetAccessibleMultiError is an error wrapping multiple validation errors
// returned by InternetAccessible.ValidateAll() if the designated constraints
// aren't met.
type InternetAccessibleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InternetAccessibleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InternetAccessibleMultiError) AllErrors() []error { return m }

// InternetAccessibleValidationError is the validation error returned by
// InternetAccessible.Validate if the designated constraints aren't met.
type InternetAccessibleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InternetAccessibleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InternetAccessibleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InternetAccessibleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InternetAccessibleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InternetAccessibleValidationError) ErrorName() string {
	return "InternetAccessibleValidationError"
}

// Error satisfies the builtin error interface
func (e InternetAccessibleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInternetAccessible.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InternetAccessibleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InternetAccessibleValidationError{}

// Validate checks the field values on InstanceTemplateConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceTemplateConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceTemplateConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceTemplateConfigMultiError, or nil if none found.
func (m *InstanceTemplateConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceTemplateConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for Zone

	// no validation rules for VpcID

	// no validation rules for SubnetID

	// no validation rules for ApplyNum

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for InstanceType

	if _, ok := _InstanceTemplateConfig_InstanceChargeType_InLookup[m.GetInstanceChargeType()]; !ok {
		err := InstanceTemplateConfigValidationError{
			field:  "InstanceChargeType",
			reason: "value must be in list [PREPAID POSTPAID_BY_HOUR SPOTPAID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSystemDisk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSystemDisk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTemplateConfigValidationError{
				field:  "SystemDisk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTemplateConfigValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTemplateConfigValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTemplateConfigValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetImageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "ImageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "ImageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTemplateConfigValidationError{
				field:  "ImageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InitLoginPassword

	// no validation rules for IsSecurityService

	// no validation rules for IsMonitorService

	for idx, item := range m.GetCloudDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTemplateConfigValidationError{
						field:  fmt.Sprintf("CloudDataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTemplateConfigValidationError{
						field:  fmt.Sprintf("CloudDataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTemplateConfigValidationError{
					field:  fmt.Sprintf("CloudDataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for InitLoginUsername

	if all {
		switch v := interface{}(m.GetKeyPair()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyPair()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTemplateConfigValidationError{
				field:  "KeyPair",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DockerGraphPath

	// no validation rules for NodeRole

	if all {
		switch v := interface{}(m.GetCharge()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "Charge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "Charge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCharge()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTemplateConfigValidationError{
				field:  "Charge",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInternetAccess()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "InternetAccess",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTemplateConfigValidationError{
					field:  "InternetAccess",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInternetAccess()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTemplateConfigValidationError{
				field:  "InternetAccess",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstanceTemplateConfigMultiError(errors)
	}

	return nil
}

// InstanceTemplateConfigMultiError is an error wrapping multiple validation
// errors returned by InstanceTemplateConfig.ValidateAll() if the designated
// constraints aren't met.
type InstanceTemplateConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTemplateConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTemplateConfigMultiError) AllErrors() []error { return m }

// InstanceTemplateConfigValidationError is the validation error returned by
// InstanceTemplateConfig.Validate if the designated constraints aren't met.
type InstanceTemplateConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTemplateConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTemplateConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTemplateConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTemplateConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTemplateConfigValidationError) ErrorName() string {
	return "InstanceTemplateConfigValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceTemplateConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceTemplateConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTemplateConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTemplateConfigValidationError{}

var _InstanceTemplateConfig_InstanceChargeType_InLookup = map[string]struct{}{
	"PREPAID":          {},
	"POSTPAID_BY_HOUR": {},
	"SPOTPAID":         {},
}

// Validate checks the field values on InstanceChargePrepaid with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceChargePrepaid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceChargePrepaid with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceChargePrepaidMultiError, or nil if none found.
func (m *InstanceChargePrepaid) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceChargePrepaid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Period

	// no validation rules for RenewFlag

	if len(errors) > 0 {
		return InstanceChargePrepaidMultiError(errors)
	}

	return nil
}

// InstanceChargePrepaidMultiError is an error wrapping multiple validation
// errors returned by InstanceChargePrepaid.ValidateAll() if the designated
// constraints aren't met.
type InstanceChargePrepaidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceChargePrepaidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceChargePrepaidMultiError) AllErrors() []error { return m }

// InstanceChargePrepaidValidationError is the validation error returned by
// InstanceChargePrepaid.Validate if the designated constraints aren't met.
type InstanceChargePrepaidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceChargePrepaidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceChargePrepaidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceChargePrepaidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceChargePrepaidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceChargePrepaidValidationError) ErrorName() string {
	return "InstanceChargePrepaidValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceChargePrepaidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceChargePrepaid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceChargePrepaidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceChargePrepaidValidationError{}

// Validate checks the field values on LaunchConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LaunchConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LaunchConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LaunchConfigurationMultiError, or nil if none found.
func (m *LaunchConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *LaunchConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LaunchConfigurationID

	// no validation rules for LaunchConfigureName

	// no validation rules for ProjectID

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for InstanceType

	// no validation rules for InstanceChargeType

	if all {
		switch v := interface{}(m.GetSystemDisk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSystemDisk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LaunchConfigurationValidationError{
				field:  "SystemDisk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LaunchConfigurationValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LaunchConfigurationValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LaunchConfigurationValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetInternetAccess()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "InternetAccess",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "InternetAccess",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInternetAccess()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LaunchConfigurationValidationError{
				field:  "InternetAccess",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InitLoginPassword

	if all {
		switch v := interface{}(m.GetImageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "ImageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "ImageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LaunchConfigurationValidationError{
				field:  "ImageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsSecurityService

	// no validation rules for IsMonitorService

	// no validation rules for UserData

	// no validation rules for InitLoginUsername

	// no validation rules for Selector

	if all {
		switch v := interface{}(m.GetKeyPair()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyPair()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LaunchConfigurationValidationError{
				field:  "KeyPair",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCharge()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "Charge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LaunchConfigurationValidationError{
					field:  "Charge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCharge()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LaunchConfigurationValidationError{
				field:  "Charge",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LaunchConfigurationMultiError(errors)
	}

	return nil
}

// LaunchConfigurationMultiError is an error wrapping multiple validation
// errors returned by LaunchConfiguration.ValidateAll() if the designated
// constraints aren't met.
type LaunchConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LaunchConfigurationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LaunchConfigurationMultiError) AllErrors() []error { return m }

// LaunchConfigurationValidationError is the validation error returned by
// LaunchConfiguration.Validate if the designated constraints aren't met.
type LaunchConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LaunchConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LaunchConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LaunchConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LaunchConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LaunchConfigurationValidationError) ErrorName() string {
	return "LaunchConfigurationValidationError"
}

// Error satisfies the builtin error interface
func (e LaunchConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLaunchConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LaunchConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LaunchConfigurationValidationError{}

// Validate checks the field values on KeyInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KeyInfoMultiError, or nil if none found.
func (m *KeyInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for KeyID

	// no validation rules for KeySecret

	// no validation rules for KeyPublic

	if len(errors) > 0 {
		return KeyInfoMultiError(errors)
	}

	return nil
}

// KeyInfoMultiError is an error wrapping multiple validation errors returned
// by KeyInfo.ValidateAll() if the designated constraints aren't met.
type KeyInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyInfoMultiError) AllErrors() []error { return m }

// KeyInfoValidationError is the validation error returned by KeyInfo.Validate
// if the designated constraints aren't met.
type KeyInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyInfoValidationError) ErrorName() string { return "KeyInfoValidationError" }

// Error satisfies the builtin error interface
func (e KeyInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyInfoValidationError{}

// Validate checks the field values on ImageInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImageInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImageInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImageInfoMultiError, or nil
// if none found.
func (m *ImageInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ImageInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ImageID

	// no validation rules for ImageName

	// no validation rules for ImageType

	if len(errors) > 0 {
		return ImageInfoMultiError(errors)
	}

	return nil
}

// ImageInfoMultiError is an error wrapping multiple validation errors returned
// by ImageInfo.ValidateAll() if the designated constraints aren't met.
type ImageInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImageInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImageInfoMultiError) AllErrors() []error { return m }

// ImageInfoValidationError is the validation error returned by
// ImageInfo.Validate if the designated constraints aren't met.
type ImageInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImageInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImageInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImageInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImageInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImageInfoValidationError) ErrorName() string { return "ImageInfoValidationError" }

// Error satisfies the builtin error interface
func (e ImageInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImageInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImageInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImageInfoValidationError{}

// Validate checks the field values on ClusterAutoScalingOption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAutoScalingOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAutoScalingOption with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterAutoScalingOptionMultiError, or nil if none found.
func (m *ClusterAutoScalingOption) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAutoScalingOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsScaleDownEnable

	// no validation rules for Expander

	// no validation rules for MaxEmptyBulkDelete

	// no validation rules for ScaleDownDelay

	// no validation rules for ScaleDownUnneededTime

	// no validation rules for ScaleDownUtilizationThreahold

	// no validation rules for SkipNodesWithLocalStorage

	// no validation rules for SkipNodesWithSystemPods

	// no validation rules for IgnoreDaemonSetsUtilization

	// no validation rules for OkTotalUnreadyCount

	// no validation rules for MaxTotalUnreadyPercentage

	// no validation rules for ScaleDownUnreadyTime

	// no validation rules for UnregisteredNodeRemovalTime

	// no validation rules for ProjectID

	// no validation rules for ClusterID

	// no validation rules for Creator

	// no validation rules for CreateTime

	// no validation rules for Updater

	// no validation rules for UpdateTime

	// no validation rules for Provider

	// no validation rules for EnableAutoscale

	// no validation rules for BufferResourceRatio

	// no validation rules for MaxGracefulTerminationSec

	// no validation rules for ScanInterval

	// no validation rules for MaxNodeProvisionTime

	// no validation rules for ScaleUpFromZero

	// no validation rules for ScaleDownDelayAfterAdd

	// no validation rules for ScaleDownDelayAfterDelete

	// no validation rules for ScaleDownDelayAfterFailure

	// no validation rules for ScaleDownGpuUtilizationThreshold

	// no validation rules for Status

	// no validation rules for ErrorMessage

	// no validation rules for BufferResourceCpuRatio

	// no validation rules for BufferResourceMemRatio

	if all {
		switch v := interface{}(m.GetModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterAutoScalingOptionValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterAutoScalingOptionValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterAutoScalingOptionValidationError{
				field:  "Module",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebhook()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterAutoScalingOptionValidationError{
					field:  "Webhook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterAutoScalingOptionValidationError{
					field:  "Webhook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebhook()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterAutoScalingOptionValidationError{
				field:  "Webhook",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExpendablePodsPriorityCutoff

	if m.GetNewPodScaleUpDelay() < 0 {
		err := ClusterAutoScalingOptionValidationError{
			field:  "NewPodScaleUpDelay",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DevicePoolProvider

	if len(errors) > 0 {
		return ClusterAutoScalingOptionMultiError(errors)
	}

	return nil
}

// ClusterAutoScalingOptionMultiError is an error wrapping multiple validation
// errors returned by ClusterAutoScalingOption.ValidateAll() if the designated
// constraints aren't met.
type ClusterAutoScalingOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAutoScalingOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAutoScalingOptionMultiError) AllErrors() []error { return m }

// ClusterAutoScalingOptionValidationError is the validation error returned by
// ClusterAutoScalingOption.Validate if the designated constraints aren't met.
type ClusterAutoScalingOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAutoScalingOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAutoScalingOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAutoScalingOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAutoScalingOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAutoScalingOptionValidationError) ErrorName() string {
	return "ClusterAutoScalingOptionValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAutoScalingOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAutoScalingOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAutoScalingOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAutoScalingOptionValidationError{}

// Validate checks the field values on WebhookMode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebhookMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebhookMode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebhookModeMultiError, or
// nil if none found.
func (m *WebhookMode) ValidateAll() error {
	return m.validate(true)
}

func (m *WebhookMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mode

	// no validation rules for Server

	// no validation rules for Token

	if len(errors) > 0 {
		return WebhookModeMultiError(errors)
	}

	return nil
}

// WebhookModeMultiError is an error wrapping multiple validation errors
// returned by WebhookMode.ValidateAll() if the designated constraints aren't met.
type WebhookModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebhookModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebhookModeMultiError) AllErrors() []error { return m }

// WebhookModeValidationError is the validation error returned by
// WebhookMode.Validate if the designated constraints aren't met.
type WebhookModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebhookModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebhookModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebhookModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebhookModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebhookModeValidationError) ErrorName() string { return "WebhookModeValidationError" }

// Error satisfies the builtin error interface
func (e WebhookModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebhookMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebhookModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebhookModeValidationError{}

// Validate checks the field values on Taint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Taint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Taint with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaintMultiError, or nil if none found.
func (m *Taint) ValidateAll() error {
	return m.validate(true)
}

func (m *Taint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	// no validation rules for Effect

	if len(errors) > 0 {
		return TaintMultiError(errors)
	}

	return nil
}

// TaintMultiError is an error wrapping multiple validation errors returned by
// Taint.ValidateAll() if the designated constraints aren't met.
type TaintMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaintMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaintMultiError) AllErrors() []error { return m }

// TaintValidationError is the validation error returned by Taint.Validate if
// the designated constraints aren't met.
type TaintValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaintValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaintValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaintValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaintValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaintValidationError) ErrorName() string { return "TaintValidationError" }

// Error satisfies the builtin error interface
func (e TaintValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaintValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaintValidationError{}

// Validate checks the field values on NodeTemplate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeTemplateMultiError, or
// nil if none found.
func (m *NodeTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeTemplateID

	// no validation rules for Name

	// no validation rules for ProjectID

	// no validation rules for Labels

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeTemplateValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DockerGraphPath

	// no validation rules for MountTarget

	// no validation rules for UserScript

	// no validation rules for UnSchedulable

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeTemplateValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeTemplateValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtraArgs

	// no validation rules for PreStartUserScript

	if all {
		switch v := interface{}(m.GetBcsScaleOutAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "BcsScaleOutAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "BcsScaleOutAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBcsScaleOutAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "BcsScaleOutAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBcsScaleInAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "BcsScaleInAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "BcsScaleInAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBcsScaleInAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "BcsScaleInAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleOutExtraAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "ScaleOutExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "ScaleOutExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleOutExtraAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "ScaleOutExtraAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleInExtraAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "ScaleInExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "ScaleInExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleInExtraAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "ScaleInExtraAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NodeOS

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "Runtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeTemplateValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeTemplateValidationError{
				field:  "Module",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ScaleInPreScript

	// no validation rules for ScaleInPostScript

	// no validation rules for Annotations

	// no validation rules for MaxPodsPerNode

	// no validation rules for SkipSystemInit

	// no validation rules for AllowSkipScaleOutWhenFailed

	// no validation rules for AllowSkipScaleInWhenFailed

	if len(errors) > 0 {
		return NodeTemplateMultiError(errors)
	}

	return nil
}

// NodeTemplateMultiError is an error wrapping multiple validation errors
// returned by NodeTemplate.ValidateAll() if the designated constraints aren't met.
type NodeTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeTemplateMultiError) AllErrors() []error { return m }

// NodeTemplateValidationError is the validation error returned by
// NodeTemplate.Validate if the designated constraints aren't met.
type NodeTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeTemplateValidationError) ErrorName() string { return "NodeTemplateValidationError" }

// Error satisfies the builtin error interface
func (e NodeTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeTemplateValidationError{}

// Validate checks the field values on ClusterModule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterModule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterModuleMultiError, or
// nil if none found.
func (m *ClusterModule) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MasterModuleID

	// no validation rules for MasterModuleName

	// no validation rules for WorkerModuleID

	// no validation rules for WorkerModuleName

	if len(errors) > 0 {
		return ClusterModuleMultiError(errors)
	}

	return nil
}

// ClusterModuleMultiError is an error wrapping multiple validation errors
// returned by ClusterModule.ValidateAll() if the designated constraints
// aren't met.
type ClusterModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterModuleMultiError) AllErrors() []error { return m }

// ClusterModuleValidationError is the validation error returned by
// ClusterModule.Validate if the designated constraints aren't met.
type ClusterModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterModuleValidationError) ErrorName() string { return "ClusterModuleValidationError" }

// Error satisfies the builtin error interface
func (e ClusterModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterModuleValidationError{}

// Validate checks the field values on ModuleInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModuleInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModuleInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModuleInfoMultiError, or
// nil if none found.
func (m *ModuleInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ModuleInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScaleOutModuleID

	// no validation rules for ScaleInModuleID

	// no validation rules for ScaleOutBizID

	// no validation rules for ScaleInBizID

	// no validation rules for ScaleOutModuleName

	// no validation rules for ScaleInModuleName

	if len(errors) > 0 {
		return ModuleInfoMultiError(errors)
	}

	return nil
}

// ModuleInfoMultiError is an error wrapping multiple validation errors
// returned by ModuleInfo.ValidateAll() if the designated constraints aren't met.
type ModuleInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModuleInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModuleInfoMultiError) AllErrors() []error { return m }

// ModuleInfoValidationError is the validation error returned by
// ModuleInfo.Validate if the designated constraints aren't met.
type ModuleInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModuleInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModuleInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModuleInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModuleInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModuleInfoValidationError) ErrorName() string { return "ModuleInfoValidationError" }

// Error satisfies the builtin error interface
func (e ModuleInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModuleInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModuleInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModuleInfoValidationError{}

// Validate checks the field values on RunTimeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunTimeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunTimeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunTimeInfoMultiError, or
// nil if none found.
func (m *RunTimeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RunTimeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContainerRuntime

	// no validation rules for RuntimeVersion

	if len(errors) > 0 {
		return RunTimeInfoMultiError(errors)
	}

	return nil
}

// RunTimeInfoMultiError is an error wrapping multiple validation errors
// returned by RunTimeInfo.ValidateAll() if the designated constraints aren't met.
type RunTimeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunTimeInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunTimeInfoMultiError) AllErrors() []error { return m }

// RunTimeInfoValidationError is the validation error returned by
// RunTimeInfo.Validate if the designated constraints aren't met.
type RunTimeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunTimeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunTimeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunTimeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunTimeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunTimeInfoValidationError) ErrorName() string { return "RunTimeInfoValidationError" }

// Error satisfies the builtin error interface
func (e RunTimeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunTimeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunTimeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunTimeInfoValidationError{}

// Validate checks the field values on CreateNodeTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeTemplateRequestMultiError, or nil if none found.
func (m *CreateNodeTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 2048 {
		err := CreateNodeTemplateRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 2048 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateNodeTemplateRequest_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := CreateNodeTemplateRequestValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CreateNodeTemplateRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Desc

	// no validation rules for Labels

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNodeTemplateRequestValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNodeTemplateRequestValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNodeTemplateRequestValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DockerGraphPath

	// no validation rules for MountTarget

	// no validation rules for UserScript

	// no validation rules for UnSchedulable

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNodeTemplateRequestValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNodeTemplateRequestValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNodeTemplateRequestValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtraArgs

	// no validation rules for PreStartUserScript

	if all {
		switch v := interface{}(m.GetScaleOutExtraAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "ScaleOutExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "ScaleOutExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleOutExtraAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeTemplateRequestValidationError{
				field:  "ScaleOutExtraAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleInExtraAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "ScaleInExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "ScaleInExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleInExtraAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeTemplateRequestValidationError{
				field:  "ScaleInExtraAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NodeOS

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 1024 {
		err := CreateNodeTemplateRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeTemplateRequestValidationError{
				field:  "Runtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeTemplateRequestValidationError{
				field:  "Module",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleInPreScript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "ScaleInPreScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "ScaleInPreScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleInPreScript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeTemplateRequestValidationError{
				field:  "ScaleInPreScript",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleInPostScript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "ScaleInPostScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "ScaleInPostScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleInPostScript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeTemplateRequestValidationError{
				field:  "ScaleInPostScript",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "Annotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeTemplateRequestValidationError{
					field:  "Annotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeTemplateRequestValidationError{
				field:  "Annotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNodeTemplateRequestMultiError(errors)
	}

	return nil
}

// CreateNodeTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by CreateNodeTemplateRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateNodeTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeTemplateRequestMultiError) AllErrors() []error { return m }

// CreateNodeTemplateRequestValidationError is the validation error returned by
// CreateNodeTemplateRequest.Validate if the designated constraints aren't met.
type CreateNodeTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeTemplateRequestValidationError) ErrorName() string {
	return "CreateNodeTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeTemplateRequestValidationError{}

var _CreateNodeTemplateRequest_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateNodeTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeTemplateResponseMultiError, or nil if none found.
func (m *CreateNodeTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeTemplateResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNodeTemplateResponseMultiError(errors)
	}

	return nil
}

// CreateNodeTemplateResponseMultiError is an error wrapping multiple
// validation errors returned by CreateNodeTemplateResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateNodeTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeTemplateResponseMultiError) AllErrors() []error { return m }

// CreateNodeTemplateResponseValidationError is the validation error returned
// by CreateNodeTemplateResponse.Validate if the designated constraints aren't met.
type CreateNodeTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeTemplateResponseValidationError) ErrorName() string {
	return "CreateNodeTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeTemplateResponseValidationError{}

// Validate checks the field values on UpdateNodeTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeTemplateRequestMultiError, or nil if none found.
func (m *UpdateNodeTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for NodeTemplateID

	// no validation rules for Name

	// no validation rules for Desc

	// no validation rules for Labels

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeTemplateRequestValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeTemplateRequestValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeTemplateRequestValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DockerGraphPath

	// no validation rules for MountTarget

	// no validation rules for UserScript

	if all {
		switch v := interface{}(m.GetUnSchedulable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "UnSchedulable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "UnSchedulable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnSchedulable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateRequestValidationError{
				field:  "UnSchedulable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeTemplateRequestValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeTemplateRequestValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeTemplateRequestValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtraArgs

	// no validation rules for PreStartUserScript

	if all {
		switch v := interface{}(m.GetScaleOutExtraAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "ScaleOutExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "ScaleOutExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleOutExtraAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateRequestValidationError{
				field:  "ScaleOutExtraAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleInExtraAddons()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "ScaleInExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "ScaleInExtraAddons",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleInExtraAddons()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateRequestValidationError{
				field:  "ScaleInExtraAddons",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NodeOS

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 1024 {
		err := UpdateNodeTemplateRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateRequestValidationError{
				field:  "Runtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateRequestValidationError{
				field:  "Module",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleInPreScript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "ScaleInPreScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "ScaleInPreScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleInPreScript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateRequestValidationError{
				field:  "ScaleInPreScript",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleInPostScript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "ScaleInPostScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "ScaleInPostScript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleInPostScript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateRequestValidationError{
				field:  "ScaleInPostScript",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "Annotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateRequestValidationError{
					field:  "Annotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateRequestValidationError{
				field:  "Annotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeTemplateRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeTemplateRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateNodeTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeTemplateRequestMultiError) AllErrors() []error { return m }

// UpdateNodeTemplateRequestValidationError is the validation error returned by
// UpdateNodeTemplateRequest.Validate if the designated constraints aren't met.
type UpdateNodeTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeTemplateRequestValidationError) ErrorName() string {
	return "UpdateNodeTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeTemplateRequestValidationError{}

// Validate checks the field values on UpdateNodeTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeTemplateResponseMultiError, or nil if none found.
func (m *UpdateNodeTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTemplateResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeTemplateResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeTemplateResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateNodeTemplateResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateNodeTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeTemplateResponseMultiError) AllErrors() []error { return m }

// UpdateNodeTemplateResponseValidationError is the validation error returned
// by UpdateNodeTemplateResponse.Validate if the designated constraints aren't met.
type UpdateNodeTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeTemplateResponseValidationError) ErrorName() string {
	return "UpdateNodeTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeTemplateResponseValidationError{}

// Validate checks the field values on DeleteNodeTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodeTemplateRequestMultiError, or nil if none found.
func (m *DeleteNodeTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for NodeTemplateID

	if len(errors) > 0 {
		return DeleteNodeTemplateRequestMultiError(errors)
	}

	return nil
}

// DeleteNodeTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteNodeTemplateRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteNodeTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeTemplateRequestMultiError) AllErrors() []error { return m }

// DeleteNodeTemplateRequestValidationError is the validation error returned by
// DeleteNodeTemplateRequest.Validate if the designated constraints aren't met.
type DeleteNodeTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeTemplateRequestValidationError) ErrorName() string {
	return "DeleteNodeTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeTemplateRequestValidationError{}

// Validate checks the field values on DeleteNodeTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodeTemplateResponseMultiError, or nil if none found.
func (m *DeleteNodeTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodeTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodeTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodeTemplateResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNodeTemplateResponseMultiError(errors)
	}

	return nil
}

// DeleteNodeTemplateResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteNodeTemplateResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteNodeTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeTemplateResponseMultiError) AllErrors() []error { return m }

// DeleteNodeTemplateResponseValidationError is the validation error returned
// by DeleteNodeTemplateResponse.Validate if the designated constraints aren't met.
type DeleteNodeTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeTemplateResponseValidationError) ErrorName() string {
	return "DeleteNodeTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeTemplateResponseValidationError{}

// Validate checks the field values on GetNodeTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeTemplateRequestMultiError, or nil if none found.
func (m *GetNodeTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for NodeTemplateID

	if len(errors) > 0 {
		return GetNodeTemplateRequestMultiError(errors)
	}

	return nil
}

// GetNodeTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by GetNodeTemplateRequest.ValidateAll() if the designated
// constraints aren't met.
type GetNodeTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeTemplateRequestMultiError) AllErrors() []error { return m }

// GetNodeTemplateRequestValidationError is the validation error returned by
// GetNodeTemplateRequest.Validate if the designated constraints aren't met.
type GetNodeTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeTemplateRequestValidationError) ErrorName() string {
	return "GetNodeTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeTemplateRequestValidationError{}

// Validate checks the field values on GetNodeTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeTemplateResponseMultiError, or nil if none found.
func (m *GetNodeTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNodeTemplateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNodeTemplateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNodeTemplateResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNodeTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNodeTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNodeTemplateResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNodeTemplateResponseMultiError(errors)
	}

	return nil
}

// GetNodeTemplateResponseMultiError is an error wrapping multiple validation
// errors returned by GetNodeTemplateResponse.ValidateAll() if the designated
// constraints aren't met.
type GetNodeTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeTemplateResponseMultiError) AllErrors() []error { return m }

// GetNodeTemplateResponseValidationError is the validation error returned by
// GetNodeTemplateResponse.Validate if the designated constraints aren't met.
type GetNodeTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeTemplateResponseValidationError) ErrorName() string {
	return "GetNodeTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeTemplateResponseValidationError{}

// Validate checks the field values on ListNodeTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodeTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodeTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodeTemplateRequestMultiError, or nil if none found.
func (m *ListNodeTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodeTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for NodeTemplateID

	if len(errors) > 0 {
		return ListNodeTemplateRequestMultiError(errors)
	}

	return nil
}

// ListNodeTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by ListNodeTemplateRequest.ValidateAll() if the designated
// constraints aren't met.
type ListNodeTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodeTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodeTemplateRequestMultiError) AllErrors() []error { return m }

// ListNodeTemplateRequestValidationError is the validation error returned by
// ListNodeTemplateRequest.Validate if the designated constraints aren't met.
type ListNodeTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodeTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodeTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodeTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodeTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodeTemplateRequestValidationError) ErrorName() string {
	return "ListNodeTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodeTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodeTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodeTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodeTemplateRequestValidationError{}

// Validate checks the field values on ListNodeTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodeTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodeTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodeTemplateResponseMultiError, or nil if none found.
func (m *ListNodeTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodeTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodeTemplateResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodeTemplateResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodeTemplateResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNodeTemplateResponseMultiError(errors)
	}

	return nil
}

// ListNodeTemplateResponseMultiError is an error wrapping multiple validation
// errors returned by ListNodeTemplateResponse.ValidateAll() if the designated
// constraints aren't met.
type ListNodeTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodeTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodeTemplateResponseMultiError) AllErrors() []error { return m }

// ListNodeTemplateResponseValidationError is the validation error returned by
// ListNodeTemplateResponse.Validate if the designated constraints aren't met.
type ListNodeTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodeTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodeTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodeTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodeTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodeTemplateResponseValidationError) ErrorName() string {
	return "ListNodeTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodeTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodeTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodeTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodeTemplateResponseValidationError{}

// Validate checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Project) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProjectMultiError, or nil if none found.
func (m *Project) ValidateAll() error {
	return m.validate(true)
}

func (m *Project) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for Name

	// no validation rules for EnglishName

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for ProjectType

	// no validation rules for UseBKRes

	// no validation rules for Description

	// no validation rules for IsOffline

	// no validation rules for Kind

	// no validation rules for BusinessID

	// no validation rules for DeployType

	// no validation rules for BgID

	// no validation rules for BgName

	// no validation rules for DeptID

	// no validation rules for DeptName

	// no validation rules for CenterID

	// no validation rules for CenterName

	// no validation rules for IsSecret

	{
		sorted_keys := make([]string, len(m.GetCredentials()))
		i := 0
		for key := range m.GetCredentials() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCredentials()[key]
			_ = val

			// no validation rules for Credentials[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ProjectValidationError{
							field:  fmt.Sprintf("Credentials[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ProjectValidationError{
							field:  fmt.Sprintf("Credentials[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ProjectValidationError{
						field:  fmt.Sprintf("Credentials[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return ProjectMultiError(errors)
	}

	return nil
}

// ProjectMultiError is an error wrapping multiple validation errors returned
// by Project.ValidateAll() if the designated constraints aren't met.
type ProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectMultiError) AllErrors() []error { return m }

// ProjectValidationError is the validation error returned by Project.Validate
// if the designated constraints aren't met.
type ProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectValidationError) ErrorName() string { return "ProjectValidationError" }

// Error satisfies the builtin error interface
func (e ProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectValidationError{}

// Validate checks the field values on Task with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Task) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaskMultiError, or nil if none found.
func (m *Task) ValidateAll() error {
	return m.validate(true)
}

func (m *Task) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskID

	// no validation rules for TaskType

	if _, ok := _Task_Status_InLookup[m.GetStatus()]; !ok {
		err := TaskValidationError{
			field:  "Status",
			reason: "value must be in list [INITIALIZING RUNNING SUCCESS FAILURE TIMEOUT FORCETERMINATE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ExecutionTime

	// no validation rules for CurrentStep

	{
		sorted_keys := make([]string, len(m.GetSteps()))
		i := 0
		for key := range m.GetSteps() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSteps()[key]
			_ = val

			// no validation rules for Steps[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TaskValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TaskValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TaskValidationError{
						field:  fmt.Sprintf("Steps[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for ClusterID

	// no validation rules for ProjectID

	// no validation rules for Creator

	// no validation rules for LastUpdate

	// no validation rules for Updater

	// no validation rules for ForceTerminate

	// no validation rules for CommonParams

	// no validation rules for TaskName

	// no validation rules for NodeGroupID

	if len(errors) > 0 {
		return TaskMultiError(errors)
	}

	return nil
}

// TaskMultiError is an error wrapping multiple validation errors returned by
// Task.ValidateAll() if the designated constraints aren't met.
type TaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskMultiError) AllErrors() []error { return m }

// TaskValidationError is the validation error returned by Task.Validate if the
// designated constraints aren't met.
type TaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskValidationError) ErrorName() string { return "TaskValidationError" }

// Error satisfies the builtin error interface
func (e TaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskValidationError{}

var _Task_Status_InLookup = map[string]struct{}{
	"INITIALIZING":   {},
	"RUNNING":        {},
	"SUCCESS":        {},
	"FAILURE":        {},
	"TIMEOUT":        {},
	"FORCETERMINATE": {},
}

// Validate checks the field values on Step with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Step with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StepMultiError, or nil if none found.
func (m *Step) ValidateAll() error {
	return m.validate(true)
}

func (m *Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for System

	// no validation rules for Link

	// no validation rules for Params

	// no validation rules for Retry

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ExecutionTime

	if _, ok := _Step_Status_InLookup[m.GetStatus()]; !ok {
		err := StepValidationError{
			field:  "Status",
			reason: "value must be in list [NOTSTARTED RUNNING SUCCESS FAILURE TIMEOUT FORCETERMINATE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for LastUpdate

	// no validation rules for TaskMethod

	// no validation rules for TaskName

	// no validation rules for SkipOnFailed

	// no validation rules for Translate

	// no validation rules for AllowSkip

	if len(errors) > 0 {
		return StepMultiError(errors)
	}

	return nil
}

// StepMultiError is an error wrapping multiple validation errors returned by
// Step.ValidateAll() if the designated constraints aren't met.
type StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StepMultiError) AllErrors() []error { return m }

// StepValidationError is the validation error returned by Step.Validate if the
// designated constraints aren't met.
type StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StepValidationError) ErrorName() string { return "StepValidationError" }

// Error satisfies the builtin error interface
func (e StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StepValidationError{}

var _Step_Status_InLookup = map[string]struct{}{
	"NOTSTARTED":     {},
	"RUNNING":        {},
	"SUCCESS":        {},
	"FAILURE":        {},
	"TIMEOUT":        {},
	"FORCETERMINATE": {},
}

// Validate checks the field values on TkeCidr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TkeCidr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TkeCidr with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TkeCidrMultiError, or nil if none found.
func (m *TkeCidr) ValidateAll() error {
	return m.validate(true)
}

func (m *TkeCidr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VPC

	// no validation rules for CIDR

	// no validation rules for IPNumber

	// no validation rules for Status

	// no validation rules for Cluster

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return TkeCidrMultiError(errors)
	}

	return nil
}

// TkeCidrMultiError is an error wrapping multiple validation errors returned
// by TkeCidr.ValidateAll() if the designated constraints aren't met.
type TkeCidrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TkeCidrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TkeCidrMultiError) AllErrors() []error { return m }

// TkeCidrValidationError is the validation error returned by TkeCidr.Validate
// if the designated constraints aren't met.
type TkeCidrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TkeCidrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TkeCidrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TkeCidrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TkeCidrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TkeCidrValidationError) ErrorName() string { return "TkeCidrValidationError" }

// Error satisfies the builtin error interface
func (e TkeCidrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTkeCidr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TkeCidrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TkeCidrValidationError{}

// Validate checks the field values on TkeCidrCount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TkeCidrCount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TkeCidrCount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TkeCidrCountMultiError, or
// nil if none found.
func (m *TkeCidrCount) ValidateAll() error {
	return m.validate(true)
}

func (m *TkeCidrCount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	// no validation rules for VPC

	// no validation rules for IPNumber

	// no validation rules for Status

	if len(errors) > 0 {
		return TkeCidrCountMultiError(errors)
	}

	return nil
}

// TkeCidrCountMultiError is an error wrapping multiple validation errors
// returned by TkeCidrCount.ValidateAll() if the designated constraints aren't met.
type TkeCidrCountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TkeCidrCountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TkeCidrCountMultiError) AllErrors() []error { return m }

// TkeCidrCountValidationError is the validation error returned by
// TkeCidrCount.Validate if the designated constraints aren't met.
type TkeCidrCountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TkeCidrCountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TkeCidrCountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TkeCidrCountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TkeCidrCountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TkeCidrCountValidationError) ErrorName() string { return "TkeCidrCountValidationError" }

// Error satisfies the builtin error interface
func (e TkeCidrCountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTkeCidrCount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TkeCidrCountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TkeCidrCountValidationError{}

// Validate checks the field values on CreateClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterReqMultiError, or nil if none found.
func (m *CreateClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if l := utf8.RuneCountInString(m.GetClusterName()); l < 1 || l > 1024 {
		err := CreateClusterReqValidationError{
			field:  "ClusterName",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProvider()) > 32 {
		err := CreateClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 1 || l > 100 {
		err := CreateClusterReqValidationError{
			field:  "Region",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateClusterReq_Region_Pattern.MatchString(m.GetRegion()) {
		err := CreateClusterReqValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVpcID()) > 32 {
		err := CreateClusterReqValidationError{
			field:  "VpcID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := CreateClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateClusterReq_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := CreateClusterReqValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 100 {
		err := CreateClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateClusterReq_BusinessID_Pattern.MatchString(m.GetBusinessID()) {
		err := CreateClusterReqValidationError{
			field:  "BusinessID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateClusterReq_Environment_InLookup[m.GetEnvironment()]; !ok {
		err := CreateClusterReqValidationError{
			field:  "Environment",
			reason: "value must be in list [stag debug prod]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateClusterReq_EngineType_InLookup[m.GetEngineType()]; !ok {
		err := CreateClusterReqValidationError{
			field:  "EngineType",
			reason: "value must be in list [k8s mesos]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsExclusive

	if _, ok := _CreateClusterReq_ClusterType_InLookup[m.GetClusterType()]; !ok {
		err := CreateClusterReqValidationError{
			field:  "ClusterType",
			reason: "value must be in list [federation single]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FederationClusterID

	if len(m.GetLabels()) > 20 {
		err := CreateClusterReqValidationError{
			field:  "Labels",
			reason: "value must contain no more than 20 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateClusterReqValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OnlyCreateInfo

	{
		sorted_keys := make([]string, len(m.GetBcsAddons()))
		i := 0
		for key := range m.GetBcsAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetBcsAddons()[key]
			_ = val

			// no validation rules for BcsAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateClusterReqValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateClusterReqValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateClusterReqValidationError{
						field:  fmt.Sprintf("BcsAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraAddons()))
		i := 0
		for key := range m.GetExtraAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraAddons()[key]
			_ = val

			// no validation rules for ExtraAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateClusterReqValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateClusterReqValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateClusterReqValidationError{
						field:  fmt.Sprintf("ExtraAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for CloudID

	// no validation rules for ManageType

	if m.GetNetworkSettings() == nil {
		err := CreateClusterReqValidationError{
			field:  "NetworkSettings",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetNetworkSettings(); a != nil {

	}

	if m.GetClusterBasicSettings() == nil {
		err := CreateClusterReqValidationError{
			field:  "ClusterBasicSettings",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetClusterBasicSettings(); a != nil {

	}

	if all {
		switch v := interface{}(m.GetClusterAdvanceSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAdvanceSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterReqValidationError{
				field:  "ClusterAdvanceSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterReqValidationError{
				field:  "NodeSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SystemReinstall

	// no validation rules for InitLoginPassword

	// no validation rules for NetworkType

	// no validation rules for AutoGenerateMasterNodes

	for idx, item := range m.GetInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateClusterReqValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateClusterReqValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateClusterReqValidationError{
					field:  fmt.Sprintf("Instances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtraInfo

	// no validation rules for ModuleID

	// no validation rules for ExtraClusterID

	// no validation rules for IsCommonCluster

	// no validation rules for Description

	// no validation rules for ClusterCategory

	// no validation rules for IsShared

	// no validation rules for CloudAccountID

	// no validation rules for NodeTemplateID

	for idx, item := range m.GetNodeGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateClusterReqValidationError{
						field:  fmt.Sprintf("NodeGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateClusterReqValidationError{
						field:  fmt.Sprintf("NodeGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateClusterReqValidationError{
					field:  fmt.Sprintf("NodeGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsMixed

	if len(errors) > 0 {
		return CreateClusterReqMultiError(errors)
	}

	return nil
}

// CreateClusterReqMultiError is an error wrapping multiple validation errors
// returned by CreateClusterReq.ValidateAll() if the designated constraints
// aren't met.
type CreateClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterReqMultiError) AllErrors() []error { return m }

// CreateClusterReqValidationError is the validation error returned by
// CreateClusterReq.Validate if the designated constraints aren't met.
type CreateClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterReqValidationError) ErrorName() string { return "CreateClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterReqValidationError{}

var _CreateClusterReq_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateClusterReq_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateClusterReq_BusinessID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateClusterReq_Environment_InLookup = map[string]struct{}{
	"stag":  {},
	"debug": {},
	"prod":  {},
}

var _CreateClusterReq_EngineType_InLookup = map[string]struct{}{
	"k8s":   {},
	"mesos": {},
}

var _CreateClusterReq_ClusterType_InLookup = map[string]struct{}{
	"federation": {},
	"single":     {},
}

// Validate checks the field values on CreateClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterRespMultiError, or nil if none found.
func (m *CreateClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterRespValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateClusterRespMultiError(errors)
	}

	return nil
}

// CreateClusterRespMultiError is an error wrapping multiple validation errors
// returned by CreateClusterResp.ValidateAll() if the designated constraints
// aren't met.
type CreateClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterRespMultiError) AllErrors() []error { return m }

// CreateClusterRespValidationError is the validation error returned by
// CreateClusterResp.Validate if the designated constraints aren't met.
type CreateClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterRespValidationError) ErrorName() string {
	return "CreateClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterRespValidationError{}

// Validate checks the field values on AddSubnetToClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddSubnetToClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddSubnetToClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddSubnetToClusterReqMultiError, or nil if none found.
func (m *AddSubnetToClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddSubnetToClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := AddSubnetToClusterReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := AddSubnetToClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_AddSubnetToClusterReq_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := AddSubnetToClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubnet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddSubnetToClusterReqValidationError{
					field:  "Subnet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddSubnetToClusterReqValidationError{
					field:  "Subnet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubnet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddSubnetToClusterReqValidationError{
				field:  "Subnet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return AddSubnetToClusterReqMultiError(errors)
	}

	return nil
}

// AddSubnetToClusterReqMultiError is an error wrapping multiple validation
// errors returned by AddSubnetToClusterReq.ValidateAll() if the designated
// constraints aren't met.
type AddSubnetToClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddSubnetToClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddSubnetToClusterReqMultiError) AllErrors() []error { return m }

// AddSubnetToClusterReqValidationError is the validation error returned by
// AddSubnetToClusterReq.Validate if the designated constraints aren't met.
type AddSubnetToClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddSubnetToClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddSubnetToClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddSubnetToClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddSubnetToClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddSubnetToClusterReqValidationError) ErrorName() string {
	return "AddSubnetToClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e AddSubnetToClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddSubnetToClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddSubnetToClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddSubnetToClusterReqValidationError{}

var _AddSubnetToClusterReq_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on AddSubnetToClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddSubnetToClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddSubnetToClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddSubnetToClusterRespMultiError, or nil if none found.
func (m *AddSubnetToClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AddSubnetToClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddSubnetToClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddSubnetToClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddSubnetToClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddSubnetToClusterRespMultiError(errors)
	}

	return nil
}

// AddSubnetToClusterRespMultiError is an error wrapping multiple validation
// errors returned by AddSubnetToClusterResp.ValidateAll() if the designated
// constraints aren't met.
type AddSubnetToClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddSubnetToClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddSubnetToClusterRespMultiError) AllErrors() []error { return m }

// AddSubnetToClusterRespValidationError is the validation error returned by
// AddSubnetToClusterResp.Validate if the designated constraints aren't met.
type AddSubnetToClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddSubnetToClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddSubnetToClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddSubnetToClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddSubnetToClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddSubnetToClusterRespValidationError) ErrorName() string {
	return "AddSubnetToClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e AddSubnetToClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddSubnetToClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddSubnetToClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddSubnetToClusterRespValidationError{}

// Validate checks the field values on CreateVirtualClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateVirtualClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateVirtualClusterReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateVirtualClusterReqMultiError, or nil if none found.
func (m *CreateVirtualClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateVirtualClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if l := utf8.RuneCountInString(m.GetClusterName()); l < 1 || l > 1024 {
		err := CreateVirtualClusterReqValidationError{
			field:  "ClusterName",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProvider()) > 32 {
		err := CreateVirtualClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 1 || l > 100 {
		err := CreateVirtualClusterReqValidationError{
			field:  "Region",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateVirtualClusterReq_Region_Pattern.MatchString(m.GetRegion()) {
		err := CreateVirtualClusterReqValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVpcID()) > 32 {
		err := CreateVirtualClusterReqValidationError{
			field:  "VpcID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := CreateVirtualClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateVirtualClusterReq_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := CreateVirtualClusterReqValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 100 {
		err := CreateVirtualClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateVirtualClusterReq_BusinessID_Pattern.MatchString(m.GetBusinessID()) {
		err := CreateVirtualClusterReqValidationError{
			field:  "BusinessID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateVirtualClusterReq_Environment_InLookup[m.GetEnvironment()]; !ok {
		err := CreateVirtualClusterReqValidationError{
			field:  "Environment",
			reason: "value must be in list [stag debug prod]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateVirtualClusterReq_EngineType_InLookup[m.GetEngineType()]; !ok {
		err := CreateVirtualClusterReqValidationError{
			field:  "EngineType",
			reason: "value must be in list [k8s mesos]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsExclusive

	if _, ok := _CreateVirtualClusterReq_ClusterType_InLookup[m.GetClusterType()]; !ok {
		err := CreateVirtualClusterReqValidationError{
			field:  "ClusterType",
			reason: "value must be in list [federation single virtual]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for HostClusterID

	if _, ok := _CreateVirtualClusterReq_HostClusterNetwork_InLookup[m.GetHostClusterNetwork()]; !ok {
		err := CreateVirtualClusterReqValidationError{
			field:  "HostClusterNetwork",
			reason: "value must be in list [devnet idc ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetLabels()) > 20 {
		err := CreateVirtualClusterReqValidationError{
			field:  "Labels",
			reason: "value must contain no more than 20 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateVirtualClusterReqValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OnlyCreateInfo

	if all {
		switch v := interface{}(m.GetNetworkSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVirtualClusterReqValidationError{
				field:  "NetworkSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterBasicSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterBasicSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVirtualClusterReqValidationError{
				field:  "ClusterBasicSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterAdvanceSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAdvanceSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVirtualClusterReqValidationError{
				field:  "ClusterAdvanceSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVirtualClusterReqValidationError{
				field:  "NodeSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExtraInfo

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetNs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "Ns",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVirtualClusterReqValidationError{
					field:  "Ns",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVirtualClusterReqValidationError{
				field:  "Ns",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProjectCode

	if len(errors) > 0 {
		return CreateVirtualClusterReqMultiError(errors)
	}

	return nil
}

// CreateVirtualClusterReqMultiError is an error wrapping multiple validation
// errors returned by CreateVirtualClusterReq.ValidateAll() if the designated
// constraints aren't met.
type CreateVirtualClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateVirtualClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateVirtualClusterReqMultiError) AllErrors() []error { return m }

// CreateVirtualClusterReqValidationError is the validation error returned by
// CreateVirtualClusterReq.Validate if the designated constraints aren't met.
type CreateVirtualClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateVirtualClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateVirtualClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateVirtualClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateVirtualClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateVirtualClusterReqValidationError) ErrorName() string {
	return "CreateVirtualClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateVirtualClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateVirtualClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateVirtualClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateVirtualClusterReqValidationError{}

var _CreateVirtualClusterReq_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateVirtualClusterReq_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateVirtualClusterReq_BusinessID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateVirtualClusterReq_Environment_InLookup = map[string]struct{}{
	"stag":  {},
	"debug": {},
	"prod":  {},
}

var _CreateVirtualClusterReq_EngineType_InLookup = map[string]struct{}{
	"k8s":   {},
	"mesos": {},
}

var _CreateVirtualClusterReq_ClusterType_InLookup = map[string]struct{}{
	"federation": {},
	"single":     {},
	"virtual":    {},
}

var _CreateVirtualClusterReq_HostClusterNetwork_InLookup = map[string]struct{}{
	"devnet": {},
	"idc":    {},
	"":       {},
}

// Validate checks the field values on NamespaceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamespaceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamespaceInfoMultiError, or
// nil if none found.
func (m *NamespaceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Labels

	// no validation rules for Annotations

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamespaceInfoValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamespaceInfoValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamespaceInfoValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamespaceInfoMultiError(errors)
	}

	return nil
}

// NamespaceInfoMultiError is an error wrapping multiple validation errors
// returned by NamespaceInfo.ValidateAll() if the designated constraints
// aren't met.
type NamespaceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceInfoMultiError) AllErrors() []error { return m }

// NamespaceInfoValidationError is the validation error returned by
// NamespaceInfo.Validate if the designated constraints aren't met.
type NamespaceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceInfoValidationError) ErrorName() string { return "NamespaceInfoValidationError" }

// Error satisfies the builtin error interface
func (e NamespaceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceInfoValidationError{}

// Validate checks the field values on NamespaceQuota with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamespaceQuota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceQuota with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamespaceQuotaMultiError,
// or nil if none found.
func (m *NamespaceQuota) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceQuota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CpuRequests

	// no validation rules for CpuLimits

	// no validation rules for MemoryRequests

	// no validation rules for MemoryLimits

	if len(errors) > 0 {
		return NamespaceQuotaMultiError(errors)
	}

	return nil
}

// NamespaceQuotaMultiError is an error wrapping multiple validation errors
// returned by NamespaceQuota.ValidateAll() if the designated constraints
// aren't met.
type NamespaceQuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceQuotaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceQuotaMultiError) AllErrors() []error { return m }

// NamespaceQuotaValidationError is the validation error returned by
// NamespaceQuota.Validate if the designated constraints aren't met.
type NamespaceQuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceQuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceQuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceQuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceQuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceQuotaValidationError) ErrorName() string { return "NamespaceQuotaValidationError" }

// Error satisfies the builtin error interface
func (e NamespaceQuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceQuota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceQuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceQuotaValidationError{}

// Validate checks the field values on CreateVirtualClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateVirtualClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateVirtualClusterResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateVirtualClusterRespMultiError, or nil if none found.
func (m *CreateVirtualClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateVirtualClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVirtualClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVirtualClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVirtualClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVirtualClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVirtualClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVirtualClusterRespValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVirtualClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVirtualClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVirtualClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateVirtualClusterRespMultiError(errors)
	}

	return nil
}

// CreateVirtualClusterRespMultiError is an error wrapping multiple validation
// errors returned by CreateVirtualClusterResp.ValidateAll() if the designated
// constraints aren't met.
type CreateVirtualClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateVirtualClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateVirtualClusterRespMultiError) AllErrors() []error { return m }

// CreateVirtualClusterRespValidationError is the validation error returned by
// CreateVirtualClusterResp.Validate if the designated constraints aren't met.
type CreateVirtualClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateVirtualClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateVirtualClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateVirtualClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateVirtualClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateVirtualClusterRespValidationError) ErrorName() string {
	return "CreateVirtualClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateVirtualClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateVirtualClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateVirtualClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateVirtualClusterRespValidationError{}

// Validate checks the field values on KubeConfigReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KubeConfigReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubeConfigReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KubeConfigReqMultiError, or
// nil if none found.
func (m *KubeConfigReq) ValidateAll() error {
	return m.validate(true)
}

func (m *KubeConfigReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKubeConfig()) < 1 {
		err := KubeConfigReqValidationError{
			field:  "KubeConfig",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return KubeConfigReqMultiError(errors)
	}

	return nil
}

// KubeConfigReqMultiError is an error wrapping multiple validation errors
// returned by KubeConfigReq.ValidateAll() if the designated constraints
// aren't met.
type KubeConfigReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubeConfigReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubeConfigReqMultiError) AllErrors() []error { return m }

// KubeConfigReqValidationError is the validation error returned by
// KubeConfigReq.Validate if the designated constraints aren't met.
type KubeConfigReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubeConfigReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubeConfigReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubeConfigReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubeConfigReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubeConfigReqValidationError) ErrorName() string { return "KubeConfigReqValidationError" }

// Error satisfies the builtin error interface
func (e KubeConfigReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubeConfigReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubeConfigReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubeConfigReqValidationError{}

// Validate checks the field values on KubeConfigConnectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KubeConfigConnectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubeConfigConnectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KubeConfigConnectReqMultiError, or nil if none found.
func (m *KubeConfigConnectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *KubeConfigConnectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	// no validation rules for IsExtranet

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 1 || l > 1024 {
		err := KubeConfigConnectReqValidationError{
			field:  "CloudID",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountID()) > 1024 {
		err := KubeConfigConnectReqValidationError{
			field:  "AccountID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := KubeConfigConnectReqValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_KubeConfigConnectReq_Region_Pattern.MatchString(m.GetRegion()) {
		err := KubeConfigConnectReqValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceGroupName

	if len(errors) > 0 {
		return KubeConfigConnectReqMultiError(errors)
	}

	return nil
}

// KubeConfigConnectReqMultiError is an error wrapping multiple validation
// errors returned by KubeConfigConnectReq.ValidateAll() if the designated
// constraints aren't met.
type KubeConfigConnectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubeConfigConnectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubeConfigConnectReqMultiError) AllErrors() []error { return m }

// KubeConfigConnectReqValidationError is the validation error returned by
// KubeConfigConnectReq.Validate if the designated constraints aren't met.
type KubeConfigConnectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubeConfigConnectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubeConfigConnectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubeConfigConnectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubeConfigConnectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubeConfigConnectReqValidationError) ErrorName() string {
	return "KubeConfigConnectReqValidationError"
}

// Error satisfies the builtin error interface
func (e KubeConfigConnectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubeConfigConnectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubeConfigConnectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubeConfigConnectReqValidationError{}

var _KubeConfigConnectReq_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on KubeConfigResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KubeConfigResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubeConfigResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KubeConfigRespMultiError,
// or nil if none found.
func (m *KubeConfigResp) ValidateAll() error {
	return m.validate(true)
}

func (m *KubeConfigResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return KubeConfigRespMultiError(errors)
	}

	return nil
}

// KubeConfigRespMultiError is an error wrapping multiple validation errors
// returned by KubeConfigResp.ValidateAll() if the designated constraints
// aren't met.
type KubeConfigRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubeConfigRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubeConfigRespMultiError) AllErrors() []error { return m }

// KubeConfigRespValidationError is the validation error returned by
// KubeConfigResp.Validate if the designated constraints aren't met.
type KubeConfigRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubeConfigRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubeConfigRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubeConfigRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubeConfigRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubeConfigRespValidationError) ErrorName() string { return "KubeConfigRespValidationError" }

// Error satisfies the builtin error interface
func (e KubeConfigRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubeConfigResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubeConfigRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubeConfigRespValidationError{}

// Validate checks the field values on KubeConfigConnectResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KubeConfigConnectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubeConfigConnectResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KubeConfigConnectRespMultiError, or nil if none found.
func (m *KubeConfigConnectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *KubeConfigConnectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return KubeConfigConnectRespMultiError(errors)
	}

	return nil
}

// KubeConfigConnectRespMultiError is an error wrapping multiple validation
// errors returned by KubeConfigConnectResp.ValidateAll() if the designated
// constraints aren't met.
type KubeConfigConnectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubeConfigConnectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubeConfigConnectRespMultiError) AllErrors() []error { return m }

// KubeConfigConnectRespValidationError is the validation error returned by
// KubeConfigConnectResp.Validate if the designated constraints aren't met.
type KubeConfigConnectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubeConfigConnectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubeConfigConnectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubeConfigConnectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubeConfigConnectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubeConfigConnectRespValidationError) ErrorName() string {
	return "KubeConfigConnectRespValidationError"
}

// Error satisfies the builtin error interface
func (e KubeConfigConnectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubeConfigConnectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubeConfigConnectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubeConfigConnectRespValidationError{}

// Validate checks the field values on ImportCloudMode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportCloudMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportCloudMode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportCloudModeMultiError, or nil if none found.
func (m *ImportCloudMode) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportCloudMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for KubeConfig

	// no validation rules for Inter

	// no validation rules for ResourceGroup

	if len(errors) > 0 {
		return ImportCloudModeMultiError(errors)
	}

	return nil
}

// ImportCloudModeMultiError is an error wrapping multiple validation errors
// returned by ImportCloudMode.ValidateAll() if the designated constraints
// aren't met.
type ImportCloudModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportCloudModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportCloudModeMultiError) AllErrors() []error { return m }

// ImportCloudModeValidationError is the validation error returned by
// ImportCloudMode.Validate if the designated constraints aren't met.
type ImportCloudModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportCloudModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportCloudModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportCloudModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportCloudModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportCloudModeValidationError) ErrorName() string { return "ImportCloudModeValidationError" }

// Error satisfies the builtin error interface
func (e ImportCloudModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportCloudMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportCloudModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportCloudModeValidationError{}

// Validate checks the field values on ImportClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportClusterReqMultiError, or nil if none found.
func (m *ImportClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if l := utf8.RuneCountInString(m.GetClusterName()); l < 1 || l > 1024 {
		err := ImportClusterReqValidationError{
			field:  "ClusterName",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	if l := utf8.RuneCountInString(m.GetProvider()); l < 1 || l > 1024 {
		err := ImportClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := ImportClusterReqValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ImportClusterReq_Region_Pattern.MatchString(m.GetRegion()) {
		err := ImportClusterReqValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 100 {
		err := ImportClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ImportClusterReq_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := ImportClusterReqValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetBusinessID()); l < 1 || l > 100 {
		err := ImportClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ImportClusterReq_BusinessID_Pattern.MatchString(m.GetBusinessID()) {
		err := ImportClusterReqValidationError{
			field:  "BusinessID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _ImportClusterReq_Environment_InLookup[m.GetEnvironment()]; !ok {
		err := ImportClusterReqValidationError{
			field:  "Environment",
			reason: "value must be in list [stag debug prod]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _ImportClusterReq_EngineType_InLookup[m.GetEngineType()]; !ok {
		err := ImportClusterReqValidationError{
			field:  "EngineType",
			reason: "value must be in list [k8s mesos ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetIsExclusive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportClusterReqValidationError{
					field:  "IsExclusive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportClusterReqValidationError{
					field:  "IsExclusive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsExclusive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportClusterReqValidationError{
				field:  "IsExclusive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _ImportClusterReq_ClusterType_InLookup[m.GetClusterType()]; !ok {
		err := ImportClusterReqValidationError{
			field:  "ClusterType",
			reason: "value must be in list [federation single ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetLabels()) > 20 {
		err := ImportClusterReqValidationError{
			field:  "Labels",
			reason: "value must contain no more than 20 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 1 || l > 1024 {
		err := ImportClusterReqValidationError{
			field:  "Creator",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetCloudMode() == nil {
		err := ImportClusterReqValidationError{
			field:  "CloudMode",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetCloudMode(); a != nil {

	}

	// no validation rules for ManageType

	// no validation rules for NetworkType

	// no validation rules for ExtraInfo

	// no validation rules for ExtraClusterID

	// no validation rules for ClusterCategory

	// no validation rules for IsShared

	if utf8.RuneCountInString(m.GetVersion()) > 1024 {
		err := ImportClusterReqValidationError{
			field:  "Version",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountID()) > 1024 {
		err := ImportClusterReqValidationError{
			field:  "AccountID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetArea()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportClusterReqValidationError{
					field:  "Area",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportClusterReqValidationError{
					field:  "Area",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArea()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportClusterReqValidationError{
				field:  "Area",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ImportClusterReqMultiError(errors)
	}

	return nil
}

// ImportClusterReqMultiError is an error wrapping multiple validation errors
// returned by ImportClusterReq.ValidateAll() if the designated constraints
// aren't met.
type ImportClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportClusterReqMultiError) AllErrors() []error { return m }

// ImportClusterReqValidationError is the validation error returned by
// ImportClusterReq.Validate if the designated constraints aren't met.
type ImportClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportClusterReqValidationError) ErrorName() string { return "ImportClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e ImportClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportClusterReqValidationError{}

var _ImportClusterReq_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _ImportClusterReq_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _ImportClusterReq_BusinessID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _ImportClusterReq_Environment_InLookup = map[string]struct{}{
	"stag":  {},
	"debug": {},
	"prod":  {},
}

var _ImportClusterReq_EngineType_InLookup = map[string]struct{}{
	"k8s":   {},
	"mesos": {},
	"":      {},
}

var _ImportClusterReq_ClusterType_InLookup = map[string]struct{}{
	"federation": {},
	"single":     {},
	"":           {},
}

// Validate checks the field values on ImportClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportClusterRespMultiError, or nil if none found.
func (m *ImportClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ImportClusterRespMultiError(errors)
	}

	return nil
}

// ImportClusterRespMultiError is an error wrapping multiple validation errors
// returned by ImportClusterResp.ValidateAll() if the designated constraints
// aren't met.
type ImportClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportClusterRespMultiError) AllErrors() []error { return m }

// ImportClusterRespValidationError is the validation error returned by
// ImportClusterResp.Validate if the designated constraints aren't met.
type ImportClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportClusterRespValidationError) ErrorName() string {
	return "ImportClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e ImportClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportClusterRespValidationError{}

// Validate checks the field values on DeleteVirtualClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteVirtualClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteVirtualClusterReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteVirtualClusterReqMultiError, or nil if none found.
func (m *DeleteVirtualClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteVirtualClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := DeleteVirtualClusterReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := DeleteVirtualClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteVirtualClusterReq_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := DeleteVirtualClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OnlyDeleteInfo

	// no validation rules for Operator

	if len(errors) > 0 {
		return DeleteVirtualClusterReqMultiError(errors)
	}

	return nil
}

// DeleteVirtualClusterReqMultiError is an error wrapping multiple validation
// errors returned by DeleteVirtualClusterReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteVirtualClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteVirtualClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteVirtualClusterReqMultiError) AllErrors() []error { return m }

// DeleteVirtualClusterReqValidationError is the validation error returned by
// DeleteVirtualClusterReq.Validate if the designated constraints aren't met.
type DeleteVirtualClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteVirtualClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteVirtualClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteVirtualClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteVirtualClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteVirtualClusterReqValidationError) ErrorName() string {
	return "DeleteVirtualClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteVirtualClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteVirtualClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteVirtualClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteVirtualClusterReqValidationError{}

var _DeleteVirtualClusterReq_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteVirtualClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteVirtualClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteVirtualClusterResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteVirtualClusterRespMultiError, or nil if none found.
func (m *DeleteVirtualClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteVirtualClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteVirtualClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteVirtualClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteVirtualClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteVirtualClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteVirtualClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteVirtualClusterRespValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteVirtualClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteVirtualClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteVirtualClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteVirtualClusterRespMultiError(errors)
	}

	return nil
}

// DeleteVirtualClusterRespMultiError is an error wrapping multiple validation
// errors returned by DeleteVirtualClusterResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteVirtualClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteVirtualClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteVirtualClusterRespMultiError) AllErrors() []error { return m }

// DeleteVirtualClusterRespValidationError is the validation error returned by
// DeleteVirtualClusterResp.Validate if the designated constraints aren't met.
type DeleteVirtualClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteVirtualClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteVirtualClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteVirtualClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteVirtualClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteVirtualClusterRespValidationError) ErrorName() string {
	return "DeleteVirtualClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteVirtualClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteVirtualClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteVirtualClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteVirtualClusterRespValidationError{}

// Validate checks the field values on UpdateVirtualClusterQuotaReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateVirtualClusterQuotaReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateVirtualClusterQuotaReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateVirtualClusterQuotaReqMultiError, or nil if none found.
func (m *UpdateVirtualClusterQuotaReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateVirtualClusterQuotaReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := UpdateVirtualClusterQuotaReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := UpdateVirtualClusterQuotaReqValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateVirtualClusterQuotaReq_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := UpdateVirtualClusterQuotaReqValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateVirtualClusterQuotaReqValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateVirtualClusterQuotaReqValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateVirtualClusterQuotaReqValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetUpdater()) > 1024 {
		err := UpdateVirtualClusterQuotaReqValidationError{
			field:  "Updater",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateVirtualClusterQuotaReqMultiError(errors)
	}

	return nil
}

// UpdateVirtualClusterQuotaReqMultiError is an error wrapping multiple
// validation errors returned by UpdateVirtualClusterQuotaReq.ValidateAll() if
// the designated constraints aren't met.
type UpdateVirtualClusterQuotaReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateVirtualClusterQuotaReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateVirtualClusterQuotaReqMultiError) AllErrors() []error { return m }

// UpdateVirtualClusterQuotaReqValidationError is the validation error returned
// by UpdateVirtualClusterQuotaReq.Validate if the designated constraints
// aren't met.
type UpdateVirtualClusterQuotaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateVirtualClusterQuotaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateVirtualClusterQuotaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateVirtualClusterQuotaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateVirtualClusterQuotaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateVirtualClusterQuotaReqValidationError) ErrorName() string {
	return "UpdateVirtualClusterQuotaReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateVirtualClusterQuotaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateVirtualClusterQuotaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateVirtualClusterQuotaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateVirtualClusterQuotaReqValidationError{}

var _UpdateVirtualClusterQuotaReq_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateVirtualClusterQuotaResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateVirtualClusterQuotaResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateVirtualClusterQuotaResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateVirtualClusterQuotaRespMultiError, or nil if none found.
func (m *UpdateVirtualClusterQuotaResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateVirtualClusterQuotaResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateVirtualClusterQuotaRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateVirtualClusterQuotaRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateVirtualClusterQuotaRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateVirtualClusterQuotaRespMultiError(errors)
	}

	return nil
}

// UpdateVirtualClusterQuotaRespMultiError is an error wrapping multiple
// validation errors returned by UpdateVirtualClusterQuotaResp.ValidateAll()
// if the designated constraints aren't met.
type UpdateVirtualClusterQuotaRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateVirtualClusterQuotaRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateVirtualClusterQuotaRespMultiError) AllErrors() []error { return m }

// UpdateVirtualClusterQuotaRespValidationError is the validation error
// returned by UpdateVirtualClusterQuotaResp.Validate if the designated
// constraints aren't met.
type UpdateVirtualClusterQuotaRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateVirtualClusterQuotaRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateVirtualClusterQuotaRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateVirtualClusterQuotaRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateVirtualClusterQuotaRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateVirtualClusterQuotaRespValidationError) ErrorName() string {
	return "UpdateVirtualClusterQuotaRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateVirtualClusterQuotaRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateVirtualClusterQuotaResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateVirtualClusterQuotaRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateVirtualClusterQuotaRespValidationError{}

// Validate checks the field values on DeleteClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterReqMultiError, or nil if none found.
func (m *DeleteClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := DeleteClusterReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := DeleteClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteClusterReq_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := DeleteClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForced

	// no validation rules for InstanceDeleteMode

	// no validation rules for OnlyDeleteInfo

	// no validation rules for Operator

	// no validation rules for DeleteClusterRecord

	if len(errors) > 0 {
		return DeleteClusterReqMultiError(errors)
	}

	return nil
}

// DeleteClusterReqMultiError is an error wrapping multiple validation errors
// returned by DeleteClusterReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterReqMultiError) AllErrors() []error { return m }

// DeleteClusterReqValidationError is the validation error returned by
// DeleteClusterReq.Validate if the designated constraints aren't met.
type DeleteClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterReqValidationError) ErrorName() string { return "DeleteClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterReqValidationError{}

var _DeleteClusterReq_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterRespMultiError, or nil if none found.
func (m *DeleteClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteClusterRespValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteClusterRespMultiError(errors)
	}

	return nil
}

// DeleteClusterRespMultiError is an error wrapping multiple validation errors
// returned by DeleteClusterResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterRespMultiError) AllErrors() []error { return m }

// DeleteClusterRespValidationError is the validation error returned by
// DeleteClusterResp.Validate if the designated constraints aren't met.
type DeleteClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterRespValidationError) ErrorName() string {
	return "DeleteClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterRespValidationError{}

// Validate checks the field values on UpdateClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterReqMultiError, or nil if none found.
func (m *UpdateClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterID()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	if utf8.RuneCountInString(m.GetProvider()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	if utf8.RuneCountInString(m.GetVpcID()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "VpcID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Environment

	// no validation rules for EngineType

	if all {
		switch v := interface{}(m.GetIsExclusive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsExclusive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsExclusive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsExclusive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "IsExclusive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ClusterType

	// no validation rules for FederationClusterID

	if len(m.GetLabels()) > 20 {
		err := UpdateClusterReqValidationError{
			field:  "Labels",
			reason: "value must contain no more than 20 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUpdater()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "Updater",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateClusterReq_Status_InLookup[m.GetStatus()]; !ok {
		err := UpdateClusterReqValidationError{
			field:  "Status",
			reason: "value must be in list [CREATING RUNNING DELETING FAILURE INITIALIZATION DELETED ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetBcsAddons()))
		i := 0
		for key := range m.GetBcsAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetBcsAddons()[key]
			_ = val

			// no validation rules for BcsAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateClusterReqValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateClusterReqValidationError{
							field:  fmt.Sprintf("BcsAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateClusterReqValidationError{
						field:  fmt.Sprintf("BcsAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraAddons()))
		i := 0
		for key := range m.GetExtraAddons() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraAddons()[key]
			_ = val

			// no validation rules for ExtraAddons[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateClusterReqValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateClusterReqValidationError{
							field:  fmt.Sprintf("ExtraAddons[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateClusterReqValidationError{
						field:  fmt.Sprintf("ExtraAddons[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for SystemID

	// no validation rules for ManageType

	if all {
		switch v := interface{}(m.GetNetworkSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "NetworkSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "NetworkSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterBasicSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "ClusterBasicSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterBasicSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "ClusterBasicSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterAdvanceSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "ClusterAdvanceSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAdvanceSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "ClusterAdvanceSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "NodeSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "NodeSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NetworkType

	// no validation rules for ExtraInfo

	// no validation rules for ModuleID

	// no validation rules for ExtraClusterID

	if all {
		switch v := interface{}(m.GetIsCommonCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsCommonCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsCommonCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsCommonCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "IsCommonCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDescription()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "Description",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "Description",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDescription()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "Description",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ClusterCategory

	if all {
		switch v := interface{}(m.GetIsShared()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsShared",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsShared",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsShared()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "IsShared",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreateTime

	if utf8.RuneCountInString(m.GetCreator()) > 1024 {
		err := UpdateClusterReqValidationError{
			field:  "Creator",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ImportCategory

	// no validation rules for CloudAccountID

	if all {
		switch v := interface{}(m.GetIsMixed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsMixed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterReqValidationError{
					field:  "IsMixed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsMixed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterReqValidationError{
				field:  "IsMixed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateClusterReqMultiError(errors)
	}

	return nil
}

// UpdateClusterReqMultiError is an error wrapping multiple validation errors
// returned by UpdateClusterReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterReqMultiError) AllErrors() []error { return m }

// UpdateClusterReqValidationError is the validation error returned by
// UpdateClusterReq.Validate if the designated constraints aren't met.
type UpdateClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterReqValidationError) ErrorName() string { return "UpdateClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterReqValidationError{}

var _UpdateClusterReq_Status_InLookup = map[string]struct{}{
	"CREATING":       {},
	"RUNNING":        {},
	"DELETING":       {},
	"FAILURE":        {},
	"INITIALIZATION": {},
	"DELETED":        {},
	"":               {},
}

// Validate checks the field values on UpdateClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterRespMultiError, or nil if none found.
func (m *UpdateClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateClusterRespMultiError(errors)
	}

	return nil
}

// UpdateClusterRespMultiError is an error wrapping multiple validation errors
// returned by UpdateClusterResp.ValidateAll() if the designated constraints
// aren't met.
type UpdateClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterRespMultiError) AllErrors() []error { return m }

// UpdateClusterRespValidationError is the validation error returned by
// UpdateClusterResp.Validate if the designated constraints aren't met.
type UpdateClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterRespValidationError) ErrorName() string {
	return "UpdateClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterRespValidationError{}

// Validate checks the field values on RetryCreateClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RetryCreateClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryCreateClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryCreateClusterReqMultiError, or nil if none found.
func (m *RetryCreateClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryCreateClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if l := utf8.RuneCountInString(m.GetOperator()); l < 1 || l > 100 {
		err := RetryCreateClusterReqValidationError{
			field:  "Operator",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RetryCreateClusterReqMultiError(errors)
	}

	return nil
}

// RetryCreateClusterReqMultiError is an error wrapping multiple validation
// errors returned by RetryCreateClusterReq.ValidateAll() if the designated
// constraints aren't met.
type RetryCreateClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryCreateClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryCreateClusterReqMultiError) AllErrors() []error { return m }

// RetryCreateClusterReqValidationError is the validation error returned by
// RetryCreateClusterReq.Validate if the designated constraints aren't met.
type RetryCreateClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryCreateClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryCreateClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryCreateClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryCreateClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryCreateClusterReqValidationError) ErrorName() string {
	return "RetryCreateClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e RetryCreateClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryCreateClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryCreateClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryCreateClusterReqValidationError{}

// Validate checks the field values on RetryCreateClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RetryCreateClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryCreateClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryCreateClusterRespMultiError, or nil if none found.
func (m *RetryCreateClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryCreateClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryCreateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryCreateClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryCreateClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryCreateClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryCreateClusterRespValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryCreateClusterRespValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RetryCreateClusterRespMultiError(errors)
	}

	return nil
}

// RetryCreateClusterRespMultiError is an error wrapping multiple validation
// errors returned by RetryCreateClusterResp.ValidateAll() if the designated
// constraints aren't met.
type RetryCreateClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryCreateClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryCreateClusterRespMultiError) AllErrors() []error { return m }

// RetryCreateClusterRespValidationError is the validation error returned by
// RetryCreateClusterResp.Validate if the designated constraints aren't met.
type RetryCreateClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryCreateClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryCreateClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryCreateClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryCreateClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryCreateClusterRespValidationError) ErrorName() string {
	return "RetryCreateClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e RetryCreateClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryCreateClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryCreateClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryCreateClusterRespValidationError{}

// Validate checks the field values on GetClusterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetClusterReqMultiError, or
// nil if none found.
func (m *GetClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := GetClusterReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := GetClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetClusterReq_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := GetClusterReqValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CloudInfo

	if len(errors) > 0 {
		return GetClusterReqMultiError(errors)
	}

	return nil
}

// GetClusterReqMultiError is an error wrapping multiple validation errors
// returned by GetClusterReq.ValidateAll() if the designated constraints
// aren't met.
type GetClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterReqMultiError) AllErrors() []error { return m }

// GetClusterReqValidationError is the validation error returned by
// GetClusterReq.Validate if the designated constraints aren't met.
type GetClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterReqValidationError) ErrorName() string { return "GetClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e GetClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterReqValidationError{}

var _GetClusterReq_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetClusterResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetClusterRespMultiError,
// or nil if none found.
func (m *GetClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterRespValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetClusterRespMultiError(errors)
	}

	return nil
}

// GetClusterRespMultiError is an error wrapping multiple validation errors
// returned by GetClusterResp.ValidateAll() if the designated constraints
// aren't met.
type GetClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterRespMultiError) AllErrors() []error { return m }

// GetClusterRespValidationError is the validation error returned by
// GetClusterResp.Validate if the designated constraints aren't met.
type GetClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterRespValidationError) ErrorName() string { return "GetClusterRespValidationError" }

// Error satisfies the builtin error interface
func (e GetClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterRespValidationError{}

// Validate checks the field values on ExtraClusterInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExtraClusterInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtraClusterInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtraClusterInfoMultiError, or nil if none found.
func (m *ExtraClusterInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtraClusterInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProviderType

	if len(errors) > 0 {
		return ExtraClusterInfoMultiError(errors)
	}

	return nil
}

// ExtraClusterInfoMultiError is an error wrapping multiple validation errors
// returned by ExtraClusterInfo.ValidateAll() if the designated constraints
// aren't met.
type ExtraClusterInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtraClusterInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtraClusterInfoMultiError) AllErrors() []error { return m }

// ExtraClusterInfoValidationError is the validation error returned by
// ExtraClusterInfo.Validate if the designated constraints aren't met.
type ExtraClusterInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtraClusterInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtraClusterInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtraClusterInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtraClusterInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtraClusterInfoValidationError) ErrorName() string { return "ExtraClusterInfoValidationError" }

// Error satisfies the builtin error interface
func (e ExtraClusterInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtraClusterInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtraClusterInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtraClusterInfoValidationError{}

// Validate checks the field values on CheckNodesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CheckNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckNodesRequestMultiError, or nil if none found.
func (m *CheckNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CheckNodesRequestMultiError(errors)
	}

	return nil
}

// CheckNodesRequestMultiError is an error wrapping multiple validation errors
// returned by CheckNodesRequest.ValidateAll() if the designated constraints
// aren't met.
type CheckNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckNodesRequestMultiError) AllErrors() []error { return m }

// CheckNodesRequestValidationError is the validation error returned by
// CheckNodesRequest.Validate if the designated constraints aren't met.
type CheckNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckNodesRequestValidationError) ErrorName() string {
	return "CheckNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckNodesRequestValidationError{}

// Validate checks the field values on CheckNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckNodesResponseMultiError, or nil if none found.
func (m *CheckNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	{
		sorted_keys := make([]string, len(m.GetData()))
		i := 0
		for key := range m.GetData() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetData()[key]
			_ = val

			// no validation rules for Data[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CheckNodesResponseValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CheckNodesResponseValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CheckNodesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return CheckNodesResponseMultiError(errors)
	}

	return nil
}

// CheckNodesResponseMultiError is an error wrapping multiple validation errors
// returned by CheckNodesResponse.ValidateAll() if the designated constraints
// aren't met.
type CheckNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckNodesResponseMultiError) AllErrors() []error { return m }

// CheckNodesResponseValidationError is the validation error returned by
// CheckNodesResponse.Validate if the designated constraints aren't met.
type CheckNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckNodesResponseValidationError) ErrorName() string {
	return "CheckNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckNodesResponseValidationError{}

// Validate checks the field values on NodeResult with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeResultMultiError, or
// nil if none found.
func (m *NodeResult) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsExist

	// no validation rules for ClusterID

	// no validation rules for ClusterName

	if len(errors) > 0 {
		return NodeResultMultiError(errors)
	}

	return nil
}

// NodeResultMultiError is an error wrapping multiple validation errors
// returned by NodeResult.ValidateAll() if the designated constraints aren't met.
type NodeResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeResultMultiError) AllErrors() []error { return m }

// NodeResultValidationError is the validation error returned by
// NodeResult.Validate if the designated constraints aren't met.
type NodeResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeResultValidationError) ErrorName() string { return "NodeResultValidationError" }

// Error satisfies the builtin error interface
func (e NodeResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeResultValidationError{}

// Validate checks the field values on UnCordonNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnCordonNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnCordonNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnCordonNodeRequestMultiError, or nil if none found.
func (m *UnCordonNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnCordonNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClusterID()) < 1 {
		err := UnCordonNodeRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UnCordonNodeRequestMultiError(errors)
	}

	return nil
}

// UnCordonNodeRequestMultiError is an error wrapping multiple validation
// errors returned by UnCordonNodeRequest.ValidateAll() if the designated
// constraints aren't met.
type UnCordonNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnCordonNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnCordonNodeRequestMultiError) AllErrors() []error { return m }

// UnCordonNodeRequestValidationError is the validation error returned by
// UnCordonNodeRequest.Validate if the designated constraints aren't met.
type UnCordonNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnCordonNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnCordonNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnCordonNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnCordonNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnCordonNodeRequestValidationError) ErrorName() string {
	return "UnCordonNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnCordonNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnCordonNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnCordonNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnCordonNodeRequestValidationError{}

// Validate checks the field values on UnCordonNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnCordonNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnCordonNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnCordonNodeResponseMultiError, or nil if none found.
func (m *UnCordonNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnCordonNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnCordonNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnCordonNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnCordonNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnCordonNodeResponseMultiError(errors)
	}

	return nil
}

// UnCordonNodeResponseMultiError is an error wrapping multiple validation
// errors returned by UnCordonNodeResponse.ValidateAll() if the designated
// constraints aren't met.
type UnCordonNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnCordonNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnCordonNodeResponseMultiError) AllErrors() []error { return m }

// UnCordonNodeResponseValidationError is the validation error returned by
// UnCordonNodeResponse.Validate if the designated constraints aren't met.
type UnCordonNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnCordonNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnCordonNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnCordonNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnCordonNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnCordonNodeResponseValidationError) ErrorName() string {
	return "UnCordonNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnCordonNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnCordonNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnCordonNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnCordonNodeResponseValidationError{}

// Validate checks the field values on CordonNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CordonNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CordonNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CordonNodeRequestMultiError, or nil if none found.
func (m *CordonNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CordonNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClusterID()) < 1 {
		err := CordonNodeRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CordonNodeRequestMultiError(errors)
	}

	return nil
}

// CordonNodeRequestMultiError is an error wrapping multiple validation errors
// returned by CordonNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type CordonNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CordonNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CordonNodeRequestMultiError) AllErrors() []error { return m }

// CordonNodeRequestValidationError is the validation error returned by
// CordonNodeRequest.Validate if the designated constraints aren't met.
type CordonNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CordonNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CordonNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CordonNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CordonNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CordonNodeRequestValidationError) ErrorName() string {
	return "CordonNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CordonNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCordonNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CordonNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CordonNodeRequestValidationError{}

// Validate checks the field values on CordonNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CordonNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CordonNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CordonNodeResponseMultiError, or nil if none found.
func (m *CordonNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CordonNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CordonNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CordonNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CordonNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CordonNodeResponseMultiError(errors)
	}

	return nil
}

// CordonNodeResponseMultiError is an error wrapping multiple validation errors
// returned by CordonNodeResponse.ValidateAll() if the designated constraints
// aren't met.
type CordonNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CordonNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CordonNodeResponseMultiError) AllErrors() []error { return m }

// CordonNodeResponseValidationError is the validation error returned by
// CordonNodeResponse.Validate if the designated constraints aren't met.
type CordonNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CordonNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CordonNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CordonNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CordonNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CordonNodeResponseValidationError) ErrorName() string {
	return "CordonNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CordonNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCordonNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CordonNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CordonNodeResponseValidationError{}

// Validate checks the field values on UpdateNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeRequestMultiError, or nil if none found.
func (m *UpdateNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetInnerIPs()); l < 1 || l > 100 {
		err := UpdateNodeRequestValidationError{
			field:  "InnerIPs",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateNodeRequest_Status_InLookup[m.GetStatus()]; !ok {
		err := UpdateNodeRequestValidationError{
			field:  "Status",
			reason: "value must be in list [INITIALIZATION RUNNING DELETING ADD-FAILURE REMOVE-FAILURE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NodeGroupID

	// no validation rules for ClusterID

	if len(m.GetUpdater()) < 1 {
		err := UpdateNodeRequestValidationError{
			field:  "Updater",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateNodeRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeRequestMultiError) AllErrors() []error { return m }

// UpdateNodeRequestValidationError is the validation error returned by
// UpdateNodeRequest.Validate if the designated constraints aren't met.
type UpdateNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeRequestValidationError) ErrorName() string {
	return "UpdateNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeRequestValidationError{}

var _UpdateNodeRequest_Status_InLookup = map[string]struct{}{
	"INITIALIZATION": {},
	"RUNNING":        {},
	"DELETING":       {},
	"ADD-FAILURE":    {},
	"REMOVE-FAILURE": {},
}

// Validate checks the field values on UpdateNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeResponseMultiError, or nil if none found.
func (m *UpdateNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateNodeResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeResponseMultiError) AllErrors() []error { return m }

// UpdateNodeResponseValidationError is the validation error returned by
// UpdateNodeResponse.Validate if the designated constraints aren't met.
type UpdateNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeResponseValidationError) ErrorName() string {
	return "UpdateNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeResponseValidationError{}

// Validate checks the field values on NodeStatus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeStatusMultiError, or
// nil if none found.
func (m *NodeStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NodeStatusMultiError(errors)
	}

	return nil
}

// NodeStatusMultiError is an error wrapping multiple validation errors
// returned by NodeStatus.ValidateAll() if the designated constraints aren't met.
type NodeStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeStatusMultiError) AllErrors() []error { return m }

// NodeStatusValidationError is the validation error returned by
// NodeStatus.Validate if the designated constraints aren't met.
type NodeStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeStatusValidationError) ErrorName() string { return "NodeStatusValidationError" }

// Error satisfies the builtin error interface
func (e NodeStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeStatusValidationError{}

// Validate checks the field values on UpdateClusterModuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterModuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterModuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterModuleRequestMultiError, or nil if none found.
func (m *UpdateClusterModuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterModuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if all {
		switch v := interface{}(m.GetModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterModuleRequestValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterModuleRequestValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterModuleRequestValidationError{
				field:  "Module",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetOperator()) < 1 {
		err := UpdateClusterModuleRequestValidationError{
			field:  "Operator",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateClusterModuleRequestMultiError(errors)
	}

	return nil
}

// UpdateClusterModuleRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateClusterModuleRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateClusterModuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterModuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterModuleRequestMultiError) AllErrors() []error { return m }

// UpdateClusterModuleRequestValidationError is the validation error returned
// by UpdateClusterModuleRequest.Validate if the designated constraints aren't met.
type UpdateClusterModuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterModuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterModuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterModuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterModuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterModuleRequestValidationError) ErrorName() string {
	return "UpdateClusterModuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterModuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterModuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterModuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterModuleRequestValidationError{}

// Validate checks the field values on UpdateClusterModuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterModuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterModuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterModuleResponseMultiError, or nil if none found.
func (m *UpdateClusterModuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterModuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterModuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterModuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterModuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateClusterModuleResponseMultiError(errors)
	}

	return nil
}

// UpdateClusterModuleResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateClusterModuleResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateClusterModuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterModuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterModuleResponseMultiError) AllErrors() []error { return m }

// UpdateClusterModuleResponseValidationError is the validation error returned
// by UpdateClusterModuleResponse.Validate if the designated constraints
// aren't met.
type UpdateClusterModuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterModuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterModuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterModuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterModuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterModuleResponseValidationError) ErrorName() string {
	return "UpdateClusterModuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterModuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterModuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterModuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterModuleResponseValidationError{}

// Validate checks the field values on RecordNodeInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecordNodeInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecordNodeInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecordNodeInfoRequestMultiError, or nil if none found.
func (m *RecordNodeInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RecordNodeInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetNodes()); l < 1 || l > 1000 {
		err := RecordNodeInfoRequestValidationError{
			field:  "Nodes",
			reason: "value must contain between 1 and 1000 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RecordNodeInfoRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RecordNodeInfoRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RecordNodeInfoRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RecordNodeInfoRequestMultiError(errors)
	}

	return nil
}

// RecordNodeInfoRequestMultiError is an error wrapping multiple validation
// errors returned by RecordNodeInfoRequest.ValidateAll() if the designated
// constraints aren't met.
type RecordNodeInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecordNodeInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecordNodeInfoRequestMultiError) AllErrors() []error { return m }

// RecordNodeInfoRequestValidationError is the validation error returned by
// RecordNodeInfoRequest.Validate if the designated constraints aren't met.
type RecordNodeInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecordNodeInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecordNodeInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecordNodeInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecordNodeInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecordNodeInfoRequestValidationError) ErrorName() string {
	return "RecordNodeInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RecordNodeInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecordNodeInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecordNodeInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecordNodeInfoRequestValidationError{}

// Validate checks the field values on GetNodeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetNodeRequestMultiError,
// or nil if none found.
func (m *GetNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetInnerIP()); ip == nil || ip.To4() == nil {
		err := GetNodeRequestValidationError{
			field:  "InnerIP",
			reason: "value must be a valid IPv4 address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShowPwd

	if len(errors) > 0 {
		return GetNodeRequestMultiError(errors)
	}

	return nil
}

// GetNodeRequestMultiError is an error wrapping multiple validation errors
// returned by GetNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type GetNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeRequestMultiError) AllErrors() []error { return m }

// GetNodeRequestValidationError is the validation error returned by
// GetNodeRequest.Validate if the designated constraints aren't met.
type GetNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeRequestValidationError) ErrorName() string { return "GetNodeRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeRequestValidationError{}

// Validate checks the field values on GetNodeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeResponseMultiError, or nil if none found.
func (m *GetNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetNodeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetNodeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetNodeResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetNodeResponseMultiError(errors)
	}

	return nil
}

// GetNodeResponseMultiError is an error wrapping multiple validation errors
// returned by GetNodeResponse.ValidateAll() if the designated constraints
// aren't met.
type GetNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeResponseMultiError) AllErrors() []error { return m }

// GetNodeResponseValidationError is the validation error returned by
// GetNodeResponse.Validate if the designated constraints aren't met.
type GetNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeResponseValidationError) ErrorName() string { return "GetNodeResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeResponseValidationError{}

// Validate checks the field values on GetNodeInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeInfoRequestMultiError, or nil if none found.
func (m *GetNodeInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetInnerIP()); ip == nil || ip.To4() == nil {
		err := GetNodeInfoRequestValidationError{
			field:  "InnerIP",
			reason: "value must be a valid IPv4 address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNodeInfoRequestMultiError(errors)
	}

	return nil
}

// GetNodeInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GetNodeInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type GetNodeInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeInfoRequestMultiError) AllErrors() []error { return m }

// GetNodeInfoRequestValidationError is the validation error returned by
// GetNodeInfoRequest.Validate if the designated constraints aren't met.
type GetNodeInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeInfoRequestValidationError) ErrorName() string {
	return "GetNodeInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeInfoRequestValidationError{}

// Validate checks the field values on GetNodeInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeInfoResponseMultiError, or nil if none found.
func (m *GetNodeInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNodeInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNodeInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNodeInfoResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNodeInfoResponseMultiError(errors)
	}

	return nil
}

// GetNodeInfoResponseMultiError is an error wrapping multiple validation
// errors returned by GetNodeInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type GetNodeInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeInfoResponseMultiError) AllErrors() []error { return m }

// GetNodeInfoResponseValidationError is the validation error returned by
// GetNodeInfoResponse.Validate if the designated constraints aren't met.
type GetNodeInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeInfoResponseValidationError) ErrorName() string {
	return "GetNodeInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeInfoResponseValidationError{}

// Validate checks the field values on NodeConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeConfigMultiError, or
// nil if none found.
func (m *NodeConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceType

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	if len(errors) > 0 {
		return NodeConfigMultiError(errors)
	}

	return nil
}

// NodeConfigMultiError is an error wrapping multiple validation errors
// returned by NodeConfig.ValidateAll() if the designated constraints aren't met.
type NodeConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeConfigMultiError) AllErrors() []error { return m }

// NodeConfigValidationError is the validation error returned by
// NodeConfig.Validate if the designated constraints aren't met.
type NodeConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeConfigValidationError) ErrorName() string { return "NodeConfigValidationError" }

// Error satisfies the builtin error interface
func (e NodeConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeConfigValidationError{}

// Validate checks the field values on NodeInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeInfoMultiError, or nil
// if none found.
func (m *NodeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeName

	// no validation rules for NodeType

	// no validation rules for NodeID

	// no validation rules for InnerIP

	// no validation rules for ClusterID

	// no validation rules for VPC

	// no validation rules for Region

	// no validation rules for DeviceID

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetInstanceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeInfoValidationError{
					field:  "InstanceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeInfoValidationError{
					field:  "InstanceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstanceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeInfoValidationError{
				field:  "InstanceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetZoneInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeInfoValidationError{
					field:  "ZoneInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeInfoValidationError{
					field:  "ZoneInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetZoneInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeInfoValidationError{
				field:  "ZoneInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeInfoValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeInfoValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeInfoValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeInfoValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeInfoValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeInfoValidationError{
				field:  "NodeTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeInfoMultiError(errors)
	}

	return nil
}

// NodeInfoMultiError is an error wrapping multiple validation errors returned
// by NodeInfo.ValidateAll() if the designated constraints aren't met.
type NodeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeInfoMultiError) AllErrors() []error { return m }

// NodeInfoValidationError is the validation error returned by
// NodeInfo.Validate if the designated constraints aren't met.
type NodeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeInfoValidationError) ErrorName() string { return "NodeInfoValidationError" }

// Error satisfies the builtin error interface
func (e NodeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeInfoValidationError{}

// Validate checks the field values on ListCommonClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCommonClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommonClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommonClusterReqMultiError, or nil if none found.
func (m *ListCommonClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommonClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ShowVCluster

	if len(errors) > 0 {
		return ListCommonClusterReqMultiError(errors)
	}

	return nil
}

// ListCommonClusterReqMultiError is an error wrapping multiple validation
// errors returned by ListCommonClusterReq.ValidateAll() if the designated
// constraints aren't met.
type ListCommonClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommonClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommonClusterReqMultiError) AllErrors() []error { return m }

// ListCommonClusterReqValidationError is the validation error returned by
// ListCommonClusterReq.Validate if the designated constraints aren't met.
type ListCommonClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommonClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommonClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommonClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommonClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommonClusterReqValidationError) ErrorName() string {
	return "ListCommonClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListCommonClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommonClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommonClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommonClusterReqValidationError{}

// Validate checks the field values on ListCommonClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCommonClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommonClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommonClusterRespMultiError, or nil if none found.
func (m *ListCommonClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommonClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCommonClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCommonClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCommonClusterRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCommonClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCommonClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCommonClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCommonClusterRespMultiError(errors)
	}

	return nil
}

// ListCommonClusterRespMultiError is an error wrapping multiple validation
// errors returned by ListCommonClusterResp.ValidateAll() if the designated
// constraints aren't met.
type ListCommonClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommonClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommonClusterRespMultiError) AllErrors() []error { return m }

// ListCommonClusterRespValidationError is the validation error returned by
// ListCommonClusterResp.Validate if the designated constraints aren't met.
type ListCommonClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommonClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommonClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommonClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommonClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommonClusterRespValidationError) ErrorName() string {
	return "ListCommonClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListCommonClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommonClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommonClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommonClusterRespValidationError{}

// Validate checks the field values on ListProjectClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectClusterReqMultiError, or nil if none found.
func (m *ListProjectClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := ListProjectClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := ListProjectClusterReqValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProvider()) > 32 {
		err := ListProjectClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListProjectClusterReqMultiError(errors)
	}

	return nil
}

// ListProjectClusterReqMultiError is an error wrapping multiple validation
// errors returned by ListProjectClusterReq.ValidateAll() if the designated
// constraints aren't met.
type ListProjectClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectClusterReqMultiError) AllErrors() []error { return m }

// ListProjectClusterReqValidationError is the validation error returned by
// ListProjectClusterReq.Validate if the designated constraints aren't met.
type ListProjectClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectClusterReqValidationError) ErrorName() string {
	return "ListProjectClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectClusterReqValidationError{}

// Validate checks the field values on ListProjectClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectClusterRespMultiError, or nil if none found.
func (m *ListProjectClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectClusterRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetClusterExtraInfo()))
		i := 0
		for key := range m.GetClusterExtraInfo() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClusterExtraInfo()[key]
			_ = val

			// no validation rules for ClusterExtraInfo[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ListProjectClusterRespValidationError{
							field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ListProjectClusterRespValidationError{
							field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ListProjectClusterRespValidationError{
						field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProjectClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProjectClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProjectClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListProjectClusterRespMultiError(errors)
	}

	return nil
}

// ListProjectClusterRespMultiError is an error wrapping multiple validation
// errors returned by ListProjectClusterResp.ValidateAll() if the designated
// constraints aren't met.
type ListProjectClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectClusterRespMultiError) AllErrors() []error { return m }

// ListProjectClusterRespValidationError is the validation error returned by
// ListProjectClusterResp.Validate if the designated constraints aren't met.
type ListProjectClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectClusterRespValidationError) ErrorName() string {
	return "ListProjectClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectClusterRespValidationError{}

// Validate checks the field values on ListClusterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListClusterReqMultiError,
// or nil if none found.
func (m *ListClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) > 100 {
		err := ListClusterReqValidationError{
			field:  "ClusterName",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProvider()) > 32 {
		err := ListClusterReqValidationError{
			field:  "Provider",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := ListClusterReqValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVpcID()) > 32 {
		err := ListClusterReqValidationError{
			field:  "VpcID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 100 {
		err := ListClusterReqValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBusinessID()) > 100 {
		err := ListClusterReqValidationError{
			field:  "BusinessID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Environment

	// no validation rules for EngineType

	// no validation rules for IsExclusive

	// no validation rules for ClusterType

	// no validation rules for FederationClusterID

	if _, ok := _ListClusterReq_Status_InLookup[m.GetStatus()]; !ok {
		err := ListClusterReqValidationError{
			field:  "Status",
			reason: "value must be in list [CREATING RUNNING DELETING FALURE INITIALIZATION DELETED ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := ListClusterReqValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 1000 {
		err := ListClusterReqValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if utf8.RuneCountInString(m.GetSystemID()) > 100 {
		err := ListClusterReqValidationError{
			field:  "SystemID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ExtraClusterID

	// no validation rules for IsCommonCluster

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ListClusterReqMultiError(errors)
	}

	return nil
}

// ListClusterReqMultiError is an error wrapping multiple validation errors
// returned by ListClusterReq.ValidateAll() if the designated constraints
// aren't met.
type ListClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterReqMultiError) AllErrors() []error { return m }

// ListClusterReqValidationError is the validation error returned by
// ListClusterReq.Validate if the designated constraints aren't met.
type ListClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterReqValidationError) ErrorName() string { return "ListClusterReqValidationError" }

// Error satisfies the builtin error interface
func (e ListClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterReqValidationError{}

var _ListClusterReq_Status_InLookup = map[string]struct{}{
	"CREATING":       {},
	"RUNNING":        {},
	"DELETING":       {},
	"FALURE":         {},
	"INITIALIZATION": {},
	"DELETED":        {},
	"":               {},
}

// Validate checks the field values on ListClusterResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterRespMultiError, or nil if none found.
func (m *ListClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListClusterRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListClusterRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetClusterExtraInfo()))
		i := 0
		for key := range m.GetClusterExtraInfo() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClusterExtraInfo()[key]
			_ = val

			// no validation rules for ClusterExtraInfo[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ListClusterRespValidationError{
							field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ListClusterRespValidationError{
							field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ListClusterRespValidationError{
						field:  fmt.Sprintf("ClusterExtraInfo[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListClusterRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListClusterRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListClusterRespMultiError(errors)
	}

	return nil
}

// ListClusterRespMultiError is an error wrapping multiple validation errors
// returned by ListClusterResp.ValidateAll() if the designated constraints
// aren't met.
type ListClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterRespMultiError) AllErrors() []error { return m }

// ListClusterRespValidationError is the validation error returned by
// ListClusterResp.Validate if the designated constraints aren't met.
type ListClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterRespValidationError) ErrorName() string { return "ListClusterRespValidationError" }

// Error satisfies the builtin error interface
func (e ListClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterRespValidationError{}

// Validate checks the field values on ExtraInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExtraInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtraInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExtraInfoMultiError, or nil
// if none found.
func (m *ExtraInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtraInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CanDeleted

	// no validation rules for ProviderType

	// no validation rules for AutoScale

	if len(errors) > 0 {
		return ExtraInfoMultiError(errors)
	}

	return nil
}

// ExtraInfoMultiError is an error wrapping multiple validation errors returned
// by ExtraInfo.ValidateAll() if the designated constraints aren't met.
type ExtraInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtraInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtraInfoMultiError) AllErrors() []error { return m }

// ExtraInfoValidationError is the validation error returned by
// ExtraInfo.Validate if the designated constraints aren't met.
type ExtraInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtraInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtraInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtraInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtraInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtraInfoValidationError) ErrorName() string { return "ExtraInfoValidationError" }

// Error satisfies the builtin error interface
func (e ExtraInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtraInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtraInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtraInfoValidationError{}

// Validate checks the field values on WebAnnotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebAnnotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAnnotations with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebAnnotationsMultiError,
// or nil if none found.
func (m *WebAnnotations) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAnnotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetPerms()))
		i := 0
		for key := range m.GetPerms() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPerms()[key]
			_ = val

			// no validation rules for Perms[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, WebAnnotationsValidationError{
							field:  fmt.Sprintf("Perms[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, WebAnnotationsValidationError{
							field:  fmt.Sprintf("Perms[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return WebAnnotationsValidationError{
						field:  fmt.Sprintf("Perms[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return WebAnnotationsMultiError(errors)
	}

	return nil
}

// WebAnnotationsMultiError is an error wrapping multiple validation errors
// returned by WebAnnotations.ValidateAll() if the designated constraints
// aren't met.
type WebAnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAnnotationsMultiError) AllErrors() []error { return m }

// WebAnnotationsValidationError is the validation error returned by
// WebAnnotations.Validate if the designated constraints aren't met.
type WebAnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAnnotationsValidationError) ErrorName() string { return "WebAnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e WebAnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAnnotationsValidationError{}

// Validate checks the field values on WebAnnotationsV2 with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WebAnnotationsV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAnnotationsV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebAnnotationsV2MultiError, or nil if none found.
func (m *WebAnnotationsV2) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAnnotationsV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPerms()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebAnnotationsV2ValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebAnnotationsV2ValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerms()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebAnnotationsV2ValidationError{
				field:  "Perms",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WebAnnotationsV2MultiError(errors)
	}

	return nil
}

// WebAnnotationsV2MultiError is an error wrapping multiple validation errors
// returned by WebAnnotationsV2.ValidateAll() if the designated constraints
// aren't met.
type WebAnnotationsV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAnnotationsV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAnnotationsV2MultiError) AllErrors() []error { return m }

// WebAnnotationsV2ValidationError is the validation error returned by
// WebAnnotationsV2.Validate if the designated constraints aren't met.
type WebAnnotationsV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAnnotationsV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAnnotationsV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAnnotationsV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAnnotationsV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAnnotationsV2ValidationError) ErrorName() string { return "WebAnnotationsV2ValidationError" }

// Error satisfies the builtin error interface
func (e WebAnnotationsV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAnnotationsV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAnnotationsV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAnnotationsV2ValidationError{}

// Validate checks the field values on ListNodesInClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInClusterRequestMultiError, or nil if none found.
func (m *ListNodesInClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := ListNodesInClusterRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) > 100 {
		err := ListNodesInClusterRequestValidationError{
			field:  "Region",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVpcID()) > 32 {
		err := ListNodesInClusterRequestValidationError{
			field:  "VpcID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNodeGroupID()) > 100 {
		err := ListNodesInClusterRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for InstanceType

	// no validation rules for Status

	if m.GetOffset() < 0 {
		err := ListNodesInClusterRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 1000 {
		err := ListNodesInClusterRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShowPwd

	if len(errors) > 0 {
		return ListNodesInClusterRequestMultiError(errors)
	}

	return nil
}

// ListNodesInClusterRequestMultiError is an error wrapping multiple validation
// errors returned by ListNodesInClusterRequest.ValidateAll() if the
// designated constraints aren't met.
type ListNodesInClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInClusterRequestMultiError) AllErrors() []error { return m }

// ListNodesInClusterRequestValidationError is the validation error returned by
// ListNodesInClusterRequest.Validate if the designated constraints aren't met.
type ListNodesInClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInClusterRequestValidationError) ErrorName() string {
	return "ListNodesInClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInClusterRequestValidationError{}

// Validate checks the field values on ListNodesInClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInClusterResponseMultiError, or nil if none found.
func (m *ListNodesInClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodesInClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodesInClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodesInClusterResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNodesInClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNodesInClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNodesInClusterResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListNodesInClusterResponseMultiError(errors)
	}

	return nil
}

// ListNodesInClusterResponseMultiError is an error wrapping multiple
// validation errors returned by ListNodesInClusterResponse.ValidateAll() if
// the designated constraints aren't met.
type ListNodesInClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInClusterResponseMultiError) AllErrors() []error { return m }

// ListNodesInClusterResponseValidationError is the validation error returned
// by ListNodesInClusterResponse.Validate if the designated constraints aren't met.
type ListNodesInClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInClusterResponseValidationError) ErrorName() string {
	return "ListNodesInClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInClusterResponseValidationError{}

// Validate checks the field values on ClusterNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterNodeMultiError, or
// nil if none found.
func (m *ClusterNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeID

	// no validation rules for InnerIP

	// no validation rules for InstanceType

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for Status

	// no validation rules for ZoneID

	// no validation rules for NodeGroupID

	// no validation rules for ClusterID

	// no validation rules for VPC

	// no validation rules for Region

	// no validation rules for Passwd

	// no validation rules for Zone

	// no validation rules for DeviceID

	// no validation rules for Labels

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterNodeValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterNodeValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterNodeValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for UnSchedulable

	// no validation rules for NodeName

	// no validation rules for Agent

	// no validation rules for Idc

	// no validation rules for Rack

	// no validation rules for DeviceClass

	// no validation rules for InnerIPv6

	// no validation rules for NodeGroupName

	// no validation rules for BkCloudID

	// no validation rules for Annotations

	// no validation rules for ZoneName

	// no validation rules for TaskID

	// no validation rules for FailedReason

	if len(errors) > 0 {
		return ClusterNodeMultiError(errors)
	}

	return nil
}

// ClusterNodeMultiError is an error wrapping multiple validation errors
// returned by ClusterNode.ValidateAll() if the designated constraints aren't met.
type ClusterNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterNodeMultiError) AllErrors() []error { return m }

// ClusterNodeValidationError is the validation error returned by
// ClusterNode.Validate if the designated constraints aren't met.
type ClusterNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterNodeValidationError) ErrorName() string { return "ClusterNodeValidationError" }

// Error satisfies the builtin error interface
func (e ClusterNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterNodeValidationError{}

// Validate checks the field values on ListMastersInClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMastersInClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMastersInClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMastersInClusterRequestMultiError, or nil if none found.
func (m *ListMastersInClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMastersInClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := ListMastersInClusterRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListMastersInClusterRequestMultiError(errors)
	}

	return nil
}

// ListMastersInClusterRequestMultiError is an error wrapping multiple
// validation errors returned by ListMastersInClusterRequest.ValidateAll() if
// the designated constraints aren't met.
type ListMastersInClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMastersInClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMastersInClusterRequestMultiError) AllErrors() []error { return m }

// ListMastersInClusterRequestValidationError is the validation error returned
// by ListMastersInClusterRequest.Validate if the designated constraints
// aren't met.
type ListMastersInClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMastersInClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMastersInClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMastersInClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMastersInClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMastersInClusterRequestValidationError) ErrorName() string {
	return "ListMastersInClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMastersInClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMastersInClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMastersInClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMastersInClusterRequestValidationError{}

// Validate checks the field values on ListMastersInClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMastersInClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMastersInClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMastersInClusterResponseMultiError, or nil if none found.
func (m *ListMastersInClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMastersInClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMastersInClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMastersInClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMastersInClusterResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMastersInClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMastersInClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMastersInClusterResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListMastersInClusterResponseMultiError(errors)
	}

	return nil
}

// ListMastersInClusterResponseMultiError is an error wrapping multiple
// validation errors returned by ListMastersInClusterResponse.ValidateAll() if
// the designated constraints aren't met.
type ListMastersInClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMastersInClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMastersInClusterResponseMultiError) AllErrors() []error { return m }

// ListMastersInClusterResponseValidationError is the validation error returned
// by ListMastersInClusterResponse.Validate if the designated constraints
// aren't met.
type ListMastersInClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMastersInClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMastersInClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMastersInClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMastersInClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMastersInClusterResponseValidationError) ErrorName() string {
	return "ListMastersInClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMastersInClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMastersInClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMastersInClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMastersInClusterResponseValidationError{}

// Validate checks the field values on GetClusterCredentialReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterCredentialReqMultiError, or nil if none found.
func (m *GetClusterCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServerKey()); l < 1 || l > 100 {
		err := GetClusterCredentialReqValidationError{
			field:  "ServerKey",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetClusterCredentialReqMultiError(errors)
	}

	return nil
}

// GetClusterCredentialReqMultiError is an error wrapping multiple validation
// errors returned by GetClusterCredentialReq.ValidateAll() if the designated
// constraints aren't met.
type GetClusterCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterCredentialReqMultiError) AllErrors() []error { return m }

// GetClusterCredentialReqValidationError is the validation error returned by
// GetClusterCredentialReq.Validate if the designated constraints aren't met.
type GetClusterCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterCredentialReqValidationError) ErrorName() string {
	return "GetClusterCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterCredentialReqValidationError{}

// Validate checks the field values on GetClusterCredentialResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterCredentialRespMultiError, or nil if none found.
func (m *GetClusterCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterCredentialRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterCredentialRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterCredentialRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetClusterCredentialRespMultiError(errors)
	}

	return nil
}

// GetClusterCredentialRespMultiError is an error wrapping multiple validation
// errors returned by GetClusterCredentialResp.ValidateAll() if the designated
// constraints aren't met.
type GetClusterCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterCredentialRespMultiError) AllErrors() []error { return m }

// GetClusterCredentialRespValidationError is the validation error returned by
// GetClusterCredentialResp.Validate if the designated constraints aren't met.
type GetClusterCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterCredentialRespValidationError) ErrorName() string {
	return "GetClusterCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterCredentialRespValidationError{}

// Validate checks the field values on UpdateClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterCredentialReqMultiError, or nil if none found.
func (m *UpdateClusterCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServerKey()); l < 1 || l > 100 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ServerKey",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClientModule()); l < 1 || l > 100 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClientModule",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetServerAddress()); l < 1 || l > 2048 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ServerAddress",
			reason: "value length must be between 1 and 2048 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCaCertData()) > 4096 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "CaCertData",
			reason: "value length must be at most 4096 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUserToken()) > 2048 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "UserToken",
			reason: "value length must be at most 2048 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterDomain()) > 2048 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClusterDomain",
			reason: "value length must be at most 2048 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientCert()) > 4096 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClientCert",
			reason: "value length must be at most 4096 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientKey()) > 4096 {
		err := UpdateClusterCredentialReqValidationError{
			field:  "ClientKey",
			reason: "value length must be at most 4096 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateClusterCredentialReqMultiError(errors)
	}

	return nil
}

// UpdateClusterCredentialReqMultiError is an error wrapping multiple
// validation errors returned by UpdateClusterCredentialReq.ValidateAll() if
// the designated constraints aren't met.
type UpdateClusterCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterCredentialReqMultiError) AllErrors() []error { return m }

// UpdateClusterCredentialReqValidationError is the validation error returned
// by UpdateClusterCredentialReq.Validate if the designated constraints aren't met.
type UpdateClusterCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterCredentialReqValidationError) ErrorName() string {
	return "UpdateClusterCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterCredentialReqValidationError{}

// Validate checks the field values on UpdateClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterCredentialRespMultiError, or nil if none found.
func (m *UpdateClusterCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateClusterCredentialRespMultiError(errors)
	}

	return nil
}

// UpdateClusterCredentialRespMultiError is an error wrapping multiple
// validation errors returned by UpdateClusterCredentialResp.ValidateAll() if
// the designated constraints aren't met.
type UpdateClusterCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterCredentialRespMultiError) AllErrors() []error { return m }

// UpdateClusterCredentialRespValidationError is the validation error returned
// by UpdateClusterCredentialResp.Validate if the designated constraints
// aren't met.
type UpdateClusterCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterCredentialRespValidationError) ErrorName() string {
	return "UpdateClusterCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterCredentialRespValidationError{}

// Validate checks the field values on DeleteClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterCredentialReqMultiError, or nil if none found.
func (m *DeleteClusterCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServerKey()); l < 2 || l > 100 {
		err := DeleteClusterCredentialReqValidationError{
			field:  "ServerKey",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteClusterCredentialReqMultiError(errors)
	}

	return nil
}

// DeleteClusterCredentialReqMultiError is an error wrapping multiple
// validation errors returned by DeleteClusterCredentialReq.ValidateAll() if
// the designated constraints aren't met.
type DeleteClusterCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterCredentialReqMultiError) AllErrors() []error { return m }

// DeleteClusterCredentialReqValidationError is the validation error returned
// by DeleteClusterCredentialReq.Validate if the designated constraints aren't met.
type DeleteClusterCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterCredentialReqValidationError) ErrorName() string {
	return "DeleteClusterCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterCredentialReqValidationError{}

// Validate checks the field values on DeleteClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterCredentialRespMultiError, or nil if none found.
func (m *DeleteClusterCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DeleteClusterCredentialRespMultiError(errors)
	}

	return nil
}

// DeleteClusterCredentialRespMultiError is an error wrapping multiple
// validation errors returned by DeleteClusterCredentialResp.ValidateAll() if
// the designated constraints aren't met.
type DeleteClusterCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterCredentialRespMultiError) AllErrors() []error { return m }

// DeleteClusterCredentialRespValidationError is the validation error returned
// by DeleteClusterCredentialResp.Validate if the designated constraints
// aren't met.
type DeleteClusterCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterCredentialRespValidationError) ErrorName() string {
	return "DeleteClusterCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterCredentialRespValidationError{}

// Validate checks the field values on ListClusterCredentialReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterCredentialReqMultiError, or nil if none found.
func (m *ListClusterCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetServerKey()) > 100 {
		err := ListClusterCredentialReqValidationError{
			field:  "ServerKey",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := ListClusterCredentialReqValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientMode()) > 100 {
		err := ListClusterCredentialReqValidationError{
			field:  "ClientMode",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetConnectMode()) > 100 {
		err := ListClusterCredentialReqValidationError{
			field:  "ConnectMode",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := ListClusterCredentialReqValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 1000 {
		err := ListClusterCredentialReqValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListClusterCredentialReqMultiError(errors)
	}

	return nil
}

// ListClusterCredentialReqMultiError is an error wrapping multiple validation
// errors returned by ListClusterCredentialReq.ValidateAll() if the designated
// constraints aren't met.
type ListClusterCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterCredentialReqMultiError) AllErrors() []error { return m }

// ListClusterCredentialReqValidationError is the validation error returned by
// ListClusterCredentialReq.Validate if the designated constraints aren't met.
type ListClusterCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterCredentialReqValidationError) ErrorName() string {
	return "ListClusterCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterCredentialReqValidationError{}

// Validate checks the field values on ListClusterCredentialResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterCredentialResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterCredentialRespMultiError, or nil if none found.
func (m *ListClusterCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListClusterCredentialRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListClusterCredentialRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListClusterCredentialRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListClusterCredentialRespMultiError(errors)
	}

	return nil
}

// ListClusterCredentialRespMultiError is an error wrapping multiple validation
// errors returned by ListClusterCredentialResp.ValidateAll() if the
// designated constraints aren't met.
type ListClusterCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterCredentialRespMultiError) AllErrors() []error { return m }

// ListClusterCredentialRespValidationError is the validation error returned by
// ListClusterCredentialResp.Validate if the designated constraints aren't met.
type ListClusterCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterCredentialRespValidationError) ErrorName() string {
	return "ListClusterCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterCredentialRespValidationError{}

// Validate checks the field values on InitFederationClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitFederationClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitFederationClusterReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitFederationClusterReqMultiError, or nil if none found.
func (m *InitFederationClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InitFederationClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return InitFederationClusterReqMultiError(errors)
	}

	return nil
}

// InitFederationClusterReqMultiError is an error wrapping multiple validation
// errors returned by InitFederationClusterReq.ValidateAll() if the designated
// constraints aren't met.
type InitFederationClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitFederationClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitFederationClusterReqMultiError) AllErrors() []error { return m }

// InitFederationClusterReqValidationError is the validation error returned by
// InitFederationClusterReq.Validate if the designated constraints aren't met.
type InitFederationClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitFederationClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitFederationClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitFederationClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitFederationClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitFederationClusterReqValidationError) ErrorName() string {
	return "InitFederationClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e InitFederationClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitFederationClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitFederationClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitFederationClusterReqValidationError{}

// Validate checks the field values on InitFederationClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitFederationClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitFederationClusterResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitFederationClusterRespMultiError, or nil if none found.
func (m *InitFederationClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *InitFederationClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return InitFederationClusterRespMultiError(errors)
	}

	return nil
}

// InitFederationClusterRespMultiError is an error wrapping multiple validation
// errors returned by InitFederationClusterResp.ValidateAll() if the
// designated constraints aren't met.
type InitFederationClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitFederationClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitFederationClusterRespMultiError) AllErrors() []error { return m }

// InitFederationClusterRespValidationError is the validation error returned by
// InitFederationClusterResp.Validate if the designated constraints aren't met.
type InitFederationClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitFederationClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitFederationClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitFederationClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitFederationClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitFederationClusterRespValidationError) ErrorName() string {
	return "InitFederationClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e InitFederationClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitFederationClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitFederationClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitFederationClusterRespValidationError{}

// Validate checks the field values on AddFederatedClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddFederatedClusterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFederatedClusterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFederatedClusterReqMultiError, or nil if none found.
func (m *AddFederatedClusterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFederatedClusterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FederationClusterID

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return AddFederatedClusterReqMultiError(errors)
	}

	return nil
}

// AddFederatedClusterReqMultiError is an error wrapping multiple validation
// errors returned by AddFederatedClusterReq.ValidateAll() if the designated
// constraints aren't met.
type AddFederatedClusterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFederatedClusterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFederatedClusterReqMultiError) AllErrors() []error { return m }

// AddFederatedClusterReqValidationError is the validation error returned by
// AddFederatedClusterReq.Validate if the designated constraints aren't met.
type AddFederatedClusterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFederatedClusterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFederatedClusterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFederatedClusterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFederatedClusterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFederatedClusterReqValidationError) ErrorName() string {
	return "AddFederatedClusterReqValidationError"
}

// Error satisfies the builtin error interface
func (e AddFederatedClusterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFederatedClusterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFederatedClusterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFederatedClusterReqValidationError{}

// Validate checks the field values on AddFederatedClusterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddFederatedClusterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFederatedClusterResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFederatedClusterRespMultiError, or nil if none found.
func (m *AddFederatedClusterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFederatedClusterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return AddFederatedClusterRespMultiError(errors)
	}

	return nil
}

// AddFederatedClusterRespMultiError is an error wrapping multiple validation
// errors returned by AddFederatedClusterResp.ValidateAll() if the designated
// constraints aren't met.
type AddFederatedClusterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFederatedClusterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFederatedClusterRespMultiError) AllErrors() []error { return m }

// AddFederatedClusterRespValidationError is the validation error returned by
// AddFederatedClusterResp.Validate if the designated constraints aren't met.
type AddFederatedClusterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFederatedClusterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFederatedClusterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFederatedClusterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFederatedClusterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFederatedClusterRespValidationError) ErrorName() string {
	return "AddFederatedClusterRespValidationError"
}

// Error satisfies the builtin error interface
func (e AddFederatedClusterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFederatedClusterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFederatedClusterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFederatedClusterRespValidationError{}

// Validate checks the field values on CreateCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudRequestMultiError, or nil if none found.
func (m *CreateCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 20 {
		err := CreateCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateCloudRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := CreateCloudRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 64 {
		err := CreateCloudRequestValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Editable

	{
		sorted_keys := make([]string, len(m.GetOpsPlugins()))
		i := 0
		for key := range m.GetOpsPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOpsPlugins()[key]
			_ = val

			// no validation rules for OpsPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateCloudRequestValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateCloudRequestValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateCloudRequestValidationError{
						field:  fmt.Sprintf("OpsPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraPlugins()))
		i := 0
		for key := range m.GetExtraPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraPlugins()[key]
			_ = val

			// no validation rules for ExtraPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateCloudRequestValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateCloudRequestValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateCloudRequestValidationError{
						field:  fmt.Sprintf("ExtraPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetCloudCredential()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudCredential()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "CloudCredential",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOsManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOsManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "OsManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "ClusterManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeGroupManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroupManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "NodeGroupManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateCloudRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CloudProvider

	// no validation rules for Config

	// no validation rules for Description

	// no validation rules for EngineType

	// no validation rules for Enable

	if all {
		switch v := interface{}(m.GetNetworkInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "NetworkInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCloudRequestValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCloudRequestValidationError{
				field:  "ConfInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlatformInfo

	if len(errors) > 0 {
		return CreateCloudRequestMultiError(errors)
	}

	return nil
}

// CreateCloudRequestMultiError is an error wrapping multiple validation errors
// returned by CreateCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudRequestMultiError) AllErrors() []error { return m }

// CreateCloudRequestValidationError is the validation error returned by
// CreateCloudRequest.Validate if the designated constraints aren't met.
type CreateCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudRequestValidationError) ErrorName() string {
	return "CreateCloudRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudRequestValidationError{}

var _CreateCloudRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudResponseMultiError, or nil if none found.
func (m *CreateCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateCloudResponseMultiError(errors)
	}

	return nil
}

// CreateCloudResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCloudResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudResponseMultiError) AllErrors() []error { return m }

// CreateCloudResponseValidationError is the validation error returned by
// CreateCloudResponse.Validate if the designated constraints aren't met.
type CreateCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudResponseValidationError) ErrorName() string {
	return "CreateCloudResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudResponseValidationError{}

// Validate checks the field values on UpdateCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudRequestMultiError, or nil if none found.
func (m *UpdateCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 1024 {
		err := UpdateCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) > 1024 {
		err := UpdateCloudRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Editable

	{
		sorted_keys := make([]string, len(m.GetOpsPlugins()))
		i := 0
		for key := range m.GetOpsPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOpsPlugins()[key]
			_ = val

			// no validation rules for OpsPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateCloudRequestValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateCloudRequestValidationError{
							field:  fmt.Sprintf("OpsPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateCloudRequestValidationError{
						field:  fmt.Sprintf("OpsPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetExtraPlugins()))
		i := 0
		for key := range m.GetExtraPlugins() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExtraPlugins()[key]
			_ = val

			// no validation rules for ExtraPlugins[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateCloudRequestValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateCloudRequestValidationError{
							field:  fmt.Sprintf("ExtraPlugins[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateCloudRequestValidationError{
						field:  fmt.Sprintf("ExtraPlugins[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetCloudCredential()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "CloudCredential",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudCredential()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "CloudCredential",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOsManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "OsManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOsManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "OsManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClusterManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "ClusterManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "ClusterManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeGroupManagement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "NodeGroupManagement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroupManagement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "NodeGroupManagement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 1024 {
		err := UpdateCloudRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CloudProvider

	// no validation rules for Config

	// no validation rules for Description

	// no validation rules for EngineType

	// no validation rules for Enable

	if all {
		switch v := interface{}(m.GetNetworkInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "NetworkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworkInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "NetworkInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudRequestValidationError{
					field:  "ConfInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudRequestValidationError{
				field:  "ConfInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlatformInfo

	if len(errors) > 0 {
		return UpdateCloudRequestMultiError(errors)
	}

	return nil
}

// UpdateCloudRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudRequestMultiError) AllErrors() []error { return m }

// UpdateCloudRequestValidationError is the validation error returned by
// UpdateCloudRequest.Validate if the designated constraints aren't met.
type UpdateCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudRequestValidationError) ErrorName() string {
	return "UpdateCloudRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudRequestValidationError{}

// Validate checks the field values on UpdateCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudResponseMultiError, or nil if none found.
func (m *UpdateCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCloudResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCloudResponseMultiError(errors)
	}

	return nil
}

// UpdateCloudResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateCloudResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudResponseMultiError) AllErrors() []error { return m }

// UpdateCloudResponseValidationError is the validation error returned by
// UpdateCloudResponse.Validate if the designated constraints aren't met.
type UpdateCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudResponseValidationError) ErrorName() string {
	return "UpdateCloudResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudResponseValidationError{}

// Validate checks the field values on DeleteCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudRequestMultiError, or nil if none found.
func (m *DeleteCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 20 {
		err := DeleteCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteCloudRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := DeleteCloudRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForce

	if len(errors) > 0 {
		return DeleteCloudRequestMultiError(errors)
	}

	return nil
}

// DeleteCloudRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudRequestMultiError) AllErrors() []error { return m }

// DeleteCloudRequestValidationError is the validation error returned by
// DeleteCloudRequest.Validate if the designated constraints aren't met.
type DeleteCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudRequestValidationError) ErrorName() string {
	return "DeleteCloudRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudRequestValidationError{}

var _DeleteCloudRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudResponseMultiError, or nil if none found.
func (m *DeleteCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteCloudResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteCloudResponseMultiError(errors)
	}

	return nil
}

// DeleteCloudResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCloudResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudResponseMultiError) AllErrors() []error { return m }

// DeleteCloudResponseValidationError is the validation error returned by
// DeleteCloudResponse.Validate if the designated constraints aren't met.
type DeleteCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudResponseValidationError) ErrorName() string {
	return "DeleteCloudResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudResponseValidationError{}

// Validate checks the field values on GetCloudRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRequestMultiError, or nil if none found.
func (m *GetCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCloudID()); l < 2 || l > 20 {
		err := GetCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetCloudRequest_CloudID_Pattern.MatchString(m.GetCloudID()) {
		err := GetCloudRequestValidationError{
			field:  "CloudID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCloudRequestMultiError(errors)
	}

	return nil
}

// GetCloudRequestMultiError is an error wrapping multiple validation errors
// returned by GetCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type GetCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRequestMultiError) AllErrors() []error { return m }

// GetCloudRequestValidationError is the validation error returned by
// GetCloudRequest.Validate if the designated constraints aren't met.
type GetCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRequestValidationError) ErrorName() string { return "GetCloudRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRequestValidationError{}

var _GetCloudRequest_CloudID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetCloudResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudResponseMultiError, or nil if none found.
func (m *GetCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCloudResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCloudResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCloudResponseMultiError(errors)
	}

	return nil
}

// GetCloudResponseMultiError is an error wrapping multiple validation errors
// returned by GetCloudResponse.ValidateAll() if the designated constraints
// aren't met.
type GetCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudResponseMultiError) AllErrors() []error { return m }

// GetCloudResponseValidationError is the validation error returned by
// GetCloudResponse.Validate if the designated constraints aren't met.
type GetCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudResponseValidationError) ErrorName() string { return "GetCloudResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudResponseValidationError{}

// Validate checks the field values on ListCloudRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudRequestMultiError, or nil if none found.
func (m *ListCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) > 20 {
		err := ListCloudRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Editable

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CloudProvider

	if len(errors) > 0 {
		return ListCloudRequestMultiError(errors)
	}

	return nil
}

// ListCloudRequestMultiError is an error wrapping multiple validation errors
// returned by ListCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type ListCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRequestMultiError) AllErrors() []error { return m }

// ListCloudRequestValidationError is the validation error returned by
// ListCloudRequest.Validate if the designated constraints aren't met.
type ListCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRequestValidationError) ErrorName() string { return "ListCloudRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRequestValidationError{}

// Validate checks the field values on ListCloudResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListCloudResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudResponseMultiError, or nil if none found.
func (m *ListCloudResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudResponseMultiError(errors)
	}

	return nil
}

// ListCloudResponseMultiError is an error wrapping multiple validation errors
// returned by ListCloudResponse.ValidateAll() if the designated constraints
// aren't met.
type ListCloudResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudResponseMultiError) AllErrors() []error { return m }

// ListCloudResponseValidationError is the validation error returned by
// ListCloudResponse.Validate if the designated constraints aren't met.
type ListCloudResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudResponseValidationError) ErrorName() string {
	return "ListCloudResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudResponseValidationError{}

// Validate checks the field values on CreateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeGroupRequestMultiError, or nil if none found.
func (m *CreateNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := CreateNodeGroupRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := CreateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CreateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateNodeGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CreateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 1 || l > 32 {
		err := CreateNodeGroupRequestValidationError{
			field:  "Region",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateNodeGroupRequest_Region_Pattern.MatchString(m.GetRegion()) {
		err := CreateNodeGroupRequestValidationError{
			field:  "Region",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for EnableAutoscale

	if m.GetAutoScaling() == nil {
		err := CreateNodeGroupRequestValidationError{
			field:  "AutoScaling",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAutoScaling()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutoScaling()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupRequestValidationError{
				field:  "AutoScaling",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetLaunchTemplate() == nil {
		err := CreateNodeGroupRequestValidationError{
			field:  "LaunchTemplate",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetLaunchTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLaunchTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupRequestValidationError{
				field:  "LaunchTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	// no validation rules for Taints

	// no validation rules for NodeOS

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateNodeGroupRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	// no validation rules for ConsumerID

	if all {
		switch v := interface{}(m.GetNodeTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupRequestValidationError{
				field:  "NodeTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Tags

	// no validation rules for NodeGroupType

	// no validation rules for BkCloudID

	// no validation rules for CloudAreaName

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupRequestValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupRequestValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OnlyCreateInfo

	if len(errors) > 0 {
		return CreateNodeGroupRequestMultiError(errors)
	}

	return nil
}

// CreateNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by CreateNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeGroupRequestMultiError) AllErrors() []error { return m }

// CreateNodeGroupRequestValidationError is the validation error returned by
// CreateNodeGroupRequest.Validate if the designated constraints aren't met.
type CreateNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeGroupRequestValidationError) ErrorName() string {
	return "CreateNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeGroupRequestValidationError{}

var _CreateNodeGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateNodeGroupRequest_Region_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GroupExtraInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GroupExtraInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupExtraInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GroupExtraInfoMultiError,
// or nil if none found.
func (m *GroupExtraInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupExtraInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	// no validation rules for PoolID

	// no validation rules for ScriptType

	if len(errors) > 0 {
		return GroupExtraInfoMultiError(errors)
	}

	return nil
}

// GroupExtraInfoMultiError is an error wrapping multiple validation errors
// returned by GroupExtraInfo.ValidateAll() if the designated constraints
// aren't met.
type GroupExtraInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupExtraInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupExtraInfoMultiError) AllErrors() []error { return m }

// GroupExtraInfoValidationError is the validation error returned by
// GroupExtraInfo.Validate if the designated constraints aren't met.
type GroupExtraInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupExtraInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupExtraInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupExtraInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupExtraInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupExtraInfoValidationError) ErrorName() string { return "GroupExtraInfoValidationError" }

// Error satisfies the builtin error interface
func (e GroupExtraInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupExtraInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupExtraInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupExtraInfoValidationError{}

// Validate checks the field values on CreateNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeGroupResponseMultiError, or nil if none found.
func (m *CreateNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNodeGroupResponseMultiError(errors)
	}

	return nil
}

// CreateNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by CreateNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeGroupResponseMultiError) AllErrors() []error { return m }

// CreateNodeGroupResponseValidationError is the validation error returned by
// CreateNodeGroupResponse.Validate if the designated constraints aren't met.
type CreateNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeGroupResponseValidationError) ErrorName() string {
	return "CreateNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeGroupResponseValidationError{}

// Validate checks the field values on CreateNodeGroupResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeGroupResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeGroupResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeGroupResponseDataMultiError, or nil if none found.
func (m *CreateNodeGroupResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeGroupResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupResponseDataValidationError{
					field:  "NodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupResponseDataValidationError{
					field:  "NodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupResponseDataValidationError{
				field:  "NodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNodeGroupResponseDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNodeGroupResponseDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNodeGroupResponseDataValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNodeGroupResponseDataMultiError(errors)
	}

	return nil
}

// CreateNodeGroupResponseDataMultiError is an error wrapping multiple
// validation errors returned by CreateNodeGroupResponseData.ValidateAll() if
// the designated constraints aren't met.
type CreateNodeGroupResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeGroupResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeGroupResponseDataMultiError) AllErrors() []error { return m }

// CreateNodeGroupResponseDataValidationError is the validation error returned
// by CreateNodeGroupResponseData.Validate if the designated constraints
// aren't met.
type CreateNodeGroupResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeGroupResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeGroupResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeGroupResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeGroupResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeGroupResponseDataValidationError) ErrorName() string {
	return "CreateNodeGroupResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeGroupResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeGroupResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeGroupResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeGroupResponseDataValidationError{}

// Validate checks the field values on UpdateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeGroupRequestMultiError, or nil if none found.
func (m *UpdateNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetNodeGroupID()) > 20 {
		err := UpdateNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := UpdateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := UpdateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateNodeGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := UpdateNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Region

	if all {
		switch v := interface{}(m.GetEnableAutoscale()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "EnableAutoscale",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "EnableAutoscale",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnableAutoscale()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "EnableAutoscale",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAutoScaling()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutoScaling()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "AutoScaling",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLaunchTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "LaunchTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLaunchTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "LaunchTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNodeTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "NodeTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "NodeTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	// no validation rules for Taints

	// no validation rules for Tags

	// no validation rules for NodeOS

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateNodeGroupRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	// no validation rules for ConsumerID

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetBkCloudID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "BkCloudID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "BkCloudID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBkCloudID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "BkCloudID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCloudAreaName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "CloudAreaName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupRequestValidationError{
					field:  "CloudAreaName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudAreaName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupRequestValidationError{
				field:  "CloudAreaName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OnlyUpdateInfo

	// no validation rules for ExtraInfo

	if len(errors) > 0 {
		return UpdateNodeGroupRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeGroupRequestMultiError) AllErrors() []error { return m }

// UpdateNodeGroupRequestValidationError is the validation error returned by
// UpdateNodeGroupRequest.Validate if the designated constraints aren't met.
type UpdateNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeGroupRequestValidationError) ErrorName() string {
	return "UpdateNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeGroupRequestValidationError{}

var _UpdateNodeGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeGroupResponseMultiError, or nil if none found.
func (m *UpdateNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeGroupResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeGroupResponseMultiError) AllErrors() []error { return m }

// UpdateNodeGroupResponseValidationError is the validation error returned by
// UpdateNodeGroupResponse.Validate if the designated constraints aren't met.
type UpdateNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeGroupResponseValidationError) ErrorName() string {
	return "UpdateNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeGroupResponseValidationError{}

// Validate checks the field values on DeleteNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodeGroupRequestMultiError, or nil if none found.
func (m *DeleteNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := DeleteNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteNodeGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := DeleteNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForce

	// no validation rules for ReserveNodesInCluster

	// no validation rules for KeepNodesInstance

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 100 {
		err := DeleteNodeGroupRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OnlyDeleteInfo

	if len(errors) > 0 {
		return DeleteNodeGroupRequestMultiError(errors)
	}

	return nil
}

// DeleteNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeGroupRequestMultiError) AllErrors() []error { return m }

// DeleteNodeGroupRequestValidationError is the validation error returned by
// DeleteNodeGroupRequest.Validate if the designated constraints aren't met.
type DeleteNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeGroupRequestValidationError) ErrorName() string {
	return "DeleteNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeGroupRequestValidationError{}

var _DeleteNodeGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodeGroupResponseMultiError, or nil if none found.
func (m *DeleteNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodeGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodeGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNodeGroupResponseMultiError(errors)
	}

	return nil
}

// DeleteNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeGroupResponseMultiError) AllErrors() []error { return m }

// DeleteNodeGroupResponseValidationError is the validation error returned by
// DeleteNodeGroupResponse.Validate if the designated constraints aren't met.
type DeleteNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeGroupResponseValidationError) ErrorName() string {
	return "DeleteNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeGroupResponseValidationError{}

// Validate checks the field values on DeleteNodeGroupResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeGroupResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeGroupResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodeGroupResponseDataMultiError, or nil if none found.
func (m *DeleteNodeGroupResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeGroupResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseDataValidationError{
					field:  "NodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseDataValidationError{
					field:  "NodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodeGroupResponseDataValidationError{
				field:  "NodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodeGroupResponseDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodeGroupResponseDataValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNodeGroupResponseDataMultiError(errors)
	}

	return nil
}

// DeleteNodeGroupResponseDataMultiError is an error wrapping multiple
// validation errors returned by DeleteNodeGroupResponseData.ValidateAll() if
// the designated constraints aren't met.
type DeleteNodeGroupResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeGroupResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeGroupResponseDataMultiError) AllErrors() []error { return m }

// DeleteNodeGroupResponseDataValidationError is the validation error returned
// by DeleteNodeGroupResponseData.Validate if the designated constraints
// aren't met.
type DeleteNodeGroupResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeGroupResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeGroupResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeGroupResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeGroupResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeGroupResponseDataValidationError) ErrorName() string {
	return "DeleteNodeGroupResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeGroupResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeGroupResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeGroupResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeGroupResponseDataValidationError{}

// Validate checks the field values on GetNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeGroupRequestMultiError, or nil if none found.
func (m *GetNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := GetNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetNodeGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := GetNodeGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNodeGroupRequestMultiError(errors)
	}

	return nil
}

// GetNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by GetNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type GetNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeGroupRequestMultiError) AllErrors() []error { return m }

// GetNodeGroupRequestValidationError is the validation error returned by
// GetNodeGroupRequest.Validate if the designated constraints aren't met.
type GetNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeGroupRequestValidationError) ErrorName() string {
	return "GetNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeGroupRequestValidationError{}

var _GetNodeGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeGroupResponseMultiError, or nil if none found.
func (m *GetNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNodeGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNodeGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNodeGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNodeGroupResponseMultiError(errors)
	}

	return nil
}

// GetNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by GetNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type GetNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeGroupResponseMultiError) AllErrors() []error { return m }

// GetNodeGroupResponseValidationError is the validation error returned by
// GetNodeGroupResponse.Validate if the designated constraints aren't met.
type GetNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeGroupResponseValidationError) ErrorName() string {
	return "GetNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeGroupResponseValidationError{}

// Validate checks the field values on ListClusterNodeGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterNodeGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterNodeGroupRequestMultiError, or nil if none found.
func (m *ListClusterNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := ListClusterNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := ListClusterNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListClusterNodeGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := ListClusterNodeGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for EnableFilter

	if len(errors) > 0 {
		return ListClusterNodeGroupRequestMultiError(errors)
	}

	return nil
}

// ListClusterNodeGroupRequestMultiError is an error wrapping multiple
// validation errors returned by ListClusterNodeGroupRequest.ValidateAll() if
// the designated constraints aren't met.
type ListClusterNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterNodeGroupRequestMultiError) AllErrors() []error { return m }

// ListClusterNodeGroupRequestValidationError is the validation error returned
// by ListClusterNodeGroupRequest.Validate if the designated constraints
// aren't met.
type ListClusterNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterNodeGroupRequestValidationError) ErrorName() string {
	return "ListClusterNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterNodeGroupRequestValidationError{}

var _ListClusterNodeGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ListClusterNodeGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterNodeGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterNodeGroupResponseMultiError, or nil if none found.
func (m *ListClusterNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListClusterNodeGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListClusterNodeGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListClusterNodeGroupResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListClusterNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListClusterNodeGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListClusterNodeGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListClusterNodeGroupResponseMultiError(errors)
	}

	return nil
}

// ListClusterNodeGroupResponseMultiError is an error wrapping multiple
// validation errors returned by ListClusterNodeGroupResponse.ValidateAll() if
// the designated constraints aren't met.
type ListClusterNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterNodeGroupResponseMultiError) AllErrors() []error { return m }

// ListClusterNodeGroupResponseValidationError is the validation error returned
// by ListClusterNodeGroupResponse.Validate if the designated constraints
// aren't met.
type ListClusterNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterNodeGroupResponseValidationError) ErrorName() string {
	return "ListClusterNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterNodeGroupResponseValidationError{}

// Validate checks the field values on ListNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodeGroupRequestMultiError, or nil if none found.
func (m *ListNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ClusterID

	// no validation rules for Region

	// no validation rules for ProjectID

	if len(errors) > 0 {
		return ListNodeGroupRequestMultiError(errors)
	}

	return nil
}

// ListNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by ListNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type ListNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodeGroupRequestMultiError) AllErrors() []error { return m }

// ListNodeGroupRequestValidationError is the validation error returned by
// ListNodeGroupRequest.Validate if the designated constraints aren't met.
type ListNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodeGroupRequestValidationError) ErrorName() string {
	return "ListNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodeGroupRequestValidationError{}

// Validate checks the field values on ListNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodeGroupResponseMultiError, or nil if none found.
func (m *ListNodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodeGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodeGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodeGroupResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNodeGroupResponseMultiError(errors)
	}

	return nil
}

// ListNodeGroupResponseMultiError is an error wrapping multiple validation
// errors returned by ListNodeGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type ListNodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodeGroupResponseMultiError) AllErrors() []error { return m }

// ListNodeGroupResponseValidationError is the validation error returned by
// ListNodeGroupResponse.Validate if the designated constraints aren't met.
type ListNodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodeGroupResponseValidationError) ErrorName() string {
	return "ListNodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodeGroupResponseValidationError{}

// Validate checks the field values on AddNodesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNodesRequestMultiError, or nil if none found.
func (m *AddNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := AddNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := AddNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_AddNodesRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := AddNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNodes()) < 1 {
		err := AddNodesRequestValidationError{
			field:  "Nodes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_AddNodesRequest_Nodes_Unique := make(map[string]struct{}, len(m.GetNodes()))

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if _, exists := _AddNodesRequest_Nodes_Unique[item]; exists {
			err := AddNodesRequestValidationError{
				field:  fmt.Sprintf("Nodes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_AddNodesRequest_Nodes_Unique[item] = struct{}{}
		}

		// no validation rules for Nodes[idx]
	}

	// no validation rules for InitLoginPassword

	// no validation rules for NodeGroupID

	// no validation rules for OnlyCreateInfo

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := AddNodesRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NodeTemplateID

	// no validation rules for IsExternalNode

	if all {
		switch v := interface{}(m.GetLogin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNodesRequestValidationError{
					field:  "Login",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNodesRequestValidationError{
					field:  "Login",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNodesRequestValidationError{
				field:  "Login",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNodesRequestMultiError(errors)
	}

	return nil
}

// AddNodesRequestMultiError is an error wrapping multiple validation errors
// returned by AddNodesRequest.ValidateAll() if the designated constraints
// aren't met.
type AddNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNodesRequestMultiError) AllErrors() []error { return m }

// AddNodesRequestValidationError is the validation error returned by
// AddNodesRequest.Validate if the designated constraints aren't met.
type AddNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNodesRequestValidationError) ErrorName() string { return "AddNodesRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNodesRequestValidationError{}

var _AddNodesRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on AddNodesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNodesResponseMultiError, or nil if none found.
func (m *AddNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNodesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNodesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNodesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNodesResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNodesResponseMultiError(errors)
	}

	return nil
}

// AddNodesResponseMultiError is an error wrapping multiple validation errors
// returned by AddNodesResponse.ValidateAll() if the designated constraints
// aren't met.
type AddNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNodesResponseMultiError) AllErrors() []error { return m }

// AddNodesResponseValidationError is the validation error returned by
// AddNodesResponse.Validate if the designated constraints aren't met.
type AddNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNodesResponseValidationError) ErrorName() string { return "AddNodesResponseValidationError" }

// Error satisfies the builtin error interface
func (e AddNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNodesResponseValidationError{}

// Validate checks the field values on BatchDeleteClusterNodesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchDeleteClusterNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchDeleteClusterNodesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatchDeleteClusterNodesRequestMultiError, or nil if none found.
func (m *BatchDeleteClusterNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchDeleteClusterNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := BatchDeleteClusterNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := BatchDeleteClusterNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BatchDeleteClusterNodesRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := BatchDeleteClusterNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NodeIPs

	// no validation rules for VirtualNodeIDs

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := BatchDeleteClusterNodesRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DeleteMode

	if len(errors) > 0 {
		return BatchDeleteClusterNodesRequestMultiError(errors)
	}

	return nil
}

// BatchDeleteClusterNodesRequestMultiError is an error wrapping multiple
// validation errors returned by BatchDeleteClusterNodesRequest.ValidateAll()
// if the designated constraints aren't met.
type BatchDeleteClusterNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchDeleteClusterNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchDeleteClusterNodesRequestMultiError) AllErrors() []error { return m }

// BatchDeleteClusterNodesRequestValidationError is the validation error
// returned by BatchDeleteClusterNodesRequest.Validate if the designated
// constraints aren't met.
type BatchDeleteClusterNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchDeleteClusterNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchDeleteClusterNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchDeleteClusterNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchDeleteClusterNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchDeleteClusterNodesRequestValidationError) ErrorName() string {
	return "BatchDeleteClusterNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchDeleteClusterNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchDeleteClusterNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchDeleteClusterNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchDeleteClusterNodesRequestValidationError{}

var _BatchDeleteClusterNodesRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on BatchDeleteClusterNodesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchDeleteClusterNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchDeleteClusterNodesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatchDeleteClusterNodesResponseMultiError, or nil if none found.
func (m *BatchDeleteClusterNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchDeleteClusterNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchDeleteClusterNodesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchDeleteClusterNodesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchDeleteClusterNodesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchDeleteClusterNodesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchDeleteClusterNodesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchDeleteClusterNodesResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchDeleteClusterNodesResponseMultiError(errors)
	}

	return nil
}

// BatchDeleteClusterNodesResponseMultiError is an error wrapping multiple
// validation errors returned by BatchDeleteClusterNodesResponse.ValidateAll()
// if the designated constraints aren't met.
type BatchDeleteClusterNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchDeleteClusterNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchDeleteClusterNodesResponseMultiError) AllErrors() []error { return m }

// BatchDeleteClusterNodesResponseValidationError is the validation error
// returned by BatchDeleteClusterNodesResponse.Validate if the designated
// constraints aren't met.
type BatchDeleteClusterNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchDeleteClusterNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchDeleteClusterNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchDeleteClusterNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchDeleteClusterNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchDeleteClusterNodesResponseValidationError) ErrorName() string {
	return "BatchDeleteClusterNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatchDeleteClusterNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchDeleteClusterNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchDeleteClusterNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchDeleteClusterNodesResponseValidationError{}

// Validate checks the field values on BatchNodesStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BatchNodesStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchNodesStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchNodesStatusMultiError, or nil if none found.
func (m *BatchNodesStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchNodesStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	// no validation rules for TaskID

	// no validation rules for NodeGroupID

	// no validation rules for NodeGroupType

	if len(errors) > 0 {
		return BatchNodesStatusMultiError(errors)
	}

	return nil
}

// BatchNodesStatusMultiError is an error wrapping multiple validation errors
// returned by BatchNodesStatus.ValidateAll() if the designated constraints
// aren't met.
type BatchNodesStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchNodesStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchNodesStatusMultiError) AllErrors() []error { return m }

// BatchNodesStatusValidationError is the validation error returned by
// BatchNodesStatus.Validate if the designated constraints aren't met.
type BatchNodesStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchNodesStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchNodesStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchNodesStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchNodesStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchNodesStatusValidationError) ErrorName() string { return "BatchNodesStatusValidationError" }

// Error satisfies the builtin error interface
func (e BatchNodesStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchNodesStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchNodesStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchNodesStatusValidationError{}

// Validate checks the field values on DeleteNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodesRequestMultiError, or nil if none found.
func (m *DeleteNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := DeleteNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := DeleteNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteNodesRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := DeleteNodesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNodes()) < 1 {
		err := DeleteNodesRequestValidationError{
			field:  "Nodes",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DeleteMode

	// no validation rules for IsForce

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := DeleteNodesRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OnlyDeleteInfo

	// no validation rules for NodeTemplateID

	// no validation rules for NodeGroupID

	// no validation rules for IsExternalNode

	if len(errors) > 0 {
		return DeleteNodesRequestMultiError(errors)
	}

	return nil
}

// DeleteNodesRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteNodesRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodesRequestMultiError) AllErrors() []error { return m }

// DeleteNodesRequestValidationError is the validation error returned by
// DeleteNodesRequest.Validate if the designated constraints aren't met.
type DeleteNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodesRequestValidationError) ErrorName() string {
	return "DeleteNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodesRequestValidationError{}

var _DeleteNodesRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNodesResponseMultiError, or nil if none found.
func (m *DeleteNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNodesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNodesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNodesResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNodesResponseMultiError(errors)
	}

	return nil
}

// DeleteNodesResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteNodesResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodesResponseMultiError) AllErrors() []error { return m }

// DeleteNodesResponseValidationError is the validation error returned by
// DeleteNodesResponse.Validate if the designated constraints aren't met.
type DeleteNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodesResponseValidationError) ErrorName() string {
	return "DeleteNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodesResponseValidationError{}

// Validate checks the field values on MoveNodesToGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MoveNodesToGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoveNodesToGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MoveNodesToGroupRequestMultiError, or nil if none found.
func (m *MoveNodesToGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MoveNodesToGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := MoveNodesToGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := MoveNodesToGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_MoveNodesToGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := MoveNodesToGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetNodes()); l < 1 || l > 100 {
		err := MoveNodesToGroupRequestValidationError{
			field:  "Nodes",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_MoveNodesToGroupRequest_Nodes_Unique := make(map[string]struct{}, len(m.GetNodes()))

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if _, exists := _MoveNodesToGroupRequest_Nodes_Unique[item]; exists {
			err := MoveNodesToGroupRequestValidationError{
				field:  fmt.Sprintf("Nodes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_MoveNodesToGroupRequest_Nodes_Unique[item] = struct{}{}
		}

		// no validation rules for Nodes[idx]
	}

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := MoveNodesToGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_MoveNodesToGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := MoveNodesToGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MoveNodesToGroupRequestMultiError(errors)
	}

	return nil
}

// MoveNodesToGroupRequestMultiError is an error wrapping multiple validation
// errors returned by MoveNodesToGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type MoveNodesToGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoveNodesToGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoveNodesToGroupRequestMultiError) AllErrors() []error { return m }

// MoveNodesToGroupRequestValidationError is the validation error returned by
// MoveNodesToGroupRequest.Validate if the designated constraints aren't met.
type MoveNodesToGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoveNodesToGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoveNodesToGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoveNodesToGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoveNodesToGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoveNodesToGroupRequestValidationError) ErrorName() string {
	return "MoveNodesToGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MoveNodesToGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoveNodesToGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoveNodesToGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoveNodesToGroupRequestValidationError{}

var _MoveNodesToGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _MoveNodesToGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on MoveNodesToGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MoveNodesToGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoveNodesToGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MoveNodesToGroupResponseMultiError, or nil if none found.
func (m *MoveNodesToGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MoveNodesToGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MoveNodesToGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MoveNodesToGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MoveNodesToGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MoveNodesToGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MoveNodesToGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MoveNodesToGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MoveNodesToGroupResponseMultiError(errors)
	}

	return nil
}

// MoveNodesToGroupResponseMultiError is an error wrapping multiple validation
// errors returned by MoveNodesToGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type MoveNodesToGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoveNodesToGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoveNodesToGroupResponseMultiError) AllErrors() []error { return m }

// MoveNodesToGroupResponseValidationError is the validation error returned by
// MoveNodesToGroupResponse.Validate if the designated constraints aren't met.
type MoveNodesToGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoveNodesToGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoveNodesToGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoveNodesToGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoveNodesToGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoveNodesToGroupResponseValidationError) ErrorName() string {
	return "MoveNodesToGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MoveNodesToGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoveNodesToGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoveNodesToGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoveNodesToGroupResponseValidationError{}

// Validate checks the field values on RemoveNodesFromGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveNodesFromGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveNodesFromGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveNodesFromGroupRequestMultiError, or nil if none found.
func (m *RemoveNodesFromGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveNodesFromGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RemoveNodesFromGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetNodes()); l < 1 || l > 100 {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "Nodes",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_RemoveNodesFromGroupRequest_Nodes_Unique := make(map[string]struct{}, len(m.GetNodes()))

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if _, exists := _RemoveNodesFromGroupRequest_Nodes_Unique[item]; exists {
			err := RemoveNodesFromGroupRequestValidationError{
				field:  fmt.Sprintf("Nodes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_RemoveNodesFromGroupRequest_Nodes_Unique[item] = struct{}{}
		}

		// no validation rules for Nodes[idx]
	}

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RemoveNodesFromGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := RemoveNodesFromGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RemoveNodesFromGroupRequestMultiError(errors)
	}

	return nil
}

// RemoveNodesFromGroupRequestMultiError is an error wrapping multiple
// validation errors returned by RemoveNodesFromGroupRequest.ValidateAll() if
// the designated constraints aren't met.
type RemoveNodesFromGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveNodesFromGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveNodesFromGroupRequestMultiError) AllErrors() []error { return m }

// RemoveNodesFromGroupRequestValidationError is the validation error returned
// by RemoveNodesFromGroupRequest.Validate if the designated constraints
// aren't met.
type RemoveNodesFromGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveNodesFromGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveNodesFromGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveNodesFromGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveNodesFromGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveNodesFromGroupRequestValidationError) ErrorName() string {
	return "RemoveNodesFromGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveNodesFromGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveNodesFromGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveNodesFromGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveNodesFromGroupRequestValidationError{}

var _RemoveNodesFromGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _RemoveNodesFromGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on RemoveNodesFromGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveNodesFromGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveNodesFromGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveNodesFromGroupResponseMultiError, or nil if none found.
func (m *RemoveNodesFromGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveNodesFromGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RemoveNodesFromGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RemoveNodesFromGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RemoveNodesFromGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RemoveNodesFromGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RemoveNodesFromGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RemoveNodesFromGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RemoveNodesFromGroupResponseMultiError(errors)
	}

	return nil
}

// RemoveNodesFromGroupResponseMultiError is an error wrapping multiple
// validation errors returned by RemoveNodesFromGroupResponse.ValidateAll() if
// the designated constraints aren't met.
type RemoveNodesFromGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveNodesFromGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveNodesFromGroupResponseMultiError) AllErrors() []error { return m }

// RemoveNodesFromGroupResponseValidationError is the validation error returned
// by RemoveNodesFromGroupResponse.Validate if the designated constraints
// aren't met.
type RemoveNodesFromGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveNodesFromGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveNodesFromGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveNodesFromGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveNodesFromGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveNodesFromGroupResponseValidationError) ErrorName() string {
	return "RemoveNodesFromGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveNodesFromGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveNodesFromGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveNodesFromGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveNodesFromGroupResponseValidationError{}

// Validate checks the field values on CleanNodesInGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanNodesInGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanNodesInGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanNodesInGroupRequestMultiError, or nil if none found.
func (m *CleanNodesInGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanNodesInGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := CleanNodesInGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CleanNodesInGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CleanNodesInGroupRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetNodes()); l < 1 || l > 100 {
		err := CleanNodesInGroupRequestValidationError{
			field:  "Nodes",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CleanNodesInGroupRequest_Nodes_Unique := make(map[string]struct{}, len(m.GetNodes()))

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if _, exists := _CleanNodesInGroupRequest_Nodes_Unique[item]; exists {
			err := CleanNodesInGroupRequestValidationError{
				field:  fmt.Sprintf("Nodes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CleanNodesInGroupRequest_Nodes_Unique[item] = struct{}{}
		}

		// no validation rules for Nodes[idx]
	}

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := CleanNodesInGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := CleanNodesInGroupRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := CleanNodesInGroupRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CleanNodesInGroupRequestMultiError(errors)
	}

	return nil
}

// CleanNodesInGroupRequestMultiError is an error wrapping multiple validation
// errors returned by CleanNodesInGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type CleanNodesInGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanNodesInGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanNodesInGroupRequestMultiError) AllErrors() []error { return m }

// CleanNodesInGroupRequestValidationError is the validation error returned by
// CleanNodesInGroupRequest.Validate if the designated constraints aren't met.
type CleanNodesInGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanNodesInGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanNodesInGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanNodesInGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanNodesInGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanNodesInGroupRequestValidationError) ErrorName() string {
	return "CleanNodesInGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CleanNodesInGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanNodesInGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanNodesInGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanNodesInGroupRequestValidationError{}

var _CleanNodesInGroupRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CleanNodesInGroupRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CleanNodesInGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanNodesInGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanNodesInGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanNodesInGroupResponseMultiError, or nil if none found.
func (m *CleanNodesInGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanNodesInGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CleanNodesInGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CleanNodesInGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CleanNodesInGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CleanNodesInGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CleanNodesInGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CleanNodesInGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CleanNodesInGroupResponseMultiError(errors)
	}

	return nil
}

// CleanNodesInGroupResponseMultiError is an error wrapping multiple validation
// errors returned by CleanNodesInGroupResponse.ValidateAll() if the
// designated constraints aren't met.
type CleanNodesInGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanNodesInGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanNodesInGroupResponseMultiError) AllErrors() []error { return m }

// CleanNodesInGroupResponseValidationError is the validation error returned by
// CleanNodesInGroupResponse.Validate if the designated constraints aren't met.
type CleanNodesInGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanNodesInGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanNodesInGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanNodesInGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanNodesInGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanNodesInGroupResponseValidationError) ErrorName() string {
	return "CleanNodesInGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CleanNodesInGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanNodesInGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanNodesInGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanNodesInGroupResponseValidationError{}

// Validate checks the field values on CleanNodesInGroupV2Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanNodesInGroupV2Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanNodesInGroupV2Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanNodesInGroupV2RequestMultiError, or nil if none found.
func (m *CleanNodesInGroupV2Request) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanNodesInGroupV2Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 5 || l > 100 {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupV2Request_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNodes()) < 1 {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "Nodes",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CleanNodesInGroupV2Request_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOperator()); l < 2 || l > 20 {
		err := CleanNodesInGroupV2RequestValidationError{
			field:  "Operator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CleanNodesInGroupV2RequestMultiError(errors)
	}

	return nil
}

// CleanNodesInGroupV2RequestMultiError is an error wrapping multiple
// validation errors returned by CleanNodesInGroupV2Request.ValidateAll() if
// the designated constraints aren't met.
type CleanNodesInGroupV2RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanNodesInGroupV2RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanNodesInGroupV2RequestMultiError) AllErrors() []error { return m }

// CleanNodesInGroupV2RequestValidationError is the validation error returned
// by CleanNodesInGroupV2Request.Validate if the designated constraints aren't met.
type CleanNodesInGroupV2RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanNodesInGroupV2RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanNodesInGroupV2RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanNodesInGroupV2RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanNodesInGroupV2RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanNodesInGroupV2RequestValidationError) ErrorName() string {
	return "CleanNodesInGroupV2RequestValidationError"
}

// Error satisfies the builtin error interface
func (e CleanNodesInGroupV2RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanNodesInGroupV2Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanNodesInGroupV2RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanNodesInGroupV2RequestValidationError{}

var _CleanNodesInGroupV2Request_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CleanNodesInGroupV2Request_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CleanNodesInGroupV2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanNodesInGroupV2Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanNodesInGroupV2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanNodesInGroupV2ResponseMultiError, or nil if none found.
func (m *CleanNodesInGroupV2Response) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanNodesInGroupV2Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CleanNodesInGroupV2ResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CleanNodesInGroupV2ResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CleanNodesInGroupV2ResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CleanNodesInGroupV2ResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CleanNodesInGroupV2ResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CleanNodesInGroupV2ResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CleanNodesInGroupV2ResponseMultiError(errors)
	}

	return nil
}

// CleanNodesInGroupV2ResponseMultiError is an error wrapping multiple
// validation errors returned by CleanNodesInGroupV2Response.ValidateAll() if
// the designated constraints aren't met.
type CleanNodesInGroupV2ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanNodesInGroupV2ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanNodesInGroupV2ResponseMultiError) AllErrors() []error { return m }

// CleanNodesInGroupV2ResponseValidationError is the validation error returned
// by CleanNodesInGroupV2Response.Validate if the designated constraints
// aren't met.
type CleanNodesInGroupV2ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanNodesInGroupV2ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanNodesInGroupV2ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanNodesInGroupV2ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanNodesInGroupV2ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanNodesInGroupV2ResponseValidationError) ErrorName() string {
	return "CleanNodesInGroupV2ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CleanNodesInGroupV2ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanNodesInGroupV2Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanNodesInGroupV2ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanNodesInGroupV2ResponseValidationError{}

// Validate checks the field values on ListNodesInGroupV2Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInGroupV2Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInGroupV2Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInGroupV2RequestMultiError, or nil if none found.
func (m *ListNodesInGroupV2Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInGroupV2Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 2 || l > 20 {
		err := ListNodesInGroupV2RequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListNodesInGroupV2Request_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := ListNodesInGroupV2RequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Output

	if len(errors) > 0 {
		return ListNodesInGroupV2RequestMultiError(errors)
	}

	return nil
}

// ListNodesInGroupV2RequestMultiError is an error wrapping multiple validation
// errors returned by ListNodesInGroupV2Request.ValidateAll() if the
// designated constraints aren't met.
type ListNodesInGroupV2RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInGroupV2RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInGroupV2RequestMultiError) AllErrors() []error { return m }

// ListNodesInGroupV2RequestValidationError is the validation error returned by
// ListNodesInGroupV2Request.Validate if the designated constraints aren't met.
type ListNodesInGroupV2RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInGroupV2RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInGroupV2RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInGroupV2RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInGroupV2RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInGroupV2RequestValidationError) ErrorName() string {
	return "ListNodesInGroupV2RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInGroupV2RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInGroupV2Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInGroupV2RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInGroupV2RequestValidationError{}

var _ListNodesInGroupV2Request_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ListNodesInGroupV2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInGroupV2Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInGroupV2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInGroupV2ResponseMultiError, or nil if none found.
func (m *ListNodesInGroupV2Response) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInGroupV2Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodesInGroupV2ResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodesInGroupV2ResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodesInGroupV2ResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNodesInGroupV2ResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNodesInGroupV2ResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNodesInGroupV2ResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListNodesInGroupV2ResponseMultiError(errors)
	}

	return nil
}

// ListNodesInGroupV2ResponseMultiError is an error wrapping multiple
// validation errors returned by ListNodesInGroupV2Response.ValidateAll() if
// the designated constraints aren't met.
type ListNodesInGroupV2ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInGroupV2ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInGroupV2ResponseMultiError) AllErrors() []error { return m }

// ListNodesInGroupV2ResponseValidationError is the validation error returned
// by ListNodesInGroupV2Response.Validate if the designated constraints aren't met.
type ListNodesInGroupV2ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInGroupV2ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInGroupV2ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInGroupV2ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInGroupV2ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInGroupV2ResponseValidationError) ErrorName() string {
	return "ListNodesInGroupV2ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInGroupV2ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInGroupV2Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInGroupV2ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInGroupV2ResponseValidationError{}

// Validate checks the field values on NodeGroupNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroupNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupNodeMultiError, or
// nil if none found.
func (m *NodeGroupNode) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeID

	// no validation rules for InnerIP

	// no validation rules for InstanceType

	// no validation rules for CPU

	// no validation rules for Mem

	// no validation rules for GPU

	// no validation rules for Status

	// no validation rules for ZoneID

	// no validation rules for NodeGroupID

	// no validation rules for ClusterID

	// no validation rules for VPC

	// no validation rules for Region

	// no validation rules for Passwd

	// no validation rules for Zone

	// no validation rules for DeviceID

	// no validation rules for InstanceRole

	// no validation rules for UnSchedulable

	// no validation rules for NodeName

	if len(errors) > 0 {
		return NodeGroupNodeMultiError(errors)
	}

	return nil
}

// NodeGroupNodeMultiError is an error wrapping multiple validation errors
// returned by NodeGroupNode.ValidateAll() if the designated constraints
// aren't met.
type NodeGroupNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupNodeMultiError) AllErrors() []error { return m }

// NodeGroupNodeValidationError is the validation error returned by
// NodeGroupNode.Validate if the designated constraints aren't met.
type NodeGroupNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupNodeValidationError) ErrorName() string { return "NodeGroupNodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupNodeValidationError{}

// Validate checks the field values on ListNodesInGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNodesInGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesInGroupResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNodesInGroupResponseMultiError, or nil if none found.
func (m *ListNodesInGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesInGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodesInGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodesInGroupResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodesInGroupResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNodesInGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNodesInGroupResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNodesInGroupResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListNodesInGroupResponseMultiError(errors)
	}

	return nil
}

// ListNodesInGroupResponseMultiError is an error wrapping multiple validation
// errors returned by ListNodesInGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type ListNodesInGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesInGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesInGroupResponseMultiError) AllErrors() []error { return m }

// ListNodesInGroupResponseValidationError is the validation error returned by
// ListNodesInGroupResponse.Validate if the designated constraints aren't met.
type ListNodesInGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesInGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesInGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesInGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesInGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesInGroupResponseValidationError) ErrorName() string {
	return "ListNodesInGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesInGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesInGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesInGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesInGroupResponseValidationError{}

// Validate checks the field values on UpdateGroupMinMaxSizeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupMinMaxSizeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupMinMaxSizeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateGroupMinMaxSizeRequestMultiError, or nil if none found.
func (m *UpdateGroupMinMaxSizeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupMinMaxSizeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := UpdateGroupMinMaxSizeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateGroupMinMaxSizeRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := UpdateGroupMinMaxSizeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMinSize() < 0 {
		err := UpdateGroupMinMaxSizeRequestValidationError{
			field:  "MinSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMaxSize() < 0 {
		err := UpdateGroupMinMaxSizeRequestValidationError{
			field:  "MaxSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOperator()); l < 1 || l > 100 {
		err := UpdateGroupMinMaxSizeRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateGroupMinMaxSizeRequestMultiError(errors)
	}

	return nil
}

// UpdateGroupMinMaxSizeRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupMinMaxSizeRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateGroupMinMaxSizeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupMinMaxSizeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupMinMaxSizeRequestMultiError) AllErrors() []error { return m }

// UpdateGroupMinMaxSizeRequestValidationError is the validation error returned
// by UpdateGroupMinMaxSizeRequest.Validate if the designated constraints
// aren't met.
type UpdateGroupMinMaxSizeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupMinMaxSizeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupMinMaxSizeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupMinMaxSizeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupMinMaxSizeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupMinMaxSizeRequestValidationError) ErrorName() string {
	return "UpdateGroupMinMaxSizeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupMinMaxSizeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupMinMaxSizeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupMinMaxSizeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupMinMaxSizeRequestValidationError{}

var _UpdateGroupMinMaxSizeRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateGroupMinMaxSizeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupMinMaxSizeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupMinMaxSizeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupMinMaxSizeResponseMultiError, or nil if none found.
func (m *UpdateGroupMinMaxSizeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupMinMaxSizeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateGroupMinMaxSizeResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateGroupMinMaxSizeResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateGroupMinMaxSizeResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateGroupMinMaxSizeResponseMultiError(errors)
	}

	return nil
}

// UpdateGroupMinMaxSizeResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupMinMaxSizeResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupMinMaxSizeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupMinMaxSizeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupMinMaxSizeResponseMultiError) AllErrors() []error { return m }

// UpdateGroupMinMaxSizeResponseValidationError is the validation error
// returned by UpdateGroupMinMaxSizeResponse.Validate if the designated
// constraints aren't met.
type UpdateGroupMinMaxSizeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupMinMaxSizeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupMinMaxSizeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupMinMaxSizeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupMinMaxSizeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupMinMaxSizeResponseValidationError) ErrorName() string {
	return "UpdateGroupMinMaxSizeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupMinMaxSizeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupMinMaxSizeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupMinMaxSizeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupMinMaxSizeResponseValidationError{}

// Validate checks the field values on TransNodeGroupToNodeTemplateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TransNodeGroupToNodeTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransNodeGroupToNodeTemplateRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TransNodeGroupToNodeTemplateRequestMultiError, or nil if none found.
func (m *TransNodeGroupToNodeTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TransNodeGroupToNodeTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 1 || l > 100 {
		err := TransNodeGroupToNodeTemplateRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_TransNodeGroupToNodeTemplateRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := TransNodeGroupToNodeTemplateRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TransNodeGroupToNodeTemplateRequestMultiError(errors)
	}

	return nil
}

// TransNodeGroupToNodeTemplateRequestMultiError is an error wrapping multiple
// validation errors returned by
// TransNodeGroupToNodeTemplateRequest.ValidateAll() if the designated
// constraints aren't met.
type TransNodeGroupToNodeTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransNodeGroupToNodeTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransNodeGroupToNodeTemplateRequestMultiError) AllErrors() []error { return m }

// TransNodeGroupToNodeTemplateRequestValidationError is the validation error
// returned by TransNodeGroupToNodeTemplateRequest.Validate if the designated
// constraints aren't met.
type TransNodeGroupToNodeTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransNodeGroupToNodeTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransNodeGroupToNodeTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransNodeGroupToNodeTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransNodeGroupToNodeTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransNodeGroupToNodeTemplateRequestValidationError) ErrorName() string {
	return "TransNodeGroupToNodeTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TransNodeGroupToNodeTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransNodeGroupToNodeTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransNodeGroupToNodeTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransNodeGroupToNodeTemplateRequestValidationError{}

var _TransNodeGroupToNodeTemplateRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on TransNodeGroupToNodeTemplateResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *TransNodeGroupToNodeTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransNodeGroupToNodeTemplateResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TransNodeGroupToNodeTemplateResponseMultiError, or nil if none found.
func (m *TransNodeGroupToNodeTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TransNodeGroupToNodeTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransNodeGroupToNodeTemplateResponseValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransNodeGroupToNodeTemplateResponseValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransNodeGroupToNodeTemplateResponseValidationError{
				field:  "Template",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransNodeGroupToNodeTemplateResponseMultiError(errors)
	}

	return nil
}

// TransNodeGroupToNodeTemplateResponseMultiError is an error wrapping multiple
// validation errors returned by
// TransNodeGroupToNodeTemplateResponse.ValidateAll() if the designated
// constraints aren't met.
type TransNodeGroupToNodeTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransNodeGroupToNodeTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransNodeGroupToNodeTemplateResponseMultiError) AllErrors() []error { return m }

// TransNodeGroupToNodeTemplateResponseValidationError is the validation error
// returned by TransNodeGroupToNodeTemplateResponse.Validate if the designated
// constraints aren't met.
type TransNodeGroupToNodeTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransNodeGroupToNodeTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransNodeGroupToNodeTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransNodeGroupToNodeTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransNodeGroupToNodeTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransNodeGroupToNodeTemplateResponseValidationError) ErrorName() string {
	return "TransNodeGroupToNodeTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TransNodeGroupToNodeTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransNodeGroupToNodeTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransNodeGroupToNodeTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransNodeGroupToNodeTemplateResponseValidationError{}

// Validate checks the field values on UpdateGroupDesiredSizeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupDesiredSizeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupDesiredSizeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupDesiredSizeRequestMultiError, or nil if none found.
func (m *UpdateGroupDesiredSizeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupDesiredSizeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := UpdateGroupDesiredSizeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateGroupDesiredSizeRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := UpdateGroupDesiredSizeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DesiredSize

	if utf8.RuneCountInString(m.GetOperator()) > 100 {
		err := UpdateGroupDesiredSizeRequestValidationError{
			field:  "Operator",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateGroupDesiredSizeRequestMultiError(errors)
	}

	return nil
}

// UpdateGroupDesiredSizeRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupDesiredSizeRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupDesiredSizeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupDesiredSizeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupDesiredSizeRequestMultiError) AllErrors() []error { return m }

// UpdateGroupDesiredSizeRequestValidationError is the validation error
// returned by UpdateGroupDesiredSizeRequest.Validate if the designated
// constraints aren't met.
type UpdateGroupDesiredSizeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupDesiredSizeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupDesiredSizeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupDesiredSizeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupDesiredSizeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupDesiredSizeRequestValidationError) ErrorName() string {
	return "UpdateGroupDesiredSizeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupDesiredSizeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupDesiredSizeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupDesiredSizeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupDesiredSizeRequestValidationError{}

var _UpdateGroupDesiredSizeRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateGroupDesiredSizeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupDesiredSizeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupDesiredSizeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupDesiredSizeResponseMultiError, or nil if none found.
func (m *UpdateGroupDesiredSizeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupDesiredSizeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateGroupDesiredSizeResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateGroupDesiredSizeResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateGroupDesiredSizeResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateGroupDesiredSizeResponseMultiError(errors)
	}

	return nil
}

// UpdateGroupDesiredSizeResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupDesiredSizeResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupDesiredSizeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupDesiredSizeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupDesiredSizeResponseMultiError) AllErrors() []error { return m }

// UpdateGroupDesiredSizeResponseValidationError is the validation error
// returned by UpdateGroupDesiredSizeResponse.Validate if the designated
// constraints aren't met.
type UpdateGroupDesiredSizeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupDesiredSizeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupDesiredSizeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupDesiredSizeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupDesiredSizeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupDesiredSizeResponseValidationError) ErrorName() string {
	return "UpdateGroupDesiredSizeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupDesiredSizeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupDesiredSizeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupDesiredSizeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupDesiredSizeResponseValidationError{}

// Validate checks the field values on UpdateGroupDesiredNodeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupDesiredNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupDesiredNodeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupDesiredNodeRequestMultiError, or nil if none found.
func (m *UpdateGroupDesiredNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupDesiredNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := UpdateGroupDesiredNodeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateGroupDesiredNodeRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := UpdateGroupDesiredNodeRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DesiredNode

	if utf8.RuneCountInString(m.GetOperator()) > 100 {
		err := UpdateGroupDesiredNodeRequestValidationError{
			field:  "Operator",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Manual

	if len(errors) > 0 {
		return UpdateGroupDesiredNodeRequestMultiError(errors)
	}

	return nil
}

// UpdateGroupDesiredNodeRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupDesiredNodeRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupDesiredNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupDesiredNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupDesiredNodeRequestMultiError) AllErrors() []error { return m }

// UpdateGroupDesiredNodeRequestValidationError is the validation error
// returned by UpdateGroupDesiredNodeRequest.Validate if the designated
// constraints aren't met.
type UpdateGroupDesiredNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupDesiredNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupDesiredNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupDesiredNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupDesiredNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupDesiredNodeRequestValidationError) ErrorName() string {
	return "UpdateGroupDesiredNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupDesiredNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupDesiredNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupDesiredNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupDesiredNodeRequestValidationError{}

var _UpdateGroupDesiredNodeRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on UpdateGroupDesiredNodeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupDesiredNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupDesiredNodeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateGroupDesiredNodeResponseMultiError, or nil if none found.
func (m *UpdateGroupDesiredNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupDesiredNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateGroupDesiredNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateGroupDesiredNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateGroupDesiredNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateGroupDesiredNodeResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateGroupDesiredNodeResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateGroupDesiredNodeResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateGroupDesiredNodeResponseMultiError(errors)
	}

	return nil
}

// UpdateGroupDesiredNodeResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateGroupDesiredNodeResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateGroupDesiredNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupDesiredNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupDesiredNodeResponseMultiError) AllErrors() []error { return m }

// UpdateGroupDesiredNodeResponseValidationError is the validation error
// returned by UpdateGroupDesiredNodeResponse.Validate if the designated
// constraints aren't met.
type UpdateGroupDesiredNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupDesiredNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupDesiredNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupDesiredNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupDesiredNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupDesiredNodeResponseValidationError) ErrorName() string {
	return "UpdateGroupDesiredNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupDesiredNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupDesiredNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupDesiredNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupDesiredNodeResponseValidationError{}

// Validate checks the field values on EnableNodeGroupAutoScaleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnableNodeGroupAutoScaleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableNodeGroupAutoScaleRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EnableNodeGroupAutoScaleRequestMultiError, or nil if none found.
func (m *EnableNodeGroupAutoScaleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableNodeGroupAutoScaleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := EnableNodeGroupAutoScaleRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EnableNodeGroupAutoScaleRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := EnableNodeGroupAutoScaleRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EnableNodeGroupAutoScaleRequestMultiError(errors)
	}

	return nil
}

// EnableNodeGroupAutoScaleRequestMultiError is an error wrapping multiple
// validation errors returned by EnableNodeGroupAutoScaleRequest.ValidateAll()
// if the designated constraints aren't met.
type EnableNodeGroupAutoScaleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableNodeGroupAutoScaleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableNodeGroupAutoScaleRequestMultiError) AllErrors() []error { return m }

// EnableNodeGroupAutoScaleRequestValidationError is the validation error
// returned by EnableNodeGroupAutoScaleRequest.Validate if the designated
// constraints aren't met.
type EnableNodeGroupAutoScaleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableNodeGroupAutoScaleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableNodeGroupAutoScaleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableNodeGroupAutoScaleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableNodeGroupAutoScaleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableNodeGroupAutoScaleRequestValidationError) ErrorName() string {
	return "EnableNodeGroupAutoScaleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EnableNodeGroupAutoScaleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableNodeGroupAutoScaleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableNodeGroupAutoScaleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableNodeGroupAutoScaleRequestValidationError{}

var _EnableNodeGroupAutoScaleRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on EnableNodeGroupAutoScaleResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *EnableNodeGroupAutoScaleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableNodeGroupAutoScaleResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EnableNodeGroupAutoScaleResponseMultiError, or nil if none found.
func (m *EnableNodeGroupAutoScaleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableNodeGroupAutoScaleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnableNodeGroupAutoScaleResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnableNodeGroupAutoScaleResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnableNodeGroupAutoScaleResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnableNodeGroupAutoScaleResponseMultiError(errors)
	}

	return nil
}

// EnableNodeGroupAutoScaleResponseMultiError is an error wrapping multiple
// validation errors returned by
// EnableNodeGroupAutoScaleResponse.ValidateAll() if the designated
// constraints aren't met.
type EnableNodeGroupAutoScaleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableNodeGroupAutoScaleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableNodeGroupAutoScaleResponseMultiError) AllErrors() []error { return m }

// EnableNodeGroupAutoScaleResponseValidationError is the validation error
// returned by EnableNodeGroupAutoScaleResponse.Validate if the designated
// constraints aren't met.
type EnableNodeGroupAutoScaleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableNodeGroupAutoScaleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableNodeGroupAutoScaleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableNodeGroupAutoScaleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableNodeGroupAutoScaleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableNodeGroupAutoScaleResponseValidationError) ErrorName() string {
	return "EnableNodeGroupAutoScaleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EnableNodeGroupAutoScaleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableNodeGroupAutoScaleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableNodeGroupAutoScaleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableNodeGroupAutoScaleResponseValidationError{}

// Validate checks the field values on DisableNodeGroupAutoScaleRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DisableNodeGroupAutoScaleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisableNodeGroupAutoScaleRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DisableNodeGroupAutoScaleRequestMultiError, or nil if none found.
func (m *DisableNodeGroupAutoScaleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DisableNodeGroupAutoScaleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetNodeGroupID()); l < 5 || l > 100 {
		err := DisableNodeGroupAutoScaleRequestValidationError{
			field:  "NodeGroupID",
			reason: "value length must be between 5 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DisableNodeGroupAutoScaleRequest_NodeGroupID_Pattern.MatchString(m.GetNodeGroupID()) {
		err := DisableNodeGroupAutoScaleRequestValidationError{
			field:  "NodeGroupID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DisableNodeGroupAutoScaleRequestMultiError(errors)
	}

	return nil
}

// DisableNodeGroupAutoScaleRequestMultiError is an error wrapping multiple
// validation errors returned by
// DisableNodeGroupAutoScaleRequest.ValidateAll() if the designated
// constraints aren't met.
type DisableNodeGroupAutoScaleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisableNodeGroupAutoScaleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisableNodeGroupAutoScaleRequestMultiError) AllErrors() []error { return m }

// DisableNodeGroupAutoScaleRequestValidationError is the validation error
// returned by DisableNodeGroupAutoScaleRequest.Validate if the designated
// constraints aren't met.
type DisableNodeGroupAutoScaleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisableNodeGroupAutoScaleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisableNodeGroupAutoScaleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisableNodeGroupAutoScaleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisableNodeGroupAutoScaleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisableNodeGroupAutoScaleRequestValidationError) ErrorName() string {
	return "DisableNodeGroupAutoScaleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DisableNodeGroupAutoScaleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisableNodeGroupAutoScaleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisableNodeGroupAutoScaleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisableNodeGroupAutoScaleRequestValidationError{}

var _DisableNodeGroupAutoScaleRequest_NodeGroupID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DisableNodeGroupAutoScaleResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DisableNodeGroupAutoScaleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisableNodeGroupAutoScaleResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DisableNodeGroupAutoScaleResponseMultiError, or nil if none found.
func (m *DisableNodeGroupAutoScaleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DisableNodeGroupAutoScaleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DisableNodeGroupAutoScaleResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DisableNodeGroupAutoScaleResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DisableNodeGroupAutoScaleResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DisableNodeGroupAutoScaleResponseMultiError(errors)
	}

	return nil
}

// DisableNodeGroupAutoScaleResponseMultiError is an error wrapping multiple
// validation errors returned by
// DisableNodeGroupAutoScaleResponse.ValidateAll() if the designated
// constraints aren't met.
type DisableNodeGroupAutoScaleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisableNodeGroupAutoScaleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisableNodeGroupAutoScaleResponseMultiError) AllErrors() []error { return m }

// DisableNodeGroupAutoScaleResponseValidationError is the validation error
// returned by DisableNodeGroupAutoScaleResponse.Validate if the designated
// constraints aren't met.
type DisableNodeGroupAutoScaleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisableNodeGroupAutoScaleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisableNodeGroupAutoScaleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisableNodeGroupAutoScaleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisableNodeGroupAutoScaleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisableNodeGroupAutoScaleResponseValidationError) ErrorName() string {
	return "DisableNodeGroupAutoScaleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DisableNodeGroupAutoScaleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisableNodeGroupAutoScaleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisableNodeGroupAutoScaleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisableNodeGroupAutoScaleResponseValidationError{}

// Validate checks the field values on CreateTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaskRequestMultiError, or nil if none found.
func (m *CreateTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskType

	if _, ok := _CreateTaskRequest_Status_InLookup[m.GetStatus()]; !ok {
		err := CreateTaskRequestValidationError{
			field:  "Status",
			reason: "value must be in list [INITIALIZING RUNNING SUCCESS FAILED TIMEOUT]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ExecutionTime

	// no validation rules for CurrentStep

	if len(m.GetStepSequence()) < 1 {
		err := CreateTaskRequestValidationError{
			field:  "StepSequence",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetSteps()); l < 1 || l > 20 {
		err := CreateTaskRequestValidationError{
			field:  "Steps",
			reason: "value must contain between 1 and 20 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetSteps()))
		i := 0
		for key := range m.GetSteps() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSteps()[key]
			_ = val

			// no validation rules for Steps[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CreateTaskRequestValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CreateTaskRequestValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CreateTaskRequestValidationError{
						field:  fmt.Sprintf("Steps[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := CreateTaskRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CreateTaskRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateTaskRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CreateTaskRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 2 || l > 32 {
		err := CreateTaskRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be between 2 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateTaskRequest_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := CreateTaskRequestValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateTaskRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for LastUpdate

	if len(errors) > 0 {
		return CreateTaskRequestMultiError(errors)
	}

	return nil
}

// CreateTaskRequestMultiError is an error wrapping multiple validation errors
// returned by CreateTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaskRequestMultiError) AllErrors() []error { return m }

// CreateTaskRequestValidationError is the validation error returned by
// CreateTaskRequest.Validate if the designated constraints aren't met.
type CreateTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaskRequestValidationError) ErrorName() string {
	return "CreateTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaskRequestValidationError{}

var _CreateTaskRequest_Status_InLookup = map[string]struct{}{
	"INITIALIZING": {},
	"RUNNING":      {},
	"SUCCESS":      {},
	"FAILED":       {},
	"TIMEOUT":      {},
}

var _CreateTaskRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateTaskRequest_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaskResponseMultiError, or nil if none found.
func (m *CreateTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTaskResponseMultiError(errors)
	}

	return nil
}

// CreateTaskResponseMultiError is an error wrapping multiple validation errors
// returned by CreateTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaskResponseMultiError) AllErrors() []error { return m }

// CreateTaskResponseValidationError is the validation error returned by
// CreateTaskResponse.Validate if the designated constraints aren't met.
type CreateTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaskResponseValidationError) ErrorName() string {
	return "CreateTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaskResponseValidationError{}

// Validate checks the field values on RetryTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RetryTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryTaskRequestMultiError, or nil if none found.
func (m *RetryTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 1024 {
		err := RetryTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RetryTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := RetryTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 1024 {
		err := RetryTaskRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RetryTaskRequestMultiError(errors)
	}

	return nil
}

// RetryTaskRequestMultiError is an error wrapping multiple validation errors
// returned by RetryTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type RetryTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryTaskRequestMultiError) AllErrors() []error { return m }

// RetryTaskRequestValidationError is the validation error returned by
// RetryTaskRequest.Validate if the designated constraints aren't met.
type RetryTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryTaskRequestValidationError) ErrorName() string { return "RetryTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e RetryTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryTaskRequestValidationError{}

var _RetryTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on RetryTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RetryTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryTaskResponseMultiError, or nil if none found.
func (m *RetryTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RetryTaskResponseMultiError(errors)
	}

	return nil
}

// RetryTaskResponseMultiError is an error wrapping multiple validation errors
// returned by RetryTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type RetryTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryTaskResponseMultiError) AllErrors() []error { return m }

// RetryTaskResponseValidationError is the validation error returned by
// RetryTaskResponse.Validate if the designated constraints aren't met.
type RetryTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryTaskResponseValidationError) ErrorName() string {
	return "RetryTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RetryTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryTaskResponseValidationError{}

// Validate checks the field values on SkipTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SkipTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SkipTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SkipTaskRequestMultiError, or nil if none found.
func (m *SkipTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SkipTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 1024 {
		err := SkipTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SkipTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := SkipTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 1024 {
		err := SkipTaskRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SkipTaskRequestMultiError(errors)
	}

	return nil
}

// SkipTaskRequestMultiError is an error wrapping multiple validation errors
// returned by SkipTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type SkipTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SkipTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SkipTaskRequestMultiError) AllErrors() []error { return m }

// SkipTaskRequestValidationError is the validation error returned by
// SkipTaskRequest.Validate if the designated constraints aren't met.
type SkipTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SkipTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SkipTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SkipTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SkipTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SkipTaskRequestValidationError) ErrorName() string { return "SkipTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e SkipTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSkipTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SkipTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SkipTaskRequestValidationError{}

var _SkipTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on SkipTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SkipTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SkipTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SkipTaskResponseMultiError, or nil if none found.
func (m *SkipTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SkipTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SkipTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SkipTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SkipTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SkipTaskResponseMultiError(errors)
	}

	return nil
}

// SkipTaskResponseMultiError is an error wrapping multiple validation errors
// returned by SkipTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type SkipTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SkipTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SkipTaskResponseMultiError) AllErrors() []error { return m }

// SkipTaskResponseValidationError is the validation error returned by
// SkipTaskResponse.Validate if the designated constraints aren't met.
type SkipTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SkipTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SkipTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SkipTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SkipTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SkipTaskResponseValidationError) ErrorName() string { return "SkipTaskResponseValidationError" }

// Error satisfies the builtin error interface
func (e SkipTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSkipTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SkipTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SkipTaskResponseValidationError{}

// Validate checks the field values on UpdateTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaskRequestMultiError, or nil if none found.
func (m *UpdateTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 36 {
		err := UpdateTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := UpdateTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateTaskRequest_Status_InLookup[m.GetStatus()]; !ok {
		err := UpdateTaskRequestValidationError{
			field:  "Status",
			reason: "value must be in list [INITIALIZING RUNNING SUCCESS FAILURE TIMEOUT]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for End

	// no validation rules for ExecutionTime

	// no validation rules for CurrentStep

	if l := len(m.GetSteps()); l < 1 || l > 20 {
		err := UpdateTaskRequestValidationError{
			field:  "Steps",
			reason: "value must contain between 1 and 20 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetSteps()))
		i := 0
		for key := range m.GetSteps() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSteps()[key]
			_ = val

			// no validation rules for Steps[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, UpdateTaskRequestValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, UpdateTaskRequestValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return UpdateTaskRequestValidationError{
						field:  fmt.Sprintf("Steps[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateTaskRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateTaskRequestMultiError(errors)
	}

	return nil
}

// UpdateTaskRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaskRequestMultiError) AllErrors() []error { return m }

// UpdateTaskRequestValidationError is the validation error returned by
// UpdateTaskRequest.Validate if the designated constraints aren't met.
type UpdateTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaskRequestValidationError) ErrorName() string {
	return "UpdateTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaskRequestValidationError{}

var _UpdateTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _UpdateTaskRequest_Status_InLookup = map[string]struct{}{
	"INITIALIZING": {},
	"RUNNING":      {},
	"SUCCESS":      {},
	"FAILURE":      {},
	"TIMEOUT":      {},
}

// Validate checks the field values on UpdateTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaskResponseMultiError, or nil if none found.
func (m *UpdateTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTaskResponseMultiError(errors)
	}

	return nil
}

// UpdateTaskResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaskResponseMultiError) AllErrors() []error { return m }

// UpdateTaskResponseValidationError is the validation error returned by
// UpdateTaskResponse.Validate if the designated constraints aren't met.
type UpdateTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaskResponseValidationError) ErrorName() string {
	return "UpdateTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaskResponseValidationError{}

// Validate checks the field values on DeleteTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTaskRequestMultiError, or nil if none found.
func (m *DeleteTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 36 {
		err := DeleteTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := DeleteTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForce

	if len(errors) > 0 {
		return DeleteTaskRequestMultiError(errors)
	}

	return nil
}

// DeleteTaskRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskRequestMultiError) AllErrors() []error { return m }

// DeleteTaskRequestValidationError is the validation error returned by
// DeleteTaskRequest.Validate if the designated constraints aren't met.
type DeleteTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskRequestValidationError) ErrorName() string {
	return "DeleteTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskRequestValidationError{}

var _DeleteTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTaskResponseMultiError, or nil if none found.
func (m *DeleteTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteTaskResponseMultiError(errors)
	}

	return nil
}

// DeleteTaskResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskResponseMultiError) AllErrors() []error { return m }

// DeleteTaskResponseValidationError is the validation error returned by
// DeleteTaskResponse.Validate if the designated constraints aren't met.
type DeleteTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskResponseValidationError) ErrorName() string {
	return "DeleteTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskResponseValidationError{}

// Validate checks the field values on GetTaskRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskRequestMultiError,
// or nil if none found.
func (m *GetTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTaskID()); l < 2 || l > 36 {
		err := GetTaskRequestValidationError{
			field:  "TaskID",
			reason: "value length must be between 2 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetTaskRequest_TaskID_Pattern.MatchString(m.GetTaskID()) {
		err := GetTaskRequestValidationError{
			field:  "TaskID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTaskRequestMultiError(errors)
	}

	return nil
}

// GetTaskRequestMultiError is an error wrapping multiple validation errors
// returned by GetTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type GetTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskRequestMultiError) AllErrors() []error { return m }

// GetTaskRequestValidationError is the validation error returned by
// GetTaskRequest.Validate if the designated constraints aren't met.
type GetTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskRequestValidationError) ErrorName() string { return "GetTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskRequestValidationError{}

var _GetTaskRequest_TaskID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaskResponseMultiError, or nil if none found.
func (m *GetTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTaskResponseMultiError(errors)
	}

	return nil
}

// GetTaskResponseMultiError is an error wrapping multiple validation errors
// returned by GetTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type GetTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskResponseMultiError) AllErrors() []error { return m }

// GetTaskResponseValidationError is the validation error returned by
// GetTaskResponse.Validate if the designated constraints aren't met.
type GetTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskResponseValidationError) ErrorName() string { return "GetTaskResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskResponseValidationError{}

// Validate checks the field values on ListTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTaskRequestMultiError, or nil if none found.
func (m *ListTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := ListTaskRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 32 {
		err := ListTaskRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) > 20 {
		err := ListTaskRequestValidationError{
			field:  "Creator",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUpdater()) > 20 {
		err := ListTaskRequestValidationError{
			field:  "Updater",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TaskType

	// no validation rules for Status

	// no validation rules for NodeIP

	// no validation rules for NodeGroupID

	if len(errors) > 0 {
		return ListTaskRequestMultiError(errors)
	}

	return nil
}

// ListTaskRequestMultiError is an error wrapping multiple validation errors
// returned by ListTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type ListTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTaskRequestMultiError) AllErrors() []error { return m }

// ListTaskRequestValidationError is the validation error returned by
// ListTaskRequest.Validate if the designated constraints aren't met.
type ListTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTaskRequestValidationError) ErrorName() string { return "ListTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTaskRequestValidationError{}

// Validate checks the field values on ListTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTaskResponseMultiError, or nil if none found.
func (m *ListTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTaskResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTaskResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTaskResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLatestTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListTaskResponseValidationError{
					field:  "LatestTask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListTaskResponseValidationError{
					field:  "LatestTask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatestTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListTaskResponseValidationError{
				field:  "LatestTask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListTaskResponseMultiError(errors)
	}

	return nil
}

// ListTaskResponseMultiError is an error wrapping multiple validation errors
// returned by ListTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type ListTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTaskResponseMultiError) AllErrors() []error { return m }

// ListTaskResponseValidationError is the validation error returned by
// ListTaskResponse.Validate if the designated constraints aren't met.
type ListTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTaskResponseValidationError) ErrorName() string { return "ListTaskResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTaskResponseValidationError{}

// Validate checks the field values on CreateAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAutoScalingOptionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAutoScalingOptionRequestMultiError, or nil if none found.
func (m *CreateAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsScaleDownEnable

	// no validation rules for Expander

	// no validation rules for MaxEmptyBulkDelete

	// no validation rules for ScaleDownDelay

	// no validation rules for ScaleDownUnneededTime

	// no validation rules for ScaleDownUtilizationThreahold

	// no validation rules for SkipNodesWithLocalStorage

	// no validation rules for SkipNodesWithSystemPods

	// no validation rules for IgnoreDaemonSetsUtilization

	// no validation rules for OkTotalUnreadyCount

	// no validation rules for MaxTotalUnreadyPercentage

	// no validation rules for ScaleDownUnreadyTime

	// no validation rules for UnregisteredNodeRemovalTime

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := CreateAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := CreateAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateAutoScalingOptionRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := CreateAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 2 || l > 20 {
		err := CreateAutoScalingOptionRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	// no validation rules for EnableAutoscale

	// no validation rules for BufferResourceRatio

	// no validation rules for MaxGracefulTerminationSec

	// no validation rules for ScanInterval

	// no validation rules for MaxNodeProvisionTime

	if all {
		switch v := interface{}(m.GetScaleUpFromZero()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAutoScalingOptionRequestValidationError{
					field:  "ScaleUpFromZero",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAutoScalingOptionRequestValidationError{
					field:  "ScaleUpFromZero",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleUpFromZero()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAutoScalingOptionRequestValidationError{
				field:  "ScaleUpFromZero",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ScaleDownDelayAfterAdd

	// no validation rules for ScaleDownDelayAfterDelete

	if all {
		switch v := interface{}(m.GetScaleDownDelayAfterFailure()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAutoScalingOptionRequestValidationError{
					field:  "ScaleDownDelayAfterFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAutoScalingOptionRequestValidationError{
					field:  "ScaleDownDelayAfterFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleDownDelayAfterFailure()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAutoScalingOptionRequestValidationError{
				field:  "ScaleDownDelayAfterFailure",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ScaleDownGpuUtilizationThreshold

	// no validation rules for BufferResourceCpuRatio

	// no validation rules for BufferResourceMemRatio

	if len(errors) > 0 {
		return CreateAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// CreateAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by CreateAutoScalingOptionRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// CreateAutoScalingOptionRequestValidationError is the validation error
// returned by CreateAutoScalingOptionRequest.Validate if the designated
// constraints aren't met.
type CreateAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAutoScalingOptionRequestValidationError) ErrorName() string {
	return "CreateAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAutoScalingOptionRequestValidationError{}

var _CreateAutoScalingOptionRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on CreateAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAutoScalingOptionResponseMultiError, or nil if none found.
func (m *CreateAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// CreateAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by CreateAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// CreateAutoScalingOptionResponseValidationError is the validation error
// returned by CreateAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type CreateAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAutoScalingOptionResponseValidationError) ErrorName() string {
	return "CreateAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAutoScalingOptionResponseValidationError{}

// Validate checks the field values on UpdateAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAutoScalingOptionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateAutoScalingOptionRequestMultiError, or nil if none found.
func (m *UpdateAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsScaleDownEnable

	if _, ok := _UpdateAutoScalingOptionRequest_Expander_InLookup[m.GetExpander()]; !ok {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "Expander",
			reason: "value must be in list [random least-waste most-pods priority]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxEmptyBulkDelete(); val < 1 || val > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "MaxEmptyBulkDelete",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownDelay(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelay",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUnneededTime(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUnneededTime",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUtilizationThreahold(); val < 0 || val > 80 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUtilizationThreahold",
			reason: "value must be inside range [0, 80]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSkipNodesWithLocalStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "SkipNodesWithLocalStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "SkipNodesWithLocalStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSkipNodesWithLocalStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionRequestValidationError{
				field:  "SkipNodesWithLocalStorage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSkipNodesWithSystemPods()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "SkipNodesWithSystemPods",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "SkipNodesWithSystemPods",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSkipNodesWithSystemPods()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionRequestValidationError{
				field:  "SkipNodesWithSystemPods",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIgnoreDaemonSetsUtilization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "IgnoreDaemonSetsUtilization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "IgnoreDaemonSetsUtilization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIgnoreDaemonSetsUtilization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionRequestValidationError{
				field:  "IgnoreDaemonSetsUtilization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetOkTotalUnreadyCount(); val < 0 || val > 320000 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "OkTotalUnreadyCount",
			reason: "value must be inside range [0, 320000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxTotalUnreadyPercentage(); val < 0 || val > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "MaxTotalUnreadyPercentage",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUnreadyTime(); val < 1200 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUnreadyTime",
			reason: "value must be inside range [1200, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for UnregisteredNodeRemovalTime

	if utf8.RuneCountInString(m.GetProjectID()) > 32 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	// no validation rules for ScaleDownGpuUtilizationThreshold

	if wrapper := m.GetBufferResourceRatio(); wrapper != nil {

		if val := wrapper.GetValue(); val < 0 || val > 100 {
			err := UpdateAutoScalingOptionRequestValidationError{
				field:  "BufferResourceRatio",
				reason: "value must be inside range [0, 100]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if val := m.GetMaxGracefulTerminationSec(); val < 60 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "MaxGracefulTerminationSec",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScanInterval(); val < 5 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScanInterval",
			reason: "value must be inside range [5, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxNodeProvisionTime(); val < 900 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "MaxNodeProvisionTime",
			reason: "value must be inside range [900, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetScaleUpFromZero()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "ScaleUpFromZero",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "ScaleUpFromZero",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleUpFromZero()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionRequestValidationError{
				field:  "ScaleUpFromZero",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetScaleDownDelayAfterAdd(); val < 1200 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelayAfterAdd",
			reason: "value must be inside range [1200, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownDelayAfterDelete(); val < 0 || val > 86400 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelayAfterDelete",
			reason: "value must be inside range [0, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetScaleDownDelayAfterFailure(); wrapper != nil {

		if val := wrapper.GetValue(); val < 60 || val > 86400 {
			err := UpdateAutoScalingOptionRequestValidationError{
				field:  "ScaleDownDelayAfterFailure",
				reason: "value must be inside range [60, 86400]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if val := m.GetBufferResourceCpuRatio(); val < 0 || val > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "BufferResourceCpuRatio",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetBufferResourceMemRatio(); val < 0 || val > 100 {
		err := UpdateAutoScalingOptionRequestValidationError{
			field:  "BufferResourceMemRatio",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "Module",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionRequestValidationError{
				field:  "Module",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebhook()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "Webhook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "Webhook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebhook()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionRequestValidationError{
				field:  "Webhook",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OnlyUpdateInfo

	if all {
		switch v := interface{}(m.GetExpendablePodsPriorityCutoff()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "ExpendablePodsPriorityCutoff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionRequestValidationError{
					field:  "ExpendablePodsPriorityCutoff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpendablePodsPriorityCutoff()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionRequestValidationError{
				field:  "ExpendablePodsPriorityCutoff",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if wrapper := m.GetNewPodScaleUpDelay(); wrapper != nil {

		if wrapper.GetValue() < 0 {
			err := UpdateAutoScalingOptionRequestValidationError{
				field:  "NewPodScaleUpDelay",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// UpdateAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateAutoScalingOptionRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// UpdateAutoScalingOptionRequestValidationError is the validation error
// returned by UpdateAutoScalingOptionRequest.Validate if the designated
// constraints aren't met.
type UpdateAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAutoScalingOptionRequestValidationError) ErrorName() string {
	return "UpdateAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAutoScalingOptionRequestValidationError{}

var _UpdateAutoScalingOptionRequest_Expander_InLookup = map[string]struct{}{
	"random":      {},
	"least-waste": {},
	"most-pods":   {},
	"priority":    {},
}

// Validate checks the field values on UpdateAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateAutoScalingOptionResponseMultiError, or nil if none found.
func (m *UpdateAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingOptionResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingOptionResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// UpdateAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// UpdateAutoScalingOptionResponseValidationError is the validation error
// returned by UpdateAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type UpdateAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAutoScalingOptionResponseValidationError) ErrorName() string {
	return "UpdateAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAutoScalingOptionResponseValidationError{}

// Validate checks the field values on UpdateAsOptionDeviceProviderRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateAsOptionDeviceProviderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAsOptionDeviceProviderRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateAsOptionDeviceProviderRequestMultiError, or nil if none found.
func (m *UpdateAsOptionDeviceProviderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAsOptionDeviceProviderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := UpdateAsOptionDeviceProviderRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	if len(errors) > 0 {
		return UpdateAsOptionDeviceProviderRequestMultiError(errors)
	}

	return nil
}

// UpdateAsOptionDeviceProviderRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateAsOptionDeviceProviderRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateAsOptionDeviceProviderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAsOptionDeviceProviderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAsOptionDeviceProviderRequestMultiError) AllErrors() []error { return m }

// UpdateAsOptionDeviceProviderRequestValidationError is the validation error
// returned by UpdateAsOptionDeviceProviderRequest.Validate if the designated
// constraints aren't met.
type UpdateAsOptionDeviceProviderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAsOptionDeviceProviderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAsOptionDeviceProviderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAsOptionDeviceProviderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAsOptionDeviceProviderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAsOptionDeviceProviderRequestValidationError) ErrorName() string {
	return "UpdateAsOptionDeviceProviderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAsOptionDeviceProviderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAsOptionDeviceProviderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAsOptionDeviceProviderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAsOptionDeviceProviderRequestValidationError{}

// Validate checks the field values on UpdateAsOptionDeviceProviderResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UpdateAsOptionDeviceProviderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAsOptionDeviceProviderResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateAsOptionDeviceProviderResponseMultiError, or nil if none found.
func (m *UpdateAsOptionDeviceProviderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAsOptionDeviceProviderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateAsOptionDeviceProviderResponseMultiError(errors)
	}

	return nil
}

// UpdateAsOptionDeviceProviderResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateAsOptionDeviceProviderResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateAsOptionDeviceProviderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAsOptionDeviceProviderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAsOptionDeviceProviderResponseMultiError) AllErrors() []error { return m }

// UpdateAsOptionDeviceProviderResponseValidationError is the validation error
// returned by UpdateAsOptionDeviceProviderResponse.Validate if the designated
// constraints aren't met.
type UpdateAsOptionDeviceProviderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAsOptionDeviceProviderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAsOptionDeviceProviderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAsOptionDeviceProviderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAsOptionDeviceProviderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAsOptionDeviceProviderResponseValidationError) ErrorName() string {
	return "UpdateAsOptionDeviceProviderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAsOptionDeviceProviderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAsOptionDeviceProviderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAsOptionDeviceProviderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAsOptionDeviceProviderResponseValidationError{}

// Validate checks the field values on SyncAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncAutoScalingOptionRequestMultiError, or nil if none found.
func (m *SyncAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsScaleDownEnable

	if _, ok := _SyncAutoScalingOptionRequest_Expander_InLookup[m.GetExpander()]; !ok {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "Expander",
			reason: "value must be in list [random least-waste most-pods priority]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxEmptyBulkDelete(); val < 1 || val > 100 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "MaxEmptyBulkDelete",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownDelay(); val < 60 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelay",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUnneededTime(); val < 60 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUnneededTime",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUtilizationThreahold(); val < 0 || val > 80 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUtilizationThreahold",
			reason: "value must be inside range [0, 80]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SkipNodesWithLocalStorage

	// no validation rules for SkipNodesWithSystemPods

	// no validation rules for IgnoreDaemonSetsUtilization

	if val := m.GetOkTotalUnreadyCount(); val < 0 || val > 320000 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "OkTotalUnreadyCount",
			reason: "value must be inside range [0, 320000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxTotalUnreadyPercentage(); val < 0 || val > 100 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "MaxTotalUnreadyPercentage",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownUnreadyTime(); val < 1200 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "ScaleDownUnreadyTime",
			reason: "value must be inside range [1200, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ScaleDownGpuUtilizationThreshold

	if val := m.GetBufferResourceRatio(); val < 0 || val > 100 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "BufferResourceRatio",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxGracefulTerminationSec(); val < 60 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "MaxGracefulTerminationSec",
			reason: "value must be inside range [60, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScanInterval(); val < 5 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "ScanInterval",
			reason: "value must be inside range [5, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxNodeProvisionTime(); val < 900 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "MaxNodeProvisionTime",
			reason: "value must be inside range [900, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxNodeStartupTime(); val < 900 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "MaxNodeStartupTime",
			reason: "value must be inside range [900, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxNodeStartScheduleTime(); val < 900 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "MaxNodeStartScheduleTime",
			reason: "value must be inside range [900, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetScaleUpFromZero()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncAutoScalingOptionRequestValidationError{
					field:  "ScaleUpFromZero",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncAutoScalingOptionRequestValidationError{
					field:  "ScaleUpFromZero",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleUpFromZero()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncAutoScalingOptionRequestValidationError{
				field:  "ScaleUpFromZero",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetScaleDownDelayAfterAdd(); val < 1200 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelayAfterAdd",
			reason: "value must be inside range [1200, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetScaleDownDelayAfterDelete(); val < 0 || val > 86400 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "ScaleDownDelayAfterDelete",
			reason: "value must be inside range [0, 86400]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetScaleDownDelayAfterFailure(); wrapper != nil {

		if val := wrapper.GetValue(); val < 60 || val > 86400 {
			err := SyncAutoScalingOptionRequestValidationError{
				field:  "ScaleDownDelayAfterFailure",
				reason: "value must be inside range [60, 86400]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if val := m.GetBufferResourceCpuRatio(); val < 0 || val > 100 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "BufferResourceCpuRatio",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetBufferResourceMemRatio(); val < 0 || val > 100 {
		err := SyncAutoScalingOptionRequestValidationError{
			field:  "BufferResourceMemRatio",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetWebhook()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncAutoScalingOptionRequestValidationError{
					field:  "Webhook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncAutoScalingOptionRequestValidationError{
					field:  "Webhook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebhook()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncAutoScalingOptionRequestValidationError{
				field:  "Webhook",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpendablePodsPriorityCutoff()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncAutoScalingOptionRequestValidationError{
					field:  "ExpendablePodsPriorityCutoff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncAutoScalingOptionRequestValidationError{
					field:  "ExpendablePodsPriorityCutoff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpendablePodsPriorityCutoff()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncAutoScalingOptionRequestValidationError{
				field:  "ExpendablePodsPriorityCutoff",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if wrapper := m.GetNewPodScaleUpDelay(); wrapper != nil {

		if wrapper.GetValue() < 0 {
			err := SyncAutoScalingOptionRequestValidationError{
				field:  "NewPodScaleUpDelay",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return SyncAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// SyncAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by SyncAutoScalingOptionRequest.ValidateAll() if
// the designated constraints aren't met.
type SyncAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// SyncAutoScalingOptionRequestValidationError is the validation error returned
// by SyncAutoScalingOptionRequest.Validate if the designated constraints
// aren't met.
type SyncAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncAutoScalingOptionRequestValidationError) ErrorName() string {
	return "SyncAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SyncAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncAutoScalingOptionRequestValidationError{}

var _SyncAutoScalingOptionRequest_Expander_InLookup = map[string]struct{}{
	"random":      {},
	"least-waste": {},
	"most-pods":   {},
	"priority":    {},
}

// Validate checks the field values on SyncAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SyncAutoScalingOptionResponseMultiError, or nil if none found.
func (m *SyncAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncAutoScalingOptionResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncAutoScalingOptionResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncAutoScalingOptionResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SyncAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// SyncAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by SyncAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type SyncAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// SyncAutoScalingOptionResponseValidationError is the validation error
// returned by SyncAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type SyncAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncAutoScalingOptionResponseValidationError) ErrorName() string {
	return "SyncAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SyncAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncAutoScalingOptionResponseValidationError{}

// Validate checks the field values on DeleteAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAutoScalingOptionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteAutoScalingOptionRequestMultiError, or nil if none found.
func (m *DeleteAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := DeleteAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := DeleteAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteAutoScalingOptionRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := DeleteAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsForce

	if len(errors) > 0 {
		return DeleteAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// DeleteAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteAutoScalingOptionRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// DeleteAutoScalingOptionRequestValidationError is the validation error
// returned by DeleteAutoScalingOptionRequest.Validate if the designated
// constraints aren't met.
type DeleteAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAutoScalingOptionRequestValidationError) ErrorName() string {
	return "DeleteAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAutoScalingOptionRequestValidationError{}

var _DeleteAutoScalingOptionRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteAutoScalingOptionResponseMultiError, or nil if none found.
func (m *DeleteAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteAutoScalingOptionResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteAutoScalingOptionResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteAutoScalingOptionResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// DeleteAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// DeleteAutoScalingOptionResponseValidationError is the validation error
// returned by DeleteAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type DeleteAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAutoScalingOptionResponseValidationError) ErrorName() string {
	return "DeleteAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAutoScalingOptionResponseValidationError{}

// Validate checks the field values on GetAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAutoScalingOptionRequestMultiError, or nil if none found.
func (m *GetAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 2 || l > 100 {
		err := GetAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterID(), "BCS-") {
		err := GetAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetAutoScalingOptionRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := GetAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	if len(errors) > 0 {
		return GetAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// GetAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by GetAutoScalingOptionRequest.ValidateAll() if
// the designated constraints aren't met.
type GetAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// GetAutoScalingOptionRequestValidationError is the validation error returned
// by GetAutoScalingOptionRequest.Validate if the designated constraints
// aren't met.
type GetAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAutoScalingOptionRequestValidationError) ErrorName() string {
	return "GetAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAutoScalingOptionRequestValidationError{}

var _GetAutoScalingOptionRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAutoScalingOptionResponseMultiError, or nil if none found.
func (m *GetAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAutoScalingOptionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAutoScalingOptionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAutoScalingOptionResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAutoScalingOptionResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAutoScalingOptionResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// GetAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by GetAutoScalingOptionResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// GetAutoScalingOptionResponseValidationError is the validation error returned
// by GetAutoScalingOptionResponse.Validate if the designated constraints
// aren't met.
type GetAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAutoScalingOptionResponseValidationError) ErrorName() string {
	return "GetAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAutoScalingOptionResponseValidationError{}

// Validate checks the field values on ListAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAutoScalingOptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAutoScalingOptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAutoScalingOptionRequestMultiError, or nil if none found.
func (m *ListAutoScalingOptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAutoScalingOptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := ListAutoScalingOptionRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) > 32 {
		err := ListAutoScalingOptionRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) > 20 {
		err := ListAutoScalingOptionRequestValidationError{
			field:  "Creator",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUpdater()) > 20 {
		err := ListAutoScalingOptionRequestValidationError{
			field:  "Updater",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAutoScalingOptionRequestMultiError(errors)
	}

	return nil
}

// ListAutoScalingOptionRequestMultiError is an error wrapping multiple
// validation errors returned by ListAutoScalingOptionRequest.ValidateAll() if
// the designated constraints aren't met.
type ListAutoScalingOptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAutoScalingOptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAutoScalingOptionRequestMultiError) AllErrors() []error { return m }

// ListAutoScalingOptionRequestValidationError is the validation error returned
// by ListAutoScalingOptionRequest.Validate if the designated constraints
// aren't met.
type ListAutoScalingOptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAutoScalingOptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAutoScalingOptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAutoScalingOptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAutoScalingOptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAutoScalingOptionRequestValidationError) ErrorName() string {
	return "ListAutoScalingOptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAutoScalingOptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAutoScalingOptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAutoScalingOptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAutoScalingOptionRequestValidationError{}

// Validate checks the field values on ListAutoScalingOptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAutoScalingOptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAutoScalingOptionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListAutoScalingOptionResponseMultiError, or nil if none found.
func (m *ListAutoScalingOptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAutoScalingOptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAutoScalingOptionResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAutoScalingOptionResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAutoScalingOptionResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListAutoScalingOptionResponseMultiError(errors)
	}

	return nil
}

// ListAutoScalingOptionResponseMultiError is an error wrapping multiple
// validation errors returned by ListAutoScalingOptionResponse.ValidateAll()
// if the designated constraints aren't met.
type ListAutoScalingOptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAutoScalingOptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAutoScalingOptionResponseMultiError) AllErrors() []error { return m }

// ListAutoScalingOptionResponseValidationError is the validation error
// returned by ListAutoScalingOptionResponse.Validate if the designated
// constraints aren't met.
type ListAutoScalingOptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAutoScalingOptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAutoScalingOptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAutoScalingOptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAutoScalingOptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAutoScalingOptionResponseValidationError) ErrorName() string {
	return "ListAutoScalingOptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAutoScalingOptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAutoScalingOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAutoScalingOptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAutoScalingOptionResponseValidationError{}

// Validate checks the field values on UpdateAutoScalingStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAutoScalingStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAutoScalingStatusRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateAutoScalingStatusRequestMultiError, or nil if none found.
func (m *UpdateAutoScalingStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAutoScalingStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enable

	if utf8.RuneCountInString(m.GetClusterID()) > 100 {
		err := UpdateAutoScalingStatusRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUpdater()); l < 2 || l > 20 {
		err := UpdateAutoScalingStatusRequestValidationError{
			field:  "Updater",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Provider

	if len(errors) > 0 {
		return UpdateAutoScalingStatusRequestMultiError(errors)
	}

	return nil
}

// UpdateAutoScalingStatusRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateAutoScalingStatusRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateAutoScalingStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAutoScalingStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAutoScalingStatusRequestMultiError) AllErrors() []error { return m }

// UpdateAutoScalingStatusRequestValidationError is the validation error
// returned by UpdateAutoScalingStatusRequest.Validate if the designated
// constraints aren't met.
type UpdateAutoScalingStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAutoScalingStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAutoScalingStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAutoScalingStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAutoScalingStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAutoScalingStatusRequestValidationError) ErrorName() string {
	return "UpdateAutoScalingStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAutoScalingStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAutoScalingStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAutoScalingStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAutoScalingStatusRequestValidationError{}

// Validate checks the field values on UpdateAutoScalingStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAutoScalingStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAutoScalingStatusResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateAutoScalingStatusResponseMultiError, or nil if none found.
func (m *UpdateAutoScalingStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAutoScalingStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingStatusResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAutoScalingStatusResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAutoScalingStatusResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAutoScalingStatusResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateAutoScalingStatusResponseMultiError(errors)
	}

	return nil
}

// UpdateAutoScalingStatusResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateAutoScalingStatusResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateAutoScalingStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAutoScalingStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAutoScalingStatusResponseMultiError) AllErrors() []error { return m }

// UpdateAutoScalingStatusResponseValidationError is the validation error
// returned by UpdateAutoScalingStatusResponse.Validate if the designated
// constraints aren't met.
type UpdateAutoScalingStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAutoScalingStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAutoScalingStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAutoScalingStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAutoScalingStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAutoScalingStatusResponseValidationError) ErrorName() string {
	return "UpdateAutoScalingStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAutoScalingStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAutoScalingStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAutoScalingStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAutoScalingStatusResponseValidationError{}

// Validate checks the field values on NodeRoleInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeRoleInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeRoleInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeRoleInfoMultiError, or
// nil if none found.
func (m *NodeRoleInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeRoleInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoleName

	// no validation rules for RoleID

	// no validation rules for Arn

	// no validation rules for Description

	if len(errors) > 0 {
		return NodeRoleInfoMultiError(errors)
	}

	return nil
}

// NodeRoleInfoMultiError is an error wrapping multiple validation errors
// returned by NodeRoleInfo.ValidateAll() if the designated constraints aren't met.
type NodeRoleInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeRoleInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeRoleInfoMultiError) AllErrors() []error { return m }

// NodeRoleInfoValidationError is the validation error returned by
// NodeRoleInfo.Validate if the designated constraints aren't met.
type NodeRoleInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeRoleInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeRoleInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeRoleInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeRoleInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeRoleInfoValidationError) ErrorName() string { return "NodeRoleInfoValidationError" }

// Error satisfies the builtin error interface
func (e NodeRoleInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeRoleInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeRoleInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeRoleInfoValidationError{}

// Validate checks the field values on GetNodeRolesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeRolesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeRolesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeRolesRequestMultiError, or nil if none found.
func (m *GetNodeRolesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeRolesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := GetNodeRolesRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountID

	if len(errors) > 0 {
		return GetNodeRolesRequestMultiError(errors)
	}

	return nil
}

// GetNodeRolesRequestMultiError is an error wrapping multiple validation
// errors returned by GetNodeRolesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetNodeRolesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeRolesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeRolesRequestMultiError) AllErrors() []error { return m }

// GetNodeRolesRequestValidationError is the validation error returned by
// GetNodeRolesRequest.Validate if the designated constraints aren't met.
type GetNodeRolesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeRolesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeRolesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeRolesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeRolesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeRolesRequestValidationError) ErrorName() string {
	return "GetNodeRolesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeRolesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeRolesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeRolesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeRolesRequestValidationError{}

// Validate checks the field values on GetNodeRolesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeRolesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeRolesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeRolesResponseMultiError, or nil if none found.
func (m *GetNodeRolesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeRolesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetNodeRolesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetNodeRolesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetNodeRolesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetNodeRolesResponseMultiError(errors)
	}

	return nil
}

// GetNodeRolesResponseMultiError is an error wrapping multiple validation
// errors returned by GetNodeRolesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetNodeRolesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeRolesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeRolesResponseMultiError) AllErrors() []error { return m }

// GetNodeRolesResponseValidationError is the validation error returned by
// GetNodeRolesResponse.Validate if the designated constraints aren't met.
type GetNodeRolesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeRolesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeRolesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeRolesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeRolesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeRolesResponseValidationError) ErrorName() string {
	return "GetNodeRolesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeRolesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeRolesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeRolesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeRolesResponseValidationError{}

// Validate checks the field values on ResourceGroupInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResourceGroupInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceGroupInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceGroupInfoMultiError, or nil if none found.
func (m *ResourceGroupInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceGroupInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Region

	// no validation rules for ProvisioningState

	if len(errors) > 0 {
		return ResourceGroupInfoMultiError(errors)
	}

	return nil
}

// ResourceGroupInfoMultiError is an error wrapping multiple validation errors
// returned by ResourceGroupInfo.ValidateAll() if the designated constraints
// aren't met.
type ResourceGroupInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceGroupInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceGroupInfoMultiError) AllErrors() []error { return m }

// ResourceGroupInfoValidationError is the validation error returned by
// ResourceGroupInfo.Validate if the designated constraints aren't met.
type ResourceGroupInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceGroupInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceGroupInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceGroupInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceGroupInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceGroupInfoValidationError) ErrorName() string {
	return "ResourceGroupInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ResourceGroupInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceGroupInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceGroupInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceGroupInfoValidationError{}

// Validate checks the field values on GetResourceGroupsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetResourceGroupsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResourceGroupsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetResourceGroupsRequestMultiError, or nil if none found.
func (m *GetResourceGroupsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResourceGroupsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := GetResourceGroupsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountID

	if len(errors) > 0 {
		return GetResourceGroupsRequestMultiError(errors)
	}

	return nil
}

// GetResourceGroupsRequestMultiError is an error wrapping multiple validation
// errors returned by GetResourceGroupsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetResourceGroupsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResourceGroupsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResourceGroupsRequestMultiError) AllErrors() []error { return m }

// GetResourceGroupsRequestValidationError is the validation error returned by
// GetResourceGroupsRequest.Validate if the designated constraints aren't met.
type GetResourceGroupsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResourceGroupsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResourceGroupsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResourceGroupsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResourceGroupsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResourceGroupsRequestValidationError) ErrorName() string {
	return "GetResourceGroupsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetResourceGroupsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResourceGroupsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResourceGroupsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResourceGroupsRequestValidationError{}

// Validate checks the field values on GetResourceGroupsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetResourceGroupsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResourceGroupsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetResourceGroupsResponseMultiError, or nil if none found.
func (m *GetResourceGroupsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResourceGroupsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetResourceGroupsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetResourceGroupsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetResourceGroupsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetResourceGroupsResponseMultiError(errors)
	}

	return nil
}

// GetResourceGroupsResponseMultiError is an error wrapping multiple validation
// errors returned by GetResourceGroupsResponse.ValidateAll() if the
// designated constraints aren't met.
type GetResourceGroupsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResourceGroupsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResourceGroupsResponseMultiError) AllErrors() []error { return m }

// GetResourceGroupsResponseValidationError is the validation error returned by
// GetResourceGroupsResponse.Validate if the designated constraints aren't met.
type GetResourceGroupsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResourceGroupsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResourceGroupsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResourceGroupsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResourceGroupsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResourceGroupsResponseValidationError) ErrorName() string {
	return "GetResourceGroupsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetResourceGroupsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResourceGroupsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResourceGroupsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResourceGroupsResponseValidationError{}

// Validate checks the field values on RegionInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegionInfoMultiError, or
// nil if none found.
func (m *RegionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for RegionName

	// no validation rules for RegionState

	if len(errors) > 0 {
		return RegionInfoMultiError(errors)
	}

	return nil
}

// RegionInfoMultiError is an error wrapping multiple validation errors
// returned by RegionInfo.ValidateAll() if the designated constraints aren't met.
type RegionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionInfoMultiError) AllErrors() []error { return m }

// RegionInfoValidationError is the validation error returned by
// RegionInfo.Validate if the designated constraints aren't met.
type RegionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionInfoValidationError) ErrorName() string { return "RegionInfoValidationError" }

// Error satisfies the builtin error interface
func (e RegionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionInfoValidationError{}

// Validate checks the field values on GetCloudRegionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRegionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRegionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRegionsRequestMultiError, or nil if none found.
func (m *GetCloudRegionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRegionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := GetCloudRegionsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountID

	if len(errors) > 0 {
		return GetCloudRegionsRequestMultiError(errors)
	}

	return nil
}

// GetCloudRegionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetCloudRegionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCloudRegionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRegionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRegionsRequestMultiError) AllErrors() []error { return m }

// GetCloudRegionsRequestValidationError is the validation error returned by
// GetCloudRegionsRequest.Validate if the designated constraints aren't met.
type GetCloudRegionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRegionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRegionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRegionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRegionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRegionsRequestValidationError) ErrorName() string {
	return "GetCloudRegionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudRegionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRegionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRegionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRegionsRequestValidationError{}

// Validate checks the field values on GetCloudRegionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRegionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRegionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRegionsResponseMultiError, or nil if none found.
func (m *GetCloudRegionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRegionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCloudRegionsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCloudRegionsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCloudRegionsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCloudRegionsResponseMultiError(errors)
	}

	return nil
}

// GetCloudRegionsResponseMultiError is an error wrapping multiple validation
// errors returned by GetCloudRegionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCloudRegionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRegionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRegionsResponseMultiError) AllErrors() []error { return m }

// GetCloudRegionsResponseValidationError is the validation error returned by
// GetCloudRegionsResponse.Validate if the designated constraints aren't met.
type GetCloudRegionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRegionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRegionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRegionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRegionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRegionsResponseValidationError) ErrorName() string {
	return "GetCloudRegionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudRegionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRegionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRegionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRegionsResponseValidationError{}

// Validate checks the field values on ZoneInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ZoneInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ZoneInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ZoneInfoMultiError, or nil
// if none found.
func (m *ZoneInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ZoneInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ZoneID

	// no validation rules for Zone

	// no validation rules for ZoneName

	// no validation rules for ZoneState

	// no validation rules for SubnetNum

	if len(errors) > 0 {
		return ZoneInfoMultiError(errors)
	}

	return nil
}

// ZoneInfoMultiError is an error wrapping multiple validation errors returned
// by ZoneInfo.ValidateAll() if the designated constraints aren't met.
type ZoneInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZoneInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZoneInfoMultiError) AllErrors() []error { return m }

// ZoneInfoValidationError is the validation error returned by
// ZoneInfo.Validate if the designated constraints aren't met.
type ZoneInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZoneInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZoneInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZoneInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZoneInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZoneInfoValidationError) ErrorName() string { return "ZoneInfoValidationError" }

// Error satisfies the builtin error interface
func (e ZoneInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZoneInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZoneInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZoneInfoValidationError{}

// Validate checks the field values on CloudClusterInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudClusterInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudClusterInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudClusterInfoMultiError, or nil if none found.
func (m *CloudClusterInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudClusterInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	// no validation rules for ClusterName

	// no validation rules for ClusterDescription

	// no validation rules for ClusterVersion

	// no validation rules for ClusterOS

	// no validation rules for ClusterType

	// no validation rules for ClusterStatus

	// no validation rules for Location

	// no validation rules for ClusterLevel

	if len(errors) > 0 {
		return CloudClusterInfoMultiError(errors)
	}

	return nil
}

// CloudClusterInfoMultiError is an error wrapping multiple validation errors
// returned by CloudClusterInfo.ValidateAll() if the designated constraints
// aren't met.
type CloudClusterInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudClusterInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudClusterInfoMultiError) AllErrors() []error { return m }

// CloudClusterInfoValidationError is the validation error returned by
// CloudClusterInfo.Validate if the designated constraints aren't met.
type CloudClusterInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudClusterInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudClusterInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudClusterInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudClusterInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudClusterInfoValidationError) ErrorName() string { return "CloudClusterInfoValidationError" }

// Error satisfies the builtin error interface
func (e CloudClusterInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudClusterInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudClusterInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudClusterInfoValidationError{}

// Validate checks the field values on ListCloudRegionClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRegionClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRegionClusterRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudRegionClusterRequestMultiError, or nil if none found.
func (m *ListCloudRegionClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRegionClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudRegionClusterRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) < 2 {
		err := ListCloudRegionClusterRequestValidationError{
			field:  "Region",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountID()) < 2 {
		err := ListCloudRegionClusterRequestValidationError{
			field:  "AccountID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceGroupName

	if len(errors) > 0 {
		return ListCloudRegionClusterRequestMultiError(errors)
	}

	return nil
}

// ListCloudRegionClusterRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudRegionClusterRequest.ValidateAll()
// if the designated constraints aren't met.
type ListCloudRegionClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRegionClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRegionClusterRequestMultiError) AllErrors() []error { return m }

// ListCloudRegionClusterRequestValidationError is the validation error
// returned by ListCloudRegionClusterRequest.Validate if the designated
// constraints aren't met.
type ListCloudRegionClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRegionClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRegionClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRegionClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRegionClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRegionClusterRequestValidationError) ErrorName() string {
	return "ListCloudRegionClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRegionClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRegionClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRegionClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRegionClusterRequestValidationError{}

// Validate checks the field values on ListCloudRegionClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRegionClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRegionClusterResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudRegionClusterResponseMultiError, or nil if none found.
func (m *ListCloudRegionClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRegionClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudRegionClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudRegionClusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudRegionClusterResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudRegionClusterResponseMultiError(errors)
	}

	return nil
}

// ListCloudRegionClusterResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudRegionClusterResponse.ValidateAll()
// if the designated constraints aren't met.
type ListCloudRegionClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRegionClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRegionClusterResponseMultiError) AllErrors() []error { return m }

// ListCloudRegionClusterResponseValidationError is the validation error
// returned by ListCloudRegionClusterResponse.Validate if the designated
// constraints aren't met.
type ListCloudRegionClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRegionClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRegionClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRegionClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRegionClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRegionClusterResponseValidationError) ErrorName() string {
	return "ListCloudRegionClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRegionClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRegionClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRegionClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRegionClusterResponseValidationError{}

// Validate checks the field values on GetCloudRegionZonesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRegionZonesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRegionZonesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRegionZonesRequestMultiError, or nil if none found.
func (m *GetCloudRegionZonesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRegionZonesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := GetCloudRegionZonesRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	// no validation rules for VpcId

	// no validation rules for State

	if len(errors) > 0 {
		return GetCloudRegionZonesRequestMultiError(errors)
	}

	return nil
}

// GetCloudRegionZonesRequestMultiError is an error wrapping multiple
// validation errors returned by GetCloudRegionZonesRequest.ValidateAll() if
// the designated constraints aren't met.
type GetCloudRegionZonesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRegionZonesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRegionZonesRequestMultiError) AllErrors() []error { return m }

// GetCloudRegionZonesRequestValidationError is the validation error returned
// by GetCloudRegionZonesRequest.Validate if the designated constraints aren't met.
type GetCloudRegionZonesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRegionZonesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRegionZonesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRegionZonesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRegionZonesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRegionZonesRequestValidationError) ErrorName() string {
	return "GetCloudRegionZonesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudRegionZonesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRegionZonesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRegionZonesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRegionZonesRequestValidationError{}

// Validate checks the field values on GetCloudRegionZonesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudRegionZonesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudRegionZonesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudRegionZonesResponseMultiError, or nil if none found.
func (m *GetCloudRegionZonesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudRegionZonesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCloudRegionZonesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCloudRegionZonesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCloudRegionZonesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCloudRegionZonesResponseMultiError(errors)
	}

	return nil
}

// GetCloudRegionZonesResponseMultiError is an error wrapping multiple
// validation errors returned by GetCloudRegionZonesResponse.ValidateAll() if
// the designated constraints aren't met.
type GetCloudRegionZonesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudRegionZonesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudRegionZonesResponseMultiError) AllErrors() []error { return m }

// GetCloudRegionZonesResponseValidationError is the validation error returned
// by GetCloudRegionZonesResponse.Validate if the designated constraints
// aren't met.
type GetCloudRegionZonesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudRegionZonesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudRegionZonesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudRegionZonesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudRegionZonesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudRegionZonesResponseValidationError) ErrorName() string {
	return "GetCloudRegionZonesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudRegionZonesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudRegionZonesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudRegionZonesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudRegionZonesResponseValidationError{}

// Validate checks the field values on OperationLog with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperationLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationLogMultiError, or
// nil if none found.
func (m *OperationLog) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceType

	// no validation rules for ResourceID

	// no validation rules for TaskID

	// no validation rules for Message

	// no validation rules for OpUser

	// no validation rules for CreateTime

	// no validation rules for ClusterID

	// no validation rules for ProjectID

	// no validation rules for ResourceName

	if len(errors) > 0 {
		return OperationLogMultiError(errors)
	}

	return nil
}

// OperationLogMultiError is an error wrapping multiple validation errors
// returned by OperationLog.ValidateAll() if the designated constraints aren't met.
type OperationLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationLogMultiError) AllErrors() []error { return m }

// OperationLogValidationError is the validation error returned by
// OperationLog.Validate if the designated constraints aren't met.
type OperationLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationLogValidationError) ErrorName() string { return "OperationLogValidationError" }

// Error satisfies the builtin error interface
func (e OperationLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationLogValidationError{}

// Validate checks the field values on TaskOperationLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TaskOperationLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskOperationLog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskOperationLogMultiError, or nil if none found.
func (m *TaskOperationLog) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskOperationLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceType

	// no validation rules for ResourceID

	// no validation rules for TaskID

	// no validation rules for Message

	// no validation rules for OpUser

	// no validation rules for CreateTime

	// no validation rules for ClusterID

	// no validation rules for ProjectID

	// no validation rules for Status

	// no validation rules for TaskType

	// no validation rules for ResourceName

	if len(errors) > 0 {
		return TaskOperationLogMultiError(errors)
	}

	return nil
}

// TaskOperationLogMultiError is an error wrapping multiple validation errors
// returned by TaskOperationLog.ValidateAll() if the designated constraints
// aren't met.
type TaskOperationLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskOperationLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskOperationLogMultiError) AllErrors() []error { return m }

// TaskOperationLogValidationError is the validation error returned by
// TaskOperationLog.Validate if the designated constraints aren't met.
type TaskOperationLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskOperationLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskOperationLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskOperationLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskOperationLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskOperationLogValidationError) ErrorName() string { return "TaskOperationLogValidationError" }

// Error satisfies the builtin error interface
func (e TaskOperationLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskOperationLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskOperationLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskOperationLogValidationError{}

// Validate checks the field values on ListCloudInstanceTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudInstanceTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudInstanceTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudInstanceTypeRequestMultiError, or nil if none found.
func (m *ListCloudInstanceTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudInstanceTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudInstanceTypeRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	if utf8.RuneCountInString(m.GetZone()) > 32 {
		err := ListCloudInstanceTypeRequestValidationError{
			field:  "Zone",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNodeFamily()) > 32 {
		err := ListCloudInstanceTypeRequestValidationError{
			field:  "NodeFamily",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Cpu

	// no validation rules for Memory

	// no validation rules for BizID

	// no validation rules for Provider

	if _, ok := _ListCloudInstanceTypeRequest_ResourceType_InLookup[m.GetResourceType()]; !ok {
		err := ListCloudInstanceTypeRequestValidationError{
			field:  "ResourceType",
			reason: "value must be in list [ online offline]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCloudInstanceTypeRequestMultiError(errors)
	}

	return nil
}

// ListCloudInstanceTypeRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudInstanceTypeRequest.ValidateAll() if
// the designated constraints aren't met.
type ListCloudInstanceTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudInstanceTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudInstanceTypeRequestMultiError) AllErrors() []error { return m }

// ListCloudInstanceTypeRequestValidationError is the validation error returned
// by ListCloudInstanceTypeRequest.Validate if the designated constraints
// aren't met.
type ListCloudInstanceTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudInstanceTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudInstanceTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudInstanceTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudInstanceTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudInstanceTypeRequestValidationError) ErrorName() string {
	return "ListCloudInstanceTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudInstanceTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudInstanceTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudInstanceTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudInstanceTypeRequestValidationError{}

var _ListCloudInstanceTypeRequest_ResourceType_InLookup = map[string]struct{}{
	"":        {},
	"online":  {},
	"offline": {},
}

// Validate checks the field values on ListCloudInstanceTypeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudInstanceTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudInstanceTypeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudInstanceTypeResponseMultiError, or nil if none found.
func (m *ListCloudInstanceTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudInstanceTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudInstanceTypeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudInstanceTypeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudInstanceTypeResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudInstanceTypeResponseMultiError(errors)
	}

	return nil
}

// ListCloudInstanceTypeResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudInstanceTypeResponse.ValidateAll()
// if the designated constraints aren't met.
type ListCloudInstanceTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudInstanceTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudInstanceTypeResponseMultiError) AllErrors() []error { return m }

// ListCloudInstanceTypeResponseValidationError is the validation error
// returned by ListCloudInstanceTypeResponse.Validate if the designated
// constraints aren't met.
type ListCloudInstanceTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudInstanceTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudInstanceTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudInstanceTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudInstanceTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudInstanceTypeResponseValidationError) ErrorName() string {
	return "ListCloudInstanceTypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudInstanceTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudInstanceTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudInstanceTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudInstanceTypeResponseValidationError{}

// Validate checks the field values on InstanceType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceTypeMultiError, or
// nil if none found.
func (m *InstanceType) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeType

	// no validation rules for TypeName

	// no validation rules for NodeFamily

	// no validation rules for Cpu

	// no validation rules for Memory

	// no validation rules for Gpu

	// no validation rules for Status

	// no validation rules for UnitPrice

	// no validation rules for Provider

	// no validation rules for ResourcePoolID

	if all {
		switch v := interface{}(m.GetSystemDisk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTypeValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTypeValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSystemDisk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTypeValidationError{
				field:  "SystemDisk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTypeValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTypeValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTypeValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InstanceTypeMultiError(errors)
	}

	return nil
}

// InstanceTypeMultiError is an error wrapping multiple validation errors
// returned by InstanceType.ValidateAll() if the designated constraints aren't met.
type InstanceTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTypeMultiError) AllErrors() []error { return m }

// InstanceTypeValidationError is the validation error returned by
// InstanceType.Validate if the designated constraints aren't met.
type InstanceTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTypeValidationError) ErrorName() string { return "InstanceTypeValidationError" }

// Error satisfies the builtin error interface
func (e InstanceTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTypeValidationError{}

// Validate checks the field values on GetMasterSuggestedMachinesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetMasterSuggestedMachinesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMasterSuggestedMachinesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetMasterSuggestedMachinesRequestMultiError, or nil if none found.
func (m *GetMasterSuggestedMachinesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMasterSuggestedMachinesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := GetMasterSuggestedMachinesRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) < 2 {
		err := GetMasterSuggestedMachinesRequestValidationError{
			field:  "Region",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _GetMasterSuggestedMachinesRequest_Level_InLookup[m.GetLevel()]; !ok {
		err := GetMasterSuggestedMachinesRequestValidationError{
			field:  "Level",
			reason: "value must be in list [L100 L500 L1000 L2000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountID

	// no validation rules for VpcID

	// no validation rules for Cpu

	// no validation rules for Memory

	// no validation rules for Zones

	if len(errors) > 0 {
		return GetMasterSuggestedMachinesRequestMultiError(errors)
	}

	return nil
}

// GetMasterSuggestedMachinesRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetMasterSuggestedMachinesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetMasterSuggestedMachinesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMasterSuggestedMachinesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMasterSuggestedMachinesRequestMultiError) AllErrors() []error { return m }

// GetMasterSuggestedMachinesRequestValidationError is the validation error
// returned by GetMasterSuggestedMachinesRequest.Validate if the designated
// constraints aren't met.
type GetMasterSuggestedMachinesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMasterSuggestedMachinesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMasterSuggestedMachinesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMasterSuggestedMachinesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMasterSuggestedMachinesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMasterSuggestedMachinesRequestValidationError) ErrorName() string {
	return "GetMasterSuggestedMachinesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMasterSuggestedMachinesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMasterSuggestedMachinesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMasterSuggestedMachinesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMasterSuggestedMachinesRequestValidationError{}

var _GetMasterSuggestedMachinesRequest_Level_InLookup = map[string]struct{}{
	"L100":  {},
	"L500":  {},
	"L1000": {},
	"L2000": {},
}

// Validate checks the field values on GetMasterSuggestedMachinesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetMasterSuggestedMachinesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMasterSuggestedMachinesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetMasterSuggestedMachinesResponseMultiError, or nil if none found.
func (m *GetMasterSuggestedMachinesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMasterSuggestedMachinesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetMasterSuggestedMachinesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetMasterSuggestedMachinesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetMasterSuggestedMachinesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetMasterSuggestedMachinesResponseMultiError(errors)
	}

	return nil
}

// GetMasterSuggestedMachinesResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetMasterSuggestedMachinesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetMasterSuggestedMachinesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMasterSuggestedMachinesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMasterSuggestedMachinesResponseMultiError) AllErrors() []error { return m }

// GetMasterSuggestedMachinesResponseValidationError is the validation error
// returned by GetMasterSuggestedMachinesResponse.Validate if the designated
// constraints aren't met.
type GetMasterSuggestedMachinesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMasterSuggestedMachinesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMasterSuggestedMachinesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMasterSuggestedMachinesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMasterSuggestedMachinesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMasterSuggestedMachinesResponseValidationError) ErrorName() string {
	return "GetMasterSuggestedMachinesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMasterSuggestedMachinesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMasterSuggestedMachinesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMasterSuggestedMachinesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMasterSuggestedMachinesResponseValidationError{}

// Validate checks the field values on ListCloudInstancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudInstancesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudInstancesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudInstancesRequestMultiError, or nil if none found.
func (m *ListCloudInstancesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudInstancesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudInstancesRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	if utf8.RuneCountInString(m.GetIpList()) < 1 {
		err := ListCloudInstancesRequestValidationError{
			field:  "IpList",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCloudInstancesRequestMultiError(errors)
	}

	return nil
}

// ListCloudInstancesRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudInstancesRequest.ValidateAll() if the
// designated constraints aren't met.
type ListCloudInstancesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudInstancesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudInstancesRequestMultiError) AllErrors() []error { return m }

// ListCloudInstancesRequestValidationError is the validation error returned by
// ListCloudInstancesRequest.Validate if the designated constraints aren't met.
type ListCloudInstancesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudInstancesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudInstancesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudInstancesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudInstancesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudInstancesRequestValidationError) ErrorName() string {
	return "ListCloudInstancesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudInstancesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudInstancesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudInstancesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudInstancesRequestValidationError{}

// Validate checks the field values on ListCloudInstancesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudInstancesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudInstancesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudInstancesResponseMultiError, or nil if none found.
func (m *ListCloudInstancesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudInstancesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudInstancesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudInstancesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudInstancesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudInstancesResponseMultiError(errors)
	}

	return nil
}

// ListCloudInstancesResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudInstancesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListCloudInstancesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudInstancesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudInstancesResponseMultiError) AllErrors() []error { return m }

// ListCloudInstancesResponseValidationError is the validation error returned
// by ListCloudInstancesResponse.Validate if the designated constraints aren't met.
type ListCloudInstancesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudInstancesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudInstancesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudInstancesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudInstancesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudInstancesResponseValidationError) ErrorName() string {
	return "ListCloudInstancesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudInstancesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudInstancesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudInstancesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudInstancesResponseValidationError{}

// Validate checks the field values on CloudNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudNodeMultiError, or nil
// if none found.
func (m *CloudNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeID

	// no validation rules for InnerIP

	// no validation rules for InstanceType

	// no validation rules for Cpu

	// no validation rules for Mem

	// no validation rules for Gpu

	// no validation rules for Vpc

	// no validation rules for Region

	// no validation rules for InnerIPv6

	// no validation rules for ZoneID

	// no validation rules for Zone

	// no validation rules for ZoneName

	// no validation rules for CloudRegionNode

	if len(errors) > 0 {
		return CloudNodeMultiError(errors)
	}

	return nil
}

// CloudNodeMultiError is an error wrapping multiple validation errors returned
// by CloudNode.ValidateAll() if the designated constraints aren't met.
type CloudNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudNodeMultiError) AllErrors() []error { return m }

// CloudNodeValidationError is the validation error returned by
// CloudNode.Validate if the designated constraints aren't met.
type CloudNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudNodeValidationError) ErrorName() string { return "CloudNodeValidationError" }

// Error satisfies the builtin error interface
func (e CloudNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudNodeValidationError{}

// Validate checks the field values on GetCloudAccountTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudAccountTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudAccountTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudAccountTypeRequestMultiError, or nil if none found.
func (m *GetCloudAccountTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudAccountTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := GetCloudAccountTypeRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	if len(errors) > 0 {
		return GetCloudAccountTypeRequestMultiError(errors)
	}

	return nil
}

// GetCloudAccountTypeRequestMultiError is an error wrapping multiple
// validation errors returned by GetCloudAccountTypeRequest.ValidateAll() if
// the designated constraints aren't met.
type GetCloudAccountTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudAccountTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudAccountTypeRequestMultiError) AllErrors() []error { return m }

// GetCloudAccountTypeRequestValidationError is the validation error returned
// by GetCloudAccountTypeRequest.Validate if the designated constraints aren't met.
type GetCloudAccountTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudAccountTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudAccountTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudAccountTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudAccountTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudAccountTypeRequestValidationError) ErrorName() string {
	return "GetCloudAccountTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudAccountTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudAccountTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudAccountTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudAccountTypeRequestValidationError{}

// Validate checks the field values on GetCloudAccountTypeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCloudAccountTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudAccountTypeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCloudAccountTypeResponseMultiError, or nil if none found.
func (m *GetCloudAccountTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudAccountTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCloudAccountTypeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCloudAccountTypeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCloudAccountTypeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCloudAccountTypeResponseMultiError(errors)
	}

	return nil
}

// GetCloudAccountTypeResponseMultiError is an error wrapping multiple
// validation errors returned by GetCloudAccountTypeResponse.ValidateAll() if
// the designated constraints aren't met.
type GetCloudAccountTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudAccountTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudAccountTypeResponseMultiError) AllErrors() []error { return m }

// GetCloudAccountTypeResponseValidationError is the validation error returned
// by GetCloudAccountTypeResponse.Validate if the designated constraints
// aren't met.
type GetCloudAccountTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudAccountTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudAccountTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudAccountTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudAccountTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudAccountTypeResponseValidationError) ErrorName() string {
	return "GetCloudAccountTypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudAccountTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudAccountTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudAccountTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudAccountTypeResponseValidationError{}

// Validate checks the field values on CloudAccountType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudAccountType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudAccountType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudAccountTypeMultiError, or nil if none found.
func (m *CloudAccountType) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudAccountType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if len(errors) > 0 {
		return CloudAccountTypeMultiError(errors)
	}

	return nil
}

// CloudAccountTypeMultiError is an error wrapping multiple validation errors
// returned by CloudAccountType.ValidateAll() if the designated constraints
// aren't met.
type CloudAccountTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAccountTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAccountTypeMultiError) AllErrors() []error { return m }

// CloudAccountTypeValidationError is the validation error returned by
// CloudAccountType.Validate if the designated constraints aren't met.
type CloudAccountTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAccountTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAccountTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAccountTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAccountTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAccountTypeValidationError) ErrorName() string { return "CloudAccountTypeValidationError" }

// Error satisfies the builtin error interface
func (e CloudAccountTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudAccountType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAccountTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAccountTypeValidationError{}

// Validate checks the field values on GetCloudBandwidthPackagesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetCloudBandwidthPackagesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudBandwidthPackagesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetCloudBandwidthPackagesRequestMultiError, or nil if none found.
func (m *GetCloudBandwidthPackagesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudBandwidthPackagesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 1 {
		err := GetCloudBandwidthPackagesRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegion()) < 1 {
		err := GetCloudBandwidthPackagesRequestValidationError{
			field:  "Region",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountID

	if len(errors) > 0 {
		return GetCloudBandwidthPackagesRequestMultiError(errors)
	}

	return nil
}

// GetCloudBandwidthPackagesRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetCloudBandwidthPackagesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCloudBandwidthPackagesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudBandwidthPackagesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudBandwidthPackagesRequestMultiError) AllErrors() []error { return m }

// GetCloudBandwidthPackagesRequestValidationError is the validation error
// returned by GetCloudBandwidthPackagesRequest.Validate if the designated
// constraints aren't met.
type GetCloudBandwidthPackagesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudBandwidthPackagesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudBandwidthPackagesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudBandwidthPackagesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudBandwidthPackagesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudBandwidthPackagesRequestValidationError) ErrorName() string {
	return "GetCloudBandwidthPackagesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudBandwidthPackagesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudBandwidthPackagesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudBandwidthPackagesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudBandwidthPackagesRequestValidationError{}

// Validate checks the field values on GetCloudBandwidthPackagesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetCloudBandwidthPackagesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCloudBandwidthPackagesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetCloudBandwidthPackagesResponseMultiError, or nil if none found.
func (m *GetCloudBandwidthPackagesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCloudBandwidthPackagesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCloudBandwidthPackagesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCloudBandwidthPackagesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCloudBandwidthPackagesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCloudBandwidthPackagesResponseMultiError(errors)
	}

	return nil
}

// GetCloudBandwidthPackagesResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetCloudBandwidthPackagesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCloudBandwidthPackagesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCloudBandwidthPackagesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCloudBandwidthPackagesResponseMultiError) AllErrors() []error { return m }

// GetCloudBandwidthPackagesResponseValidationError is the validation error
// returned by GetCloudBandwidthPackagesResponse.Validate if the designated
// constraints aren't met.
type GetCloudBandwidthPackagesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCloudBandwidthPackagesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCloudBandwidthPackagesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCloudBandwidthPackagesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCloudBandwidthPackagesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCloudBandwidthPackagesResponseValidationError) ErrorName() string {
	return "GetCloudBandwidthPackagesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCloudBandwidthPackagesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCloudBandwidthPackagesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCloudBandwidthPackagesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCloudBandwidthPackagesResponseValidationError{}

// Validate checks the field values on BandwidthPackageInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BandwidthPackageInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BandwidthPackageInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BandwidthPackageInfoMultiError, or nil if none found.
func (m *BandwidthPackageInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BandwidthPackageInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for NetworkType

	// no validation rules for Status

	// no validation rules for Bandwidth

	if len(errors) > 0 {
		return BandwidthPackageInfoMultiError(errors)
	}

	return nil
}

// BandwidthPackageInfoMultiError is an error wrapping multiple validation
// errors returned by BandwidthPackageInfo.ValidateAll() if the designated
// constraints aren't met.
type BandwidthPackageInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BandwidthPackageInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BandwidthPackageInfoMultiError) AllErrors() []error { return m }

// BandwidthPackageInfoValidationError is the validation error returned by
// BandwidthPackageInfo.Validate if the designated constraints aren't met.
type BandwidthPackageInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BandwidthPackageInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BandwidthPackageInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BandwidthPackageInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BandwidthPackageInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BandwidthPackageInfoValidationError) ErrorName() string {
	return "BandwidthPackageInfoValidationError"
}

// Error satisfies the builtin error interface
func (e BandwidthPackageInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBandwidthPackageInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BandwidthPackageInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BandwidthPackageInfoValidationError{}

// Validate checks the field values on ListCloudOsImageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudOsImageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudOsImageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudOsImageRequestMultiError, or nil if none found.
func (m *ListCloudOsImageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudOsImageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudOsImageRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	// no validation rules for Provider

	// no validation rules for ProjectID

	if len(errors) > 0 {
		return ListCloudOsImageRequestMultiError(errors)
	}

	return nil
}

// ListCloudOsImageRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudOsImageRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudOsImageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudOsImageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudOsImageRequestMultiError) AllErrors() []error { return m }

// ListCloudOsImageRequestValidationError is the validation error returned by
// ListCloudOsImageRequest.Validate if the designated constraints aren't met.
type ListCloudOsImageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudOsImageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudOsImageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudOsImageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudOsImageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudOsImageRequestValidationError) ErrorName() string {
	return "ListCloudOsImageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudOsImageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudOsImageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudOsImageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudOsImageRequestValidationError{}

// Validate checks the field values on ListCloudOsImageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudOsImageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudOsImageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudOsImageResponseMultiError, or nil if none found.
func (m *ListCloudOsImageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudOsImageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudOsImageResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudOsImageResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudOsImageResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudOsImageResponseMultiError(errors)
	}

	return nil
}

// ListCloudOsImageResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudOsImageResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudOsImageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudOsImageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudOsImageResponseMultiError) AllErrors() []error { return m }

// ListCloudOsImageResponseValidationError is the validation error returned by
// ListCloudOsImageResponse.Validate if the designated constraints aren't met.
type ListCloudOsImageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudOsImageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudOsImageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudOsImageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudOsImageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudOsImageResponseValidationError) ErrorName() string {
	return "ListCloudOsImageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudOsImageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudOsImageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudOsImageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudOsImageResponseValidationError{}

// Validate checks the field values on OsImage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OsImage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OsImage with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OsImageMultiError, or nil if none found.
func (m *OsImage) ValidateAll() error {
	return m.validate(true)
}

func (m *OsImage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ImageID

	// no validation rules for Alias

	// no validation rules for Arch

	// no validation rules for OsCustomizeType

	// no validation rules for OsName

	// no validation rules for SeriesName

	// no validation rules for Status

	// no validation rules for Provider

	for idx, item := range m.GetClusters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OsImageValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OsImageValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OsImageValidationError{
					field:  fmt.Sprintf("Clusters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OsImageMultiError(errors)
	}

	return nil
}

// OsImageMultiError is an error wrapping multiple validation errors returned
// by OsImage.ValidateAll() if the designated constraints aren't met.
type OsImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OsImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OsImageMultiError) AllErrors() []error { return m }

// OsImageValidationError is the validation error returned by OsImage.Validate
// if the designated constraints aren't met.
type OsImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OsImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OsImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OsImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OsImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OsImageValidationError) ErrorName() string { return "OsImageValidationError" }

// Error satisfies the builtin error interface
func (e OsImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOsImage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OsImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OsImageValidationError{}

// Validate checks the field values on ClusterInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterInfoMultiError, or
// nil if none found.
func (m *ClusterInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterName

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ClusterInfoMultiError(errors)
	}

	return nil
}

// ClusterInfoMultiError is an error wrapping multiple validation errors
// returned by ClusterInfo.ValidateAll() if the designated constraints aren't met.
type ClusterInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterInfoMultiError) AllErrors() []error { return m }

// ClusterInfoValidationError is the validation error returned by
// ClusterInfo.Validate if the designated constraints aren't met.
type ClusterInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterInfoValidationError) ErrorName() string { return "ClusterInfoValidationError" }

// Error satisfies the builtin error interface
func (e ClusterInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterInfoValidationError{}

// Validate checks the field values on ListCloudRuntimeInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRuntimeInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRuntimeInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudRuntimeInfoRequestMultiError, or nil if none found.
func (m *ListCloudRuntimeInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRuntimeInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudRuntimeInfoRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCloudRuntimeInfoRequestMultiError(errors)
	}

	return nil
}

// ListCloudRuntimeInfoRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudRuntimeInfoRequest.ValidateAll() if
// the designated constraints aren't met.
type ListCloudRuntimeInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRuntimeInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRuntimeInfoRequestMultiError) AllErrors() []error { return m }

// ListCloudRuntimeInfoRequestValidationError is the validation error returned
// by ListCloudRuntimeInfoRequest.Validate if the designated constraints
// aren't met.
type ListCloudRuntimeInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRuntimeInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRuntimeInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRuntimeInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRuntimeInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRuntimeInfoRequestValidationError) ErrorName() string {
	return "ListCloudRuntimeInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRuntimeInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRuntimeInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRuntimeInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRuntimeInfoRequestValidationError{}

// Validate checks the field values on ListCloudRuntimeInfoResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudRuntimeInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudRuntimeInfoResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudRuntimeInfoResponseMultiError, or nil if none found.
func (m *ListCloudRuntimeInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudRuntimeInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	{
		sorted_keys := make([]string, len(m.GetData()))
		i := 0
		for key := range m.GetData() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetData()[key]
			_ = val

			// no validation rules for Data[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ListCloudRuntimeInfoResponseValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ListCloudRuntimeInfoResponseValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ListCloudRuntimeInfoResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ListCloudRuntimeInfoResponseMultiError(errors)
	}

	return nil
}

// ListCloudRuntimeInfoResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudRuntimeInfoResponse.ValidateAll() if
// the designated constraints aren't met.
type ListCloudRuntimeInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudRuntimeInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudRuntimeInfoResponseMultiError) AllErrors() []error { return m }

// ListCloudRuntimeInfoResponseValidationError is the validation error returned
// by ListCloudRuntimeInfoResponse.Validate if the designated constraints
// aren't met.
type ListCloudRuntimeInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudRuntimeInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudRuntimeInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudRuntimeInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudRuntimeInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudRuntimeInfoResponseValidationError) ErrorName() string {
	return "ListCloudRuntimeInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudRuntimeInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudRuntimeInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudRuntimeInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudRuntimeInfoResponseValidationError{}

// Validate checks the field values on RunTimeVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunTimeVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunTimeVersion with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunTimeVersionMultiError,
// or nil if none found.
func (m *RunTimeVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *RunTimeVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RunTimeVersionMultiError(errors)
	}

	return nil
}

// RunTimeVersionMultiError is an error wrapping multiple validation errors
// returned by RunTimeVersion.ValidateAll() if the designated constraints
// aren't met.
type RunTimeVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunTimeVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunTimeVersionMultiError) AllErrors() []error { return m }

// RunTimeVersionValidationError is the validation error returned by
// RunTimeVersion.Validate if the designated constraints aren't met.
type RunTimeVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunTimeVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunTimeVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunTimeVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunTimeVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunTimeVersionValidationError) ErrorName() string { return "RunTimeVersionValidationError" }

// Error satisfies the builtin error interface
func (e RunTimeVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunTimeVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunTimeVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunTimeVersionValidationError{}

// Validate checks the field values on ListCloudProjectsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudProjectsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudProjectsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudProjectsRequestMultiError, or nil if none found.
func (m *ListCloudProjectsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudProjectsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudProjectsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	if len(errors) > 0 {
		return ListCloudProjectsRequestMultiError(errors)
	}

	return nil
}

// ListCloudProjectsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudProjectsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudProjectsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudProjectsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudProjectsRequestMultiError) AllErrors() []error { return m }

// ListCloudProjectsRequestValidationError is the validation error returned by
// ListCloudProjectsRequest.Validate if the designated constraints aren't met.
type ListCloudProjectsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudProjectsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudProjectsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudProjectsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudProjectsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudProjectsRequestValidationError) ErrorName() string {
	return "ListCloudProjectsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudProjectsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudProjectsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudProjectsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudProjectsRequestValidationError{}

// Validate checks the field values on ListCloudProjectsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudProjectsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudProjectsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudProjectsResponseMultiError, or nil if none found.
func (m *ListCloudProjectsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudProjectsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudProjectsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudProjectsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudProjectsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudProjectsResponseMultiError(errors)
	}

	return nil
}

// ListCloudProjectsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudProjectsResponse.ValidateAll() if the
// designated constraints aren't met.
type ListCloudProjectsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudProjectsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudProjectsResponseMultiError) AllErrors() []error { return m }

// ListCloudProjectsResponseValidationError is the validation error returned by
// ListCloudProjectsResponse.Validate if the designated constraints aren't met.
type ListCloudProjectsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudProjectsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudProjectsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudProjectsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudProjectsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudProjectsResponseValidationError) ErrorName() string {
	return "ListCloudProjectsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudProjectsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudProjectsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudProjectsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudProjectsResponseValidationError{}

// Validate checks the field values on CloudProject with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudProject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudProject with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudProjectMultiError, or
// nil if none found.
func (m *CloudProject) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudProject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for ProjectName

	if len(errors) > 0 {
		return CloudProjectMultiError(errors)
	}

	return nil
}

// CloudProjectMultiError is an error wrapping multiple validation errors
// returned by CloudProject.ValidateAll() if the designated constraints aren't met.
type CloudProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudProjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudProjectMultiError) AllErrors() []error { return m }

// CloudProjectValidationError is the validation error returned by
// CloudProject.Validate if the designated constraints aren't met.
type CloudProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudProjectValidationError) ErrorName() string { return "CloudProjectValidationError" }

// Error satisfies the builtin error interface
func (e CloudProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudProject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudProjectValidationError{}

// Validate checks the field values on ListCloudVpcsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudVpcsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudVpcsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudVpcsRequestMultiError, or nil if none found.
func (m *ListCloudVpcsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudVpcsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudVpcsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	// no validation rules for VpcID

	// no validation rules for ResourceGroupName

	if len(errors) > 0 {
		return ListCloudVpcsRequestMultiError(errors)
	}

	return nil
}

// ListCloudVpcsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudVpcsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudVpcsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudVpcsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudVpcsRequestMultiError) AllErrors() []error { return m }

// ListCloudVpcsRequestValidationError is the validation error returned by
// ListCloudVpcsRequest.Validate if the designated constraints aren't met.
type ListCloudVpcsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudVpcsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudVpcsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudVpcsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudVpcsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudVpcsRequestValidationError) ErrorName() string {
	return "ListCloudVpcsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudVpcsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudVpcsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudVpcsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudVpcsRequestValidationError{}

// Validate checks the field values on ListCloudVpcsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudVpcsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudVpcsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudVpcsResponseMultiError, or nil if none found.
func (m *ListCloudVpcsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudVpcsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudVpcsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudVpcsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudVpcsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudVpcsResponseMultiError(errors)
	}

	return nil
}

// ListCloudVpcsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudVpcsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudVpcsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudVpcsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudVpcsResponseMultiError) AllErrors() []error { return m }

// ListCloudVpcsResponseValidationError is the validation error returned by
// ListCloudVpcsResponse.Validate if the designated constraints aren't met.
type ListCloudVpcsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudVpcsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudVpcsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudVpcsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudVpcsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudVpcsResponseValidationError) ErrorName() string {
	return "ListCloudVpcsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudVpcsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudVpcsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudVpcsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudVpcsResponseValidationError{}

// Validate checks the field values on CloudVpc with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CloudVpc) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudVpc with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CloudVpcMultiError, or nil
// if none found.
func (m *CloudVpc) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudVpc) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for VpcId

	// no validation rules for Ipv4Cidr

	// no validation rules for Ipv6Cidr

	for idx, item := range m.GetCidrs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudVpcValidationError{
						field:  fmt.Sprintf("Cidrs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudVpcValidationError{
						field:  fmt.Sprintf("Cidrs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudVpcValidationError{
					field:  fmt.Sprintf("Cidrs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AllocateIpNum

	if len(errors) > 0 {
		return CloudVpcMultiError(errors)
	}

	return nil
}

// CloudVpcMultiError is an error wrapping multiple validation errors returned
// by CloudVpc.ValidateAll() if the designated constraints aren't met.
type CloudVpcMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudVpcMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudVpcMultiError) AllErrors() []error { return m }

// CloudVpcValidationError is the validation error returned by
// CloudVpc.Validate if the designated constraints aren't met.
type CloudVpcValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudVpcValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudVpcValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudVpcValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudVpcValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudVpcValidationError) ErrorName() string { return "CloudVpcValidationError" }

// Error satisfies the builtin error interface
func (e CloudVpcValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudVpc.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudVpcValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudVpcValidationError{}

// Validate checks the field values on AssistantCidr with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssistantCidr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssistantCidr with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssistantCidrMultiError, or
// nil if none found.
func (m *AssistantCidr) ValidateAll() error {
	return m.validate(true)
}

func (m *AssistantCidr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cidr

	// no validation rules for CidrType

	if len(errors) > 0 {
		return AssistantCidrMultiError(errors)
	}

	return nil
}

// AssistantCidrMultiError is an error wrapping multiple validation errors
// returned by AssistantCidr.ValidateAll() if the designated constraints
// aren't met.
type AssistantCidrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssistantCidrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssistantCidrMultiError) AllErrors() []error { return m }

// AssistantCidrValidationError is the validation error returned by
// AssistantCidr.Validate if the designated constraints aren't met.
type AssistantCidrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssistantCidrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssistantCidrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssistantCidrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssistantCidrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssistantCidrValidationError) ErrorName() string { return "AssistantCidrValidationError" }

// Error satisfies the builtin error interface
func (e AssistantCidrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssistantCidr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssistantCidrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssistantCidrValidationError{}

// Validate checks the field values on ListCloudSubnetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudSubnetsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudSubnetsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudSubnetsRequestMultiError, or nil if none found.
func (m *ListCloudSubnetsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudSubnetsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudSubnetsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	if utf8.RuneCountInString(m.GetAccountID()) < 2 {
		err := ListCloudSubnetsRequestValidationError{
			field:  "AccountID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for VpcID

	// no validation rules for Zone

	// no validation rules for SubnetID

	// no validation rules for InjectCluster

	// no validation rules for ResourceGroupName

	if len(errors) > 0 {
		return ListCloudSubnetsRequestMultiError(errors)
	}

	return nil
}

// ListCloudSubnetsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCloudSubnetsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCloudSubnetsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudSubnetsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudSubnetsRequestMultiError) AllErrors() []error { return m }

// ListCloudSubnetsRequestValidationError is the validation error returned by
// ListCloudSubnetsRequest.Validate if the designated constraints aren't met.
type ListCloudSubnetsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudSubnetsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudSubnetsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudSubnetsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudSubnetsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudSubnetsRequestValidationError) ErrorName() string {
	return "ListCloudSubnetsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudSubnetsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudSubnetsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudSubnetsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudSubnetsRequestValidationError{}

// Validate checks the field values on ListCloudSubnetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudSubnetsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudSubnetsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudSubnetsResponseMultiError, or nil if none found.
func (m *ListCloudSubnetsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudSubnetsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudSubnetsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudSubnetsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudSubnetsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudSubnetsResponseMultiError(errors)
	}

	return nil
}

// ListCloudSubnetsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCloudSubnetsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCloudSubnetsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudSubnetsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudSubnetsResponseMultiError) AllErrors() []error { return m }

// ListCloudSubnetsResponseValidationError is the validation error returned by
// ListCloudSubnetsResponse.Validate if the designated constraints aren't met.
type ListCloudSubnetsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudSubnetsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudSubnetsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudSubnetsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudSubnetsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudSubnetsResponseValidationError) ErrorName() string {
	return "ListCloudSubnetsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudSubnetsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudSubnetsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudSubnetsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudSubnetsResponseValidationError{}

// Validate checks the field values on Subnet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subnet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subnet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SubnetMultiError, or nil if none found.
func (m *Subnet) ValidateAll() error {
	return m.validate(true)
}

func (m *Subnet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VpcID

	// no validation rules for SubnetID

	// no validation rules for SubnetName

	// no validation rules for CidrRange

	// no validation rules for Ipv6CidrRange

	// no validation rules for Zone

	// no validation rules for AvailableIPAddressCount

	// no validation rules for ZoneName

	if all {
		switch v := interface{}(m.GetCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubnetValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubnetValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubnetValidationError{
				field:  "Cluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubnetMultiError(errors)
	}

	return nil
}

// SubnetMultiError is an error wrapping multiple validation errors returned by
// Subnet.ValidateAll() if the designated constraints aren't met.
type SubnetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubnetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubnetMultiError) AllErrors() []error { return m }

// SubnetValidationError is the validation error returned by Subnet.Validate if
// the designated constraints aren't met.
type SubnetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubnetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubnetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubnetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubnetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubnetValidationError) ErrorName() string { return "SubnetValidationError" }

// Error satisfies the builtin error interface
func (e SubnetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubnet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubnetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubnetValidationError{}

// Validate checks the field values on CheckCidrConflictFromVpcRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckCidrConflictFromVpcRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckCidrConflictFromVpcRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CheckCidrConflictFromVpcRequestMultiError, or nil if none found.
func (m *CheckCidrConflictFromVpcRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckCidrConflictFromVpcRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := CheckCidrConflictFromVpcRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for VpcId

	// no validation rules for Cidr

	if utf8.RuneCountInString(m.GetRegion()) < 2 {
		err := CheckCidrConflictFromVpcRequestValidationError{
			field:  "Region",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountID

	if len(errors) > 0 {
		return CheckCidrConflictFromVpcRequestMultiError(errors)
	}

	return nil
}

// CheckCidrConflictFromVpcRequestMultiError is an error wrapping multiple
// validation errors returned by CheckCidrConflictFromVpcRequest.ValidateAll()
// if the designated constraints aren't met.
type CheckCidrConflictFromVpcRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckCidrConflictFromVpcRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckCidrConflictFromVpcRequestMultiError) AllErrors() []error { return m }

// CheckCidrConflictFromVpcRequestValidationError is the validation error
// returned by CheckCidrConflictFromVpcRequest.Validate if the designated
// constraints aren't met.
type CheckCidrConflictFromVpcRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckCidrConflictFromVpcRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckCidrConflictFromVpcRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckCidrConflictFromVpcRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckCidrConflictFromVpcRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckCidrConflictFromVpcRequestValidationError) ErrorName() string {
	return "CheckCidrConflictFromVpcRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckCidrConflictFromVpcRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckCidrConflictFromVpcRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckCidrConflictFromVpcRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckCidrConflictFromVpcRequestValidationError{}

// Validate checks the field values on CheckCidrConflictFromVpcResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CheckCidrConflictFromVpcResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckCidrConflictFromVpcResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CheckCidrConflictFromVpcResponseMultiError, or nil if none found.
func (m *CheckCidrConflictFromVpcResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckCidrConflictFromVpcResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckCidrConflictFromVpcResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckCidrConflictFromVpcResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckCidrConflictFromVpcResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckCidrConflictFromVpcResponseMultiError(errors)
	}

	return nil
}

// CheckCidrConflictFromVpcResponseMultiError is an error wrapping multiple
// validation errors returned by
// CheckCidrConflictFromVpcResponse.ValidateAll() if the designated
// constraints aren't met.
type CheckCidrConflictFromVpcResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckCidrConflictFromVpcResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckCidrConflictFromVpcResponseMultiError) AllErrors() []error { return m }

// CheckCidrConflictFromVpcResponseValidationError is the validation error
// returned by CheckCidrConflictFromVpcResponse.Validate if the designated
// constraints aren't met.
type CheckCidrConflictFromVpcResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckCidrConflictFromVpcResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckCidrConflictFromVpcResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckCidrConflictFromVpcResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckCidrConflictFromVpcResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckCidrConflictFromVpcResponseValidationError) ErrorName() string {
	return "CheckCidrConflictFromVpcResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckCidrConflictFromVpcResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckCidrConflictFromVpcResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckCidrConflictFromVpcResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckCidrConflictFromVpcResponseValidationError{}

// Validate checks the field values on ConflictInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConflictInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConflictInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConflictInfoMultiError, or
// nil if none found.
func (m *ConflictInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ConflictInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ConflictInfoMultiError(errors)
	}

	return nil
}

// ConflictInfoMultiError is an error wrapping multiple validation errors
// returned by ConflictInfo.ValidateAll() if the designated constraints aren't met.
type ConflictInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConflictInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConflictInfoMultiError) AllErrors() []error { return m }

// ConflictInfoValidationError is the validation error returned by
// ConflictInfo.Validate if the designated constraints aren't met.
type ConflictInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConflictInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConflictInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConflictInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConflictInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConflictInfoValidationError) ErrorName() string { return "ConflictInfoValidationError" }

// Error satisfies the builtin error interface
func (e ConflictInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConflictInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConflictInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConflictInfoValidationError{}

// Validate checks the field values on ListCloudSecurityGroupsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudSecurityGroupsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudSecurityGroupsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudSecurityGroupsRequestMultiError, or nil if none found.
func (m *ListCloudSecurityGroupsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudSecurityGroupsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListCloudSecurityGroupsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	// no validation rules for ResourceGroupName

	if len(errors) > 0 {
		return ListCloudSecurityGroupsRequestMultiError(errors)
	}

	return nil
}

// ListCloudSecurityGroupsRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudSecurityGroupsRequest.ValidateAll()
// if the designated constraints aren't met.
type ListCloudSecurityGroupsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudSecurityGroupsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudSecurityGroupsRequestMultiError) AllErrors() []error { return m }

// ListCloudSecurityGroupsRequestValidationError is the validation error
// returned by ListCloudSecurityGroupsRequest.Validate if the designated
// constraints aren't met.
type ListCloudSecurityGroupsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudSecurityGroupsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudSecurityGroupsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudSecurityGroupsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudSecurityGroupsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudSecurityGroupsRequestValidationError) ErrorName() string {
	return "ListCloudSecurityGroupsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudSecurityGroupsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudSecurityGroupsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudSecurityGroupsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudSecurityGroupsRequestValidationError{}

// Validate checks the field values on ListCloudSecurityGroupsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudSecurityGroupsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudSecurityGroupsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListCloudSecurityGroupsResponseMultiError, or nil if none found.
func (m *ListCloudSecurityGroupsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudSecurityGroupsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudSecurityGroupsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudSecurityGroupsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudSecurityGroupsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudSecurityGroupsResponseMultiError(errors)
	}

	return nil
}

// ListCloudSecurityGroupsResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudSecurityGroupsResponse.ValidateAll()
// if the designated constraints aren't met.
type ListCloudSecurityGroupsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudSecurityGroupsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudSecurityGroupsResponseMultiError) AllErrors() []error { return m }

// ListCloudSecurityGroupsResponseValidationError is the validation error
// returned by ListCloudSecurityGroupsResponse.Validate if the designated
// constraints aren't met.
type ListCloudSecurityGroupsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudSecurityGroupsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudSecurityGroupsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudSecurityGroupsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudSecurityGroupsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudSecurityGroupsResponseValidationError) ErrorName() string {
	return "ListCloudSecurityGroupsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudSecurityGroupsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudSecurityGroupsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudSecurityGroupsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudSecurityGroupsResponseValidationError{}

// Validate checks the field values on ListKeyPairsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListKeyPairsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListKeyPairsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListKeyPairsRequestMultiError, or nil if none found.
func (m *ListKeyPairsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListKeyPairsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCloudID()) < 2 {
		err := ListKeyPairsRequestValidationError{
			field:  "CloudID",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	// no validation rules for AccountID

	// no validation rules for ResourceGroupName

	if len(errors) > 0 {
		return ListKeyPairsRequestMultiError(errors)
	}

	return nil
}

// ListKeyPairsRequestMultiError is an error wrapping multiple validation
// errors returned by ListKeyPairsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListKeyPairsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListKeyPairsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListKeyPairsRequestMultiError) AllErrors() []error { return m }

// ListKeyPairsRequestValidationError is the validation error returned by
// ListKeyPairsRequest.Validate if the designated constraints aren't met.
type ListKeyPairsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListKeyPairsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListKeyPairsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListKeyPairsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListKeyPairsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListKeyPairsRequestValidationError) ErrorName() string {
	return "ListKeyPairsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListKeyPairsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListKeyPairsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListKeyPairsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListKeyPairsRequestValidationError{}

// Validate checks the field values on ListKeyPairsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListKeyPairsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListKeyPairsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListKeyPairsResponseMultiError, or nil if none found.
func (m *ListKeyPairsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListKeyPairsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListKeyPairsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListKeyPairsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListKeyPairsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListKeyPairsResponseMultiError(errors)
	}

	return nil
}

// ListKeyPairsResponseMultiError is an error wrapping multiple validation
// errors returned by ListKeyPairsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListKeyPairsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListKeyPairsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListKeyPairsResponseMultiError) AllErrors() []error { return m }

// ListKeyPairsResponseValidationError is the validation error returned by
// ListKeyPairsResponse.Validate if the designated constraints aren't met.
type ListKeyPairsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListKeyPairsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListKeyPairsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListKeyPairsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListKeyPairsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListKeyPairsResponseValidationError) ErrorName() string {
	return "ListKeyPairsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListKeyPairsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListKeyPairsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListKeyPairsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListKeyPairsResponseValidationError{}

// Validate checks the field values on KeyPair with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyPair) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyPair with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KeyPairMultiError, or nil if none found.
func (m *KeyPair) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyPair) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for KeyID

	// no validation rules for KeyName

	// no validation rules for Description

	if len(errors) > 0 {
		return KeyPairMultiError(errors)
	}

	return nil
}

// KeyPairMultiError is an error wrapping multiple validation errors returned
// by KeyPair.ValidateAll() if the designated constraints aren't met.
type KeyPairMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyPairMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyPairMultiError) AllErrors() []error { return m }

// KeyPairValidationError is the validation error returned by KeyPair.Validate
// if the designated constraints aren't met.
type KeyPairValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyPairValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyPairValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyPairValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyPairValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyPairValidationError) ErrorName() string { return "KeyPairValidationError" }

// Error satisfies the builtin error interface
func (e KeyPairValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyPair.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyPairValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyPairValidationError{}

// Validate checks the field values on ListOperationLogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperationLogsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperationLogsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOperationLogsRequestMultiError, or nil if none found.
func (m *ListOperationLogsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperationLogsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ListOperationLogsRequest_ResourceType_InLookup[m.GetResourceType()]; !ok {
		err := ListOperationLogsRequestValidationError{
			field:  "ResourceType",
			reason: "value must be in list [cluster autoscalingoption cloud cloudvpc nodegroup task]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceID

	if m.GetStartTime() <= 0 {
		err := ListOperationLogsRequestValidationError{
			field:  "StartTime",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetEndTime() <= 0 {
		err := ListOperationLogsRequestValidationError{
			field:  "EndTime",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := ListOperationLogsRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPage() <= 0 {
		err := ListOperationLogsRequestValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Simple

	// no validation rules for TaskIDNull

	// no validation rules for ClusterID

	// no validation rules for ProjectID

	// no validation rules for Status

	// no validation rules for TaskType

	// no validation rules for V2

	// no validation rules for IpList

	if len(errors) > 0 {
		return ListOperationLogsRequestMultiError(errors)
	}

	return nil
}

// ListOperationLogsRequestMultiError is an error wrapping multiple validation
// errors returned by ListOperationLogsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListOperationLogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperationLogsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperationLogsRequestMultiError) AllErrors() []error { return m }

// ListOperationLogsRequestValidationError is the validation error returned by
// ListOperationLogsRequest.Validate if the designated constraints aren't met.
type ListOperationLogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperationLogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperationLogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperationLogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperationLogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperationLogsRequestValidationError) ErrorName() string {
	return "ListOperationLogsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperationLogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperationLogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperationLogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperationLogsRequestValidationError{}

var _ListOperationLogsRequest_ResourceType_InLookup = map[string]struct{}{
	"cluster":           {},
	"autoscalingoption": {},
	"cloud":             {},
	"cloudvpc":          {},
	"nodegroup":         {},
	"task":              {},
}

// Validate checks the field values on ListOperationLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperationLogsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperationLogsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOperationLogsResponseMultiError, or nil if none found.
func (m *ListOperationLogsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperationLogsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOperationLogsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOperationLogsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOperationLogsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListOperationLogsResponseMultiError(errors)
	}

	return nil
}

// ListOperationLogsResponseMultiError is an error wrapping multiple validation
// errors returned by ListOperationLogsResponse.ValidateAll() if the
// designated constraints aren't met.
type ListOperationLogsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperationLogsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperationLogsResponseMultiError) AllErrors() []error { return m }

// ListOperationLogsResponseValidationError is the validation error returned by
// ListOperationLogsResponse.Validate if the designated constraints aren't met.
type ListOperationLogsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperationLogsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperationLogsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperationLogsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperationLogsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperationLogsResponseValidationError) ErrorName() string {
	return "ListOperationLogsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperationLogsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperationLogsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperationLogsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperationLogsResponseValidationError{}

// Validate checks the field values on ListOperationLogsResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperationLogsResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperationLogsResponseData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListOperationLogsResponseDataMultiError, or nil if none found.
func (m *ListOperationLogsResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperationLogsResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperationLogsResponseDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperationLogsResponseDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperationLogsResponseDataValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListOperationLogsResponseDataMultiError(errors)
	}

	return nil
}

// ListOperationLogsResponseDataMultiError is an error wrapping multiple
// validation errors returned by ListOperationLogsResponseData.ValidateAll()
// if the designated constraints aren't met.
type ListOperationLogsResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperationLogsResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperationLogsResponseDataMultiError) AllErrors() []error { return m }

// ListOperationLogsResponseDataValidationError is the validation error
// returned by ListOperationLogsResponseData.Validate if the designated
// constraints aren't met.
type ListOperationLogsResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperationLogsResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperationLogsResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperationLogsResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperationLogsResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperationLogsResponseDataValidationError) ErrorName() string {
	return "ListOperationLogsResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperationLogsResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperationLogsResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperationLogsResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperationLogsResponseDataValidationError{}

// Validate checks the field values on OperationLogDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationLogDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationLogDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationLogDetailMultiError, or nil if none found.
func (m *OperationLogDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationLogDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceType

	// no validation rules for ResourceID

	// no validation rules for TaskID

	// no validation rules for Message

	// no validation rules for OpUser

	// no validation rules for CreateTime

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationLogDetailValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationLogDetailValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationLogDetailValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TaskType

	// no validation rules for Status

	// no validation rules for ResourceName

	if len(errors) > 0 {
		return OperationLogDetailMultiError(errors)
	}

	return nil
}

// OperationLogDetailMultiError is an error wrapping multiple validation errors
// returned by OperationLogDetail.ValidateAll() if the designated constraints
// aren't met.
type OperationLogDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationLogDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationLogDetailMultiError) AllErrors() []error { return m }

// OperationLogDetailValidationError is the validation error returned by
// OperationLogDetail.Validate if the designated constraints aren't met.
type OperationLogDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationLogDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationLogDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationLogDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationLogDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationLogDetailValidationError) ErrorName() string {
	return "OperationLogDetailValidationError"
}

// Error satisfies the builtin error interface
func (e OperationLogDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationLogDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationLogDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationLogDetailValidationError{}

// Validate checks the field values on CleanDbHistoryDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanDbHistoryDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanDbHistoryDataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanDbHistoryDataRequestMultiError, or nil if none found.
func (m *CleanDbHistoryDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanDbHistoryDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _CleanDbHistoryDataRequest_DataType_InLookup[m.GetDataType()]; !ok {
		err := CleanDbHistoryDataRequestValidationError{
			field:  "DataType",
			reason: "value must be in list [task operationlog]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	if len(errors) > 0 {
		return CleanDbHistoryDataRequestMultiError(errors)
	}

	return nil
}

// CleanDbHistoryDataRequestMultiError is an error wrapping multiple validation
// errors returned by CleanDbHistoryDataRequest.ValidateAll() if the
// designated constraints aren't met.
type CleanDbHistoryDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanDbHistoryDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanDbHistoryDataRequestMultiError) AllErrors() []error { return m }

// CleanDbHistoryDataRequestValidationError is the validation error returned by
// CleanDbHistoryDataRequest.Validate if the designated constraints aren't met.
type CleanDbHistoryDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanDbHistoryDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanDbHistoryDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanDbHistoryDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanDbHistoryDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanDbHistoryDataRequestValidationError) ErrorName() string {
	return "CleanDbHistoryDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CleanDbHistoryDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanDbHistoryDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanDbHistoryDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanDbHistoryDataRequestValidationError{}

var _CleanDbHistoryDataRequest_DataType_InLookup = map[string]struct{}{
	"task":         {},
	"operationlog": {},
}

// Validate checks the field values on CleanDbHistoryDataResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CleanDbHistoryDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanDbHistoryDataResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CleanDbHistoryDataResponseMultiError, or nil if none found.
func (m *CleanDbHistoryDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanDbHistoryDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return CleanDbHistoryDataResponseMultiError(errors)
	}

	return nil
}

// CleanDbHistoryDataResponseMultiError is an error wrapping multiple
// validation errors returned by CleanDbHistoryDataResponse.ValidateAll() if
// the designated constraints aren't met.
type CleanDbHistoryDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanDbHistoryDataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanDbHistoryDataResponseMultiError) AllErrors() []error { return m }

// CleanDbHistoryDataResponseValidationError is the validation error returned
// by CleanDbHistoryDataResponse.Validate if the designated constraints aren't met.
type CleanDbHistoryDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanDbHistoryDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanDbHistoryDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanDbHistoryDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanDbHistoryDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanDbHistoryDataResponseValidationError) ErrorName() string {
	return "CleanDbHistoryDataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CleanDbHistoryDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanDbHistoryDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanDbHistoryDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanDbHistoryDataResponseValidationError{}

// Validate checks the field values on SecurityGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecurityGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecurityGroupMultiError, or
// nil if none found.
func (m *SecurityGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityGroupID

	// no validation rules for SecurityGroupName

	// no validation rules for Description

	if len(errors) > 0 {
		return SecurityGroupMultiError(errors)
	}

	return nil
}

// SecurityGroupMultiError is an error wrapping multiple validation errors
// returned by SecurityGroup.ValidateAll() if the designated constraints
// aren't met.
type SecurityGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityGroupMultiError) AllErrors() []error { return m }

// SecurityGroupValidationError is the validation error returned by
// SecurityGroup.Validate if the designated constraints aren't met.
type SecurityGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityGroupValidationError) ErrorName() string { return "SecurityGroupValidationError" }

// Error satisfies the builtin error interface
func (e SecurityGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityGroupValidationError{}

// Validate checks the field values on NodeOperationStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeOperationStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeOperationStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeOperationStatusMultiError, or nil if none found.
func (m *NodeOperationStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeOperationStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFail() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeOperationStatusValidationError{
						field:  fmt.Sprintf("Fail[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeOperationStatusValidationError{
						field:  fmt.Sprintf("Fail[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeOperationStatusValidationError{
					field:  fmt.Sprintf("Fail[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSuccess() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeOperationStatusValidationError{
						field:  fmt.Sprintf("Success[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeOperationStatusValidationError{
						field:  fmt.Sprintf("Success[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeOperationStatusValidationError{
					field:  fmt.Sprintf("Success[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeOperationStatusMultiError(errors)
	}

	return nil
}

// NodeOperationStatusMultiError is an error wrapping multiple validation
// errors returned by NodeOperationStatus.ValidateAll() if the designated
// constraints aren't met.
type NodeOperationStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeOperationStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeOperationStatusMultiError) AllErrors() []error { return m }

// NodeOperationStatusValidationError is the validation error returned by
// NodeOperationStatus.Validate if the designated constraints aren't met.
type NodeOperationStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeOperationStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeOperationStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeOperationStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeOperationStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeOperationStatusValidationError) ErrorName() string {
	return "NodeOperationStatusValidationError"
}

// Error satisfies the builtin error interface
func (e NodeOperationStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeOperationStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeOperationStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeOperationStatusValidationError{}

// Validate checks the field values on NodeOperationStatusInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeOperationStatusInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeOperationStatusInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeOperationStatusInfoMultiError, or nil if none found.
func (m *NodeOperationStatusInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeOperationStatusInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeName

	// no validation rules for Message

	if len(errors) > 0 {
		return NodeOperationStatusInfoMultiError(errors)
	}

	return nil
}

// NodeOperationStatusInfoMultiError is an error wrapping multiple validation
// errors returned by NodeOperationStatusInfo.ValidateAll() if the designated
// constraints aren't met.
type NodeOperationStatusInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeOperationStatusInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeOperationStatusInfoMultiError) AllErrors() []error { return m }

// NodeOperationStatusInfoValidationError is the validation error returned by
// NodeOperationStatusInfo.Validate if the designated constraints aren't met.
type NodeOperationStatusInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeOperationStatusInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeOperationStatusInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeOperationStatusInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeOperationStatusInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeOperationStatusInfoValidationError) ErrorName() string {
	return "NodeOperationStatusInfoValidationError"
}

// Error satisfies the builtin error interface
func (e NodeOperationStatusInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeOperationStatusInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeOperationStatusInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeOperationStatusInfoValidationError{}

// Validate checks the field values on DrainNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DrainNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DrainNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DrainNodeRequestMultiError, or nil if none found.
func (m *DrainNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DrainNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClusterID()) < 1 {
		err := DrainNodeRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Force

	// no validation rules for GracePeriodSeconds

	// no validation rules for IgnoreAllDaemonSets

	// no validation rules for Timeout

	// no validation rules for DeleteLocalData

	// no validation rules for Selector

	// no validation rules for PodSelector

	// no validation rules for DisableEviction

	// no validation rules for SkipWaitForDeleteTimeoutSeconds

	// no validation rules for DryRun

	if len(errors) > 0 {
		return DrainNodeRequestMultiError(errors)
	}

	return nil
}

// DrainNodeRequestMultiError is an error wrapping multiple validation errors
// returned by DrainNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type DrainNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DrainNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DrainNodeRequestMultiError) AllErrors() []error { return m }

// DrainNodeRequestValidationError is the validation error returned by
// DrainNodeRequest.Validate if the designated constraints aren't met.
type DrainNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DrainNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DrainNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DrainNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DrainNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DrainNodeRequestValidationError) ErrorName() string { return "DrainNodeRequestValidationError" }

// Error satisfies the builtin error interface
func (e DrainNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDrainNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DrainNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DrainNodeRequestValidationError{}

// Validate checks the field values on DrainNodeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DrainNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DrainNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DrainNodeResponseMultiError, or nil if none found.
func (m *DrainNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DrainNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DrainNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DrainNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DrainNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DrainNodeResponseMultiError(errors)
	}

	return nil
}

// DrainNodeResponseMultiError is an error wrapping multiple validation errors
// returned by DrainNodeResponse.ValidateAll() if the designated constraints
// aren't met.
type DrainNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DrainNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DrainNodeResponseMultiError) AllErrors() []error { return m }

// DrainNodeResponseValidationError is the validation error returned by
// DrainNodeResponse.Validate if the designated constraints aren't met.
type DrainNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DrainNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DrainNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DrainNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DrainNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DrainNodeResponseValidationError) ErrorName() string {
	return "DrainNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DrainNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDrainNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DrainNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DrainNodeResponseValidationError{}

// Validate checks the field values on NodeAnnotation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeAnnotation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeAnnotation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeAnnotationMultiError,
// or nil if none found.
func (m *NodeAnnotation) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeAnnotation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNodeName()) < 1 {
		err := NodeAnnotationValidationError{
			field:  "NodeName",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Annotations

	if len(errors) > 0 {
		return NodeAnnotationMultiError(errors)
	}

	return nil
}

// NodeAnnotationMultiError is an error wrapping multiple validation errors
// returned by NodeAnnotation.ValidateAll() if the designated constraints
// aren't met.
type NodeAnnotationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeAnnotationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeAnnotationMultiError) AllErrors() []error { return m }

// NodeAnnotationValidationError is the validation error returned by
// NodeAnnotation.Validate if the designated constraints aren't met.
type NodeAnnotationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeAnnotationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeAnnotationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeAnnotationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeAnnotationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeAnnotationValidationError) ErrorName() string { return "NodeAnnotationValidationError" }

// Error satisfies the builtin error interface
func (e NodeAnnotationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeAnnotation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeAnnotationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeAnnotationValidationError{}

// Validate checks the field values on UpdateNodeAnnotationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeAnnotationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeAnnotationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeAnnotationsRequestMultiError, or nil if none found.
func (m *UpdateNodeAnnotationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeAnnotationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClusterID()) < 1 {
		err := UpdateNodeAnnotationsRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeAnnotationsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeAnnotationsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeAnnotationsRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateNodeAnnotationsRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeAnnotationsRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateNodeAnnotationsRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateNodeAnnotationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeAnnotationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeAnnotationsRequestMultiError) AllErrors() []error { return m }

// UpdateNodeAnnotationsRequestValidationError is the validation error returned
// by UpdateNodeAnnotationsRequest.Validate if the designated constraints
// aren't met.
type UpdateNodeAnnotationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeAnnotationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeAnnotationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeAnnotationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeAnnotationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeAnnotationsRequestValidationError) ErrorName() string {
	return "UpdateNodeAnnotationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeAnnotationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeAnnotationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeAnnotationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeAnnotationsRequestValidationError{}

// Validate checks the field values on UpdateNodeAnnotationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeAnnotationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeAnnotationsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateNodeAnnotationsResponseMultiError, or nil if none found.
func (m *UpdateNodeAnnotationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeAnnotationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeAnnotationsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeAnnotationsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeAnnotationsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeAnnotationsResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeAnnotationsResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateNodeAnnotationsResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateNodeAnnotationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeAnnotationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeAnnotationsResponseMultiError) AllErrors() []error { return m }

// UpdateNodeAnnotationsResponseValidationError is the validation error
// returned by UpdateNodeAnnotationsResponse.Validate if the designated
// constraints aren't met.
type UpdateNodeAnnotationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeAnnotationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeAnnotationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeAnnotationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeAnnotationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeAnnotationsResponseValidationError) ErrorName() string {
	return "UpdateNodeAnnotationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeAnnotationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeAnnotationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeAnnotationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeAnnotationsResponseValidationError{}

// Validate checks the field values on NodeLabel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeLabel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeLabel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeLabelMultiError, or nil
// if none found.
func (m *NodeLabel) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeLabel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNodeName()) < 1 {
		err := NodeLabelValidationError{
			field:  "NodeName",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Labels

	if len(errors) > 0 {
		return NodeLabelMultiError(errors)
	}

	return nil
}

// NodeLabelMultiError is an error wrapping multiple validation errors returned
// by NodeLabel.ValidateAll() if the designated constraints aren't met.
type NodeLabelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeLabelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeLabelMultiError) AllErrors() []error { return m }

// NodeLabelValidationError is the validation error returned by
// NodeLabel.Validate if the designated constraints aren't met.
type NodeLabelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeLabelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeLabelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeLabelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeLabelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeLabelValidationError) ErrorName() string { return "NodeLabelValidationError" }

// Error satisfies the builtin error interface
func (e NodeLabelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeLabel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeLabelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeLabelValidationError{}

// Validate checks the field values on UpdateNodeLabelsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeLabelsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeLabelsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeLabelsRequestMultiError, or nil if none found.
func (m *UpdateNodeLabelsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeLabelsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeLabelsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeLabelsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeLabelsRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetClusterID()) < 1 {
		err := UpdateNodeLabelsRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateNodeLabelsRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeLabelsRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeLabelsRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeLabelsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeLabelsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeLabelsRequestMultiError) AllErrors() []error { return m }

// UpdateNodeLabelsRequestValidationError is the validation error returned by
// UpdateNodeLabelsRequest.Validate if the designated constraints aren't met.
type UpdateNodeLabelsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeLabelsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeLabelsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeLabelsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeLabelsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeLabelsRequestValidationError) ErrorName() string {
	return "UpdateNodeLabelsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeLabelsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeLabelsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeLabelsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeLabelsRequestValidationError{}

// Validate checks the field values on UpdateNodeLabelsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeLabelsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeLabelsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeLabelsResponseMultiError, or nil if none found.
func (m *UpdateNodeLabelsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeLabelsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeLabelsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeLabelsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeLabelsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeLabelsResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeLabelsResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeLabelsResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeLabelsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeLabelsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeLabelsResponseMultiError) AllErrors() []error { return m }

// UpdateNodeLabelsResponseValidationError is the validation error returned by
// UpdateNodeLabelsResponse.Validate if the designated constraints aren't met.
type UpdateNodeLabelsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeLabelsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeLabelsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeLabelsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeLabelsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeLabelsResponseValidationError) ErrorName() string {
	return "UpdateNodeLabelsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeLabelsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeLabelsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeLabelsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeLabelsResponseValidationError{}

// Validate checks the field values on NodeTaint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeTaint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeTaint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeTaintMultiError, or nil
// if none found.
func (m *NodeTaint) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeTaint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNodeName()) < 1 {
		err := NodeTaintValidationError{
			field:  "NodeName",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTaints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeTaintValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeTaintValidationError{
						field:  fmt.Sprintf("Taints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeTaintValidationError{
					field:  fmt.Sprintf("Taints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeTaintMultiError(errors)
	}

	return nil
}

// NodeTaintMultiError is an error wrapping multiple validation errors returned
// by NodeTaint.ValidateAll() if the designated constraints aren't met.
type NodeTaintMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeTaintMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeTaintMultiError) AllErrors() []error { return m }

// NodeTaintValidationError is the validation error returned by
// NodeTaint.Validate if the designated constraints aren't met.
type NodeTaintValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeTaintValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeTaintValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeTaintValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeTaintValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeTaintValidationError) ErrorName() string { return "NodeTaintValidationError" }

// Error satisfies the builtin error interface
func (e NodeTaintValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeTaint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeTaintValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeTaintValidationError{}

// Validate checks the field values on UpdateNodeTaintsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeTaintsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeTaintsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeTaintsRequestMultiError, or nil if none found.
func (m *UpdateNodeTaintsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeTaintsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeTaintsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeTaintsRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeTaintsRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetClusterID()) < 1 {
		err := UpdateNodeTaintsRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateNodeTaintsRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeTaintsRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeTaintsRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeTaintsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeTaintsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeTaintsRequestMultiError) AllErrors() []error { return m }

// UpdateNodeTaintsRequestValidationError is the validation error returned by
// UpdateNodeTaintsRequest.Validate if the designated constraints aren't met.
type UpdateNodeTaintsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeTaintsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeTaintsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeTaintsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeTaintsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeTaintsRequestValidationError) ErrorName() string {
	return "UpdateNodeTaintsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeTaintsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeTaintsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeTaintsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeTaintsRequestValidationError{}

// Validate checks the field values on UpdateNodeTaintsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeTaintsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeTaintsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeTaintsResponseMultiError, or nil if none found.
func (m *UpdateNodeTaintsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeTaintsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNodeTaintsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNodeTaintsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNodeTaintsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNodeTaintsResponseMultiError(errors)
	}

	return nil
}

// UpdateNodeTaintsResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeTaintsResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeTaintsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeTaintsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeTaintsResponseMultiError) AllErrors() []error { return m }

// UpdateNodeTaintsResponseValidationError is the validation error returned by
// UpdateNodeTaintsResponse.Validate if the designated constraints aren't met.
type UpdateNodeTaintsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeTaintsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeTaintsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeTaintsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeTaintsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeTaintsResponseValidationError) ErrorName() string {
	return "UpdateNodeTaintsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeTaintsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeTaintsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeTaintsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeTaintsResponseValidationError{}

// Validate checks the field values on HealthRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthRequestMultiError, or
// nil if none found.
func (m *HealthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HealthRequestMultiError(errors)
	}

	return nil
}

// HealthRequestMultiError is an error wrapping multiple validation errors
// returned by HealthRequest.ValidateAll() if the designated constraints
// aren't met.
type HealthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthRequestMultiError) AllErrors() []error { return m }

// HealthRequestValidationError is the validation error returned by
// HealthRequest.Validate if the designated constraints aren't met.
type HealthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthRequestValidationError) ErrorName() string { return "HealthRequestValidationError" }

// Error satisfies the builtin error interface
func (e HealthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthRequestValidationError{}

// Validate checks the field values on HealthResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthResponseMultiError,
// or nil if none found.
func (m *HealthResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Available

	if len(errors) > 0 {
		return HealthResponseMultiError(errors)
	}

	return nil
}

// HealthResponseMultiError is an error wrapping multiple validation errors
// returned by HealthResponse.ValidateAll() if the designated constraints
// aren't met.
type HealthResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthResponseMultiError) AllErrors() []error { return m }

// HealthResponseValidationError is the validation error returned by
// HealthResponse.Validate if the designated constraints aren't met.
type HealthResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthResponseValidationError) ErrorName() string { return "HealthResponseValidationError" }

// Error satisfies the builtin error interface
func (e HealthResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthResponseValidationError{}

// Validate checks the field values on ListResourceSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListResourceSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResourceSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResourceSchemaRequestMultiError, or nil if none found.
func (m *ListResourceSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResourceSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	if len(errors) > 0 {
		return ListResourceSchemaRequestMultiError(errors)
	}

	return nil
}

// ListResourceSchemaRequestMultiError is an error wrapping multiple validation
// errors returned by ListResourceSchemaRequest.ValidateAll() if the
// designated constraints aren't met.
type ListResourceSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResourceSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResourceSchemaRequestMultiError) AllErrors() []error { return m }

// ListResourceSchemaRequestValidationError is the validation error returned by
// ListResourceSchemaRequest.Validate if the designated constraints aren't met.
type ListResourceSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResourceSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResourceSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResourceSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResourceSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResourceSchemaRequestValidationError) ErrorName() string {
	return "ListResourceSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListResourceSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResourceSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResourceSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResourceSchemaRequestValidationError{}

// Validate checks the field values on GetResourceSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetResourceSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResourceSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetResourceSchemaRequestMultiError, or nil if none found.
func (m *GetResourceSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResourceSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Name

	if len(errors) > 0 {
		return GetResourceSchemaRequestMultiError(errors)
	}

	return nil
}

// GetResourceSchemaRequestMultiError is an error wrapping multiple validation
// errors returned by GetResourceSchemaRequest.ValidateAll() if the designated
// constraints aren't met.
type GetResourceSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResourceSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResourceSchemaRequestMultiError) AllErrors() []error { return m }

// GetResourceSchemaRequestValidationError is the validation error returned by
// GetResourceSchemaRequest.Validate if the designated constraints aren't met.
type GetResourceSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResourceSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResourceSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResourceSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResourceSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResourceSchemaRequestValidationError) ErrorName() string {
	return "GetResourceSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetResourceSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResourceSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResourceSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResourceSchemaRequestValidationError{}

// Validate checks the field values on QueryPermByActionIDReqData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryPermByActionIDReqData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryPermByActionIDReqData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryPermByActionIDReqDataMultiError, or nil if none found.
func (m *QueryPermByActionIDReqData) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryPermByActionIDReqData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for ClusterId

	// no validation rules for Name

	// no validation rules for TemplateId

	// no validation rules for AccountId

	if utf8.RuneCountInString(m.GetOperator()) < 1 {
		err := QueryPermByActionIDReqDataValidationError{
			field:  "Operator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QueryPermByActionIDReqDataMultiError(errors)
	}

	return nil
}

// QueryPermByActionIDReqDataMultiError is an error wrapping multiple
// validation errors returned by QueryPermByActionIDReqData.ValidateAll() if
// the designated constraints aren't met.
type QueryPermByActionIDReqDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryPermByActionIDReqDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryPermByActionIDReqDataMultiError) AllErrors() []error { return m }

// QueryPermByActionIDReqDataValidationError is the validation error returned
// by QueryPermByActionIDReqData.Validate if the designated constraints aren't met.
type QueryPermByActionIDReqDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryPermByActionIDReqDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryPermByActionIDReqDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryPermByActionIDReqDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryPermByActionIDReqDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryPermByActionIDReqDataValidationError) ErrorName() string {
	return "QueryPermByActionIDReqDataValidationError"
}

// Error satisfies the builtin error interface
func (e QueryPermByActionIDReqDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryPermByActionIDReqData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryPermByActionIDReqDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryPermByActionIDReqDataValidationError{}

// Validate checks the field values on QueryPermByActionIDRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryPermByActionIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryPermByActionIDRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryPermByActionIDRequestMultiError, or nil if none found.
func (m *QueryPermByActionIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryPermByActionIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActionID

	if all {
		switch v := interface{}(m.GetPermCtx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryPermByActionIDRequestValidationError{
					field:  "PermCtx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryPermByActionIDRequestValidationError{
					field:  "PermCtx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPermCtx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryPermByActionIDRequestValidationError{
				field:  "PermCtx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryPermByActionIDRequestMultiError(errors)
	}

	return nil
}

// QueryPermByActionIDRequestMultiError is an error wrapping multiple
// validation errors returned by QueryPermByActionIDRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryPermByActionIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryPermByActionIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryPermByActionIDRequestMultiError) AllErrors() []error { return m }

// QueryPermByActionIDRequestValidationError is the validation error returned
// by QueryPermByActionIDRequest.Validate if the designated constraints aren't met.
type QueryPermByActionIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryPermByActionIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryPermByActionIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryPermByActionIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryPermByActionIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryPermByActionIDRequestValidationError) ErrorName() string {
	return "QueryPermByActionIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryPermByActionIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryPermByActionIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryPermByActionIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryPermByActionIDRequestValidationError{}

// Validate checks the field values on Perms with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Perms) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Perms with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PermsMultiError, or nil if none found.
func (m *Perms) ValidateAll() error {
	return m.validate(true)
}

func (m *Perms) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetPerms()))
		i := 0
		for key := range m.GetPerms() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPerms()[key]
			_ = val

			// no validation rules for Perms[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PermsValidationError{
							field:  fmt.Sprintf("Perms[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PermsValidationError{
							field:  fmt.Sprintf("Perms[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PermsValidationError{
						field:  fmt.Sprintf("Perms[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return PermsMultiError(errors)
	}

	return nil
}

// PermsMultiError is an error wrapping multiple validation errors returned by
// Perms.ValidateAll() if the designated constraints aren't met.
type PermsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermsMultiError) AllErrors() []error { return m }

// PermsValidationError is the validation error returned by Perms.Validate if
// the designated constraints aren't met.
type PermsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermsValidationError) ErrorName() string { return "PermsValidationError" }

// Error satisfies the builtin error interface
func (e PermsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPerms.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermsValidationError{}

// Validate checks the field values on QueryPermByActionIDResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryPermByActionIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryPermByActionIDResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryPermByActionIDResponseMultiError, or nil if none found.
func (m *QueryPermByActionIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryPermByActionIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryPermByActionIDResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryPermByActionIDResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryPermByActionIDResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryPermByActionIDResponseMultiError(errors)
	}

	return nil
}

// QueryPermByActionIDResponseMultiError is an error wrapping multiple
// validation errors returned by QueryPermByActionIDResponse.ValidateAll() if
// the designated constraints aren't met.
type QueryPermByActionIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryPermByActionIDResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryPermByActionIDResponseMultiError) AllErrors() []error { return m }

// QueryPermByActionIDResponseValidationError is the validation error returned
// by QueryPermByActionIDResponse.Validate if the designated constraints
// aren't met.
type QueryPermByActionIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryPermByActionIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryPermByActionIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryPermByActionIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryPermByActionIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryPermByActionIDResponseValidationError) ErrorName() string {
	return "QueryPermByActionIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryPermByActionIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryPermByActionIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryPermByActionIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryPermByActionIDResponseValidationError{}

// Validate checks the field values on CommonResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonRespMultiError, or
// nil if none found.
func (m *CommonResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommonRespMultiError(errors)
	}

	return nil
}

// CommonRespMultiError is an error wrapping multiple validation errors
// returned by CommonResp.ValidateAll() if the designated constraints aren't met.
type CommonRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonRespMultiError) AllErrors() []error { return m }

// CommonRespValidationError is the validation error returned by
// CommonResp.Validate if the designated constraints aren't met.
type CommonRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonRespValidationError) ErrorName() string { return "CommonRespValidationError" }

// Error satisfies the builtin error interface
func (e CommonRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonRespValidationError{}

// Validate checks the field values on CommonListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonListRespMultiError,
// or nil if none found.
func (m *CommonListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommonListRespMultiError(errors)
	}

	return nil
}

// CommonListRespMultiError is an error wrapping multiple validation errors
// returned by CommonListResp.ValidateAll() if the designated constraints
// aren't met.
type CommonListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonListRespMultiError) AllErrors() []error { return m }

// CommonListRespValidationError is the validation error returned by
// CommonListResp.Validate if the designated constraints aren't met.
type CommonListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonListRespValidationError) ErrorName() string { return "CommonListRespValidationError" }

// Error satisfies the builtin error interface
func (e CommonListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonListRespValidationError{}

// Validate checks the field values on ListBKCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBKCloudRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBKCloudRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBKCloudRequestMultiError, or nil if none found.
func (m *ListBKCloudRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBKCloudRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListBKCloudRequestMultiError(errors)
	}

	return nil
}

// ListBKCloudRequestMultiError is an error wrapping multiple validation errors
// returned by ListBKCloudRequest.ValidateAll() if the designated constraints
// aren't met.
type ListBKCloudRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBKCloudRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBKCloudRequestMultiError) AllErrors() []error { return m }

// ListBKCloudRequestValidationError is the validation error returned by
// ListBKCloudRequest.Validate if the designated constraints aren't met.
type ListBKCloudRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBKCloudRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBKCloudRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBKCloudRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBKCloudRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBKCloudRequestValidationError) ErrorName() string {
	return "ListBKCloudRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBKCloudRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBKCloudRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBKCloudRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBKCloudRequestValidationError{}

// Validate checks the field values on ListCCTopologyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCCTopologyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCCTopologyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCCTopologyRequestMultiError, or nil if none found.
func (m *ListCCTopologyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCCTopologyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 100 {
		err := ListCCTopologyRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListCCTopologyRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := ListCCTopologyRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for BizID

	if all {
		switch v := interface{}(m.GetFilterInter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCCTopologyRequestValidationError{
					field:  "FilterInter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCCTopologyRequestValidationError{
					field:  "FilterInter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilterInter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCCTopologyRequestValidationError{
				field:  "FilterInter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCCTopologyRequestMultiError(errors)
	}

	return nil
}

// ListCCTopologyRequestMultiError is an error wrapping multiple validation
// errors returned by ListCCTopologyRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCCTopologyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCCTopologyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCCTopologyRequestMultiError) AllErrors() []error { return m }

// ListCCTopologyRequestValidationError is the validation error returned by
// ListCCTopologyRequest.Validate if the designated constraints aren't met.
type ListCCTopologyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCCTopologyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCCTopologyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCCTopologyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCCTopologyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCCTopologyRequestValidationError) ErrorName() string {
	return "ListCCTopologyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCCTopologyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCCTopologyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCCTopologyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCCTopologyRequestValidationError{}

var _ListCCTopologyRequest_ClusterID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetBkSopsTemplateListRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBkSopsTemplateListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBkSopsTemplateListRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBkSopsTemplateListRequestMultiError, or nil if none found.
func (m *GetBkSopsTemplateListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBkSopsTemplateListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BusinessID

	// no validation rules for Operator

	if _, ok := _GetBkSopsTemplateListRequest_TemplateSource_InLookup[m.GetTemplateSource()]; !ok {
		err := GetBkSopsTemplateListRequestValidationError{
			field:  "TemplateSource",
			reason: "value must be in list [business common ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _GetBkSopsTemplateListRequest_Scope_InLookup[m.GetScope()]; !ok {
		err := GetBkSopsTemplateListRequestValidationError{
			field:  "Scope",
			reason: "value must be in list [cmdb_biz project ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetBkSopsTemplateListRequestMultiError(errors)
	}

	return nil
}

// GetBkSopsTemplateListRequestMultiError is an error wrapping multiple
// validation errors returned by GetBkSopsTemplateListRequest.ValidateAll() if
// the designated constraints aren't met.
type GetBkSopsTemplateListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBkSopsTemplateListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBkSopsTemplateListRequestMultiError) AllErrors() []error { return m }

// GetBkSopsTemplateListRequestValidationError is the validation error returned
// by GetBkSopsTemplateListRequest.Validate if the designated constraints
// aren't met.
type GetBkSopsTemplateListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBkSopsTemplateListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBkSopsTemplateListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBkSopsTemplateListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBkSopsTemplateListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBkSopsTemplateListRequestValidationError) ErrorName() string {
	return "GetBkSopsTemplateListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBkSopsTemplateListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBkSopsTemplateListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBkSopsTemplateListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBkSopsTemplateListRequestValidationError{}

var _GetBkSopsTemplateListRequest_TemplateSource_InLookup = map[string]struct{}{
	"business": {},
	"common":   {},
	"":         {},
}

var _GetBkSopsTemplateListRequest_Scope_InLookup = map[string]struct{}{
	"cmdb_biz": {},
	"project":  {},
	"":         {},
}

// Validate checks the field values on GetBkSopsTemplateListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBkSopsTemplateListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBkSopsTemplateListResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetBkSopsTemplateListResponseMultiError, or nil if none found.
func (m *GetBkSopsTemplateListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBkSopsTemplateListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBkSopsTemplateListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBkSopsTemplateListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBkSopsTemplateListResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBkSopsTemplateListResponseMultiError(errors)
	}

	return nil
}

// GetBkSopsTemplateListResponseMultiError is an error wrapping multiple
// validation errors returned by GetBkSopsTemplateListResponse.ValidateAll()
// if the designated constraints aren't met.
type GetBkSopsTemplateListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBkSopsTemplateListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBkSopsTemplateListResponseMultiError) AllErrors() []error { return m }

// GetBkSopsTemplateListResponseValidationError is the validation error
// returned by GetBkSopsTemplateListResponse.Validate if the designated
// constraints aren't met.
type GetBkSopsTemplateListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBkSopsTemplateListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBkSopsTemplateListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBkSopsTemplateListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBkSopsTemplateListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBkSopsTemplateListResponseValidationError) ErrorName() string {
	return "GetBkSopsTemplateListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBkSopsTemplateListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBkSopsTemplateListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBkSopsTemplateListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBkSopsTemplateListResponseValidationError{}

// Validate checks the field values on TemplateInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TemplateInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TemplateInfoMultiError, or
// nil if none found.
func (m *TemplateInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TemplateName

	// no validation rules for TemplateID

	// no validation rules for BusinessID

	// no validation rules for BusinessName

	// no validation rules for Creator

	// no validation rules for Editor

	// no validation rules for ProjectID

	if len(errors) > 0 {
		return TemplateInfoMultiError(errors)
	}

	return nil
}

// TemplateInfoMultiError is an error wrapping multiple validation errors
// returned by TemplateInfo.ValidateAll() if the designated constraints aren't met.
type TemplateInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateInfoMultiError) AllErrors() []error { return m }

// TemplateInfoValidationError is the validation error returned by
// TemplateInfo.Validate if the designated constraints aren't met.
type TemplateInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateInfoValidationError) ErrorName() string { return "TemplateInfoValidationError" }

// Error satisfies the builtin error interface
func (e TemplateInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateInfoValidationError{}

// Validate checks the field values on GetBkSopsTemplateInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBkSopsTemplateInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBkSopsTemplateInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBkSopsTemplateInfoRequestMultiError, or nil if none found.
func (m *GetBkSopsTemplateInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBkSopsTemplateInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BusinessID

	// no validation rules for TemplateID

	// no validation rules for Operator

	if _, ok := _GetBkSopsTemplateInfoRequest_TemplateSource_InLookup[m.GetTemplateSource()]; !ok {
		err := GetBkSopsTemplateInfoRequestValidationError{
			field:  "TemplateSource",
			reason: "value must be in list [business common ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _GetBkSopsTemplateInfoRequest_Scope_InLookup[m.GetScope()]; !ok {
		err := GetBkSopsTemplateInfoRequestValidationError{
			field:  "Scope",
			reason: "value must be in list [cmdb_biz project ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetBkSopsTemplateInfoRequestMultiError(errors)
	}

	return nil
}

// GetBkSopsTemplateInfoRequestMultiError is an error wrapping multiple
// validation errors returned by GetBkSopsTemplateInfoRequest.ValidateAll() if
// the designated constraints aren't met.
type GetBkSopsTemplateInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBkSopsTemplateInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBkSopsTemplateInfoRequestMultiError) AllErrors() []error { return m }

// GetBkSopsTemplateInfoRequestValidationError is the validation error returned
// by GetBkSopsTemplateInfoRequest.Validate if the designated constraints
// aren't met.
type GetBkSopsTemplateInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBkSopsTemplateInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBkSopsTemplateInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBkSopsTemplateInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBkSopsTemplateInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBkSopsTemplateInfoRequestValidationError) ErrorName() string {
	return "GetBkSopsTemplateInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBkSopsTemplateInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBkSopsTemplateInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBkSopsTemplateInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBkSopsTemplateInfoRequestValidationError{}

var _GetBkSopsTemplateInfoRequest_TemplateSource_InLookup = map[string]struct{}{
	"business": {},
	"common":   {},
	"":         {},
}

var _GetBkSopsTemplateInfoRequest_Scope_InLookup = map[string]struct{}{
	"cmdb_biz": {},
	"project":  {},
	"":         {},
}

// Validate checks the field values on GetBkSopsTemplateInfoResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBkSopsTemplateInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBkSopsTemplateInfoResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetBkSopsTemplateInfoResponseMultiError, or nil if none found.
func (m *GetBkSopsTemplateInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBkSopsTemplateInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBkSopsTemplateInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBkSopsTemplateInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBkSopsTemplateInfoResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBkSopsTemplateInfoResponseMultiError(errors)
	}

	return nil
}

// GetBkSopsTemplateInfoResponseMultiError is an error wrapping multiple
// validation errors returned by GetBkSopsTemplateInfoResponse.ValidateAll()
// if the designated constraints aren't met.
type GetBkSopsTemplateInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBkSopsTemplateInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBkSopsTemplateInfoResponseMultiError) AllErrors() []error { return m }

// GetBkSopsTemplateInfoResponseValidationError is the validation error
// returned by GetBkSopsTemplateInfoResponse.Validate if the designated
// constraints aren't met.
type GetBkSopsTemplateInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBkSopsTemplateInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBkSopsTemplateInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBkSopsTemplateInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBkSopsTemplateInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBkSopsTemplateInfoResponseValidationError) ErrorName() string {
	return "GetBkSopsTemplateInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBkSopsTemplateInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBkSopsTemplateInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBkSopsTemplateInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBkSopsTemplateInfoResponseValidationError{}

// Validate checks the field values on TemplateDetailInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TemplateDetailInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateDetailInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateDetailInfoMultiError, or nil if none found.
func (m *TemplateDetailInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateDetailInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TemplateUrl

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateDetailInfoValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateDetailInfoValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateDetailInfoValidationError{
					field:  fmt.Sprintf("Values[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TemplateDetailInfoMultiError(errors)
	}

	return nil
}

// TemplateDetailInfoMultiError is an error wrapping multiple validation errors
// returned by TemplateDetailInfo.ValidateAll() if the designated constraints
// aren't met.
type TemplateDetailInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateDetailInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateDetailInfoMultiError) AllErrors() []error { return m }

// TemplateDetailInfoValidationError is the validation error returned by
// TemplateDetailInfo.Validate if the designated constraints aren't met.
type TemplateDetailInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateDetailInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateDetailInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateDetailInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateDetailInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateDetailInfoValidationError) ErrorName() string {
	return "TemplateDetailInfoValidationError"
}

// Error satisfies the builtin error interface
func (e TemplateDetailInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateDetailInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateDetailInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateDetailInfoValidationError{}

// Validate checks the field values on ConstantValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConstantValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConstantValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConstantValueMultiError, or
// nil if none found.
func (m *ConstantValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ConstantValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Name

	// no validation rules for Index

	// no validation rules for Desc

	if len(errors) > 0 {
		return ConstantValueMultiError(errors)
	}

	return nil
}

// ConstantValueMultiError is an error wrapping multiple validation errors
// returned by ConstantValue.ValidateAll() if the designated constraints
// aren't met.
type ConstantValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConstantValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConstantValueMultiError) AllErrors() []error { return m }

// ConstantValueValidationError is the validation error returned by
// ConstantValue.Validate if the designated constraints aren't met.
type ConstantValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConstantValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConstantValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConstantValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConstantValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConstantValueValidationError) ErrorName() string { return "ConstantValueValidationError" }

// Error satisfies the builtin error interface
func (e ConstantValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConstantValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConstantValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConstantValueValidationError{}

// Validate checks the field values on GetInnerTemplateValuesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInnerTemplateValuesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInnerTemplateValuesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetInnerTemplateValuesRequestMultiError, or nil if none found.
func (m *GetInnerTemplateValuesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInnerTemplateValuesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	// no validation rules for Operator

	if len(errors) > 0 {
		return GetInnerTemplateValuesRequestMultiError(errors)
	}

	return nil
}

// GetInnerTemplateValuesRequestMultiError is an error wrapping multiple
// validation errors returned by GetInnerTemplateValuesRequest.ValidateAll()
// if the designated constraints aren't met.
type GetInnerTemplateValuesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInnerTemplateValuesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInnerTemplateValuesRequestMultiError) AllErrors() []error { return m }

// GetInnerTemplateValuesRequestValidationError is the validation error
// returned by GetInnerTemplateValuesRequest.Validate if the designated
// constraints aren't met.
type GetInnerTemplateValuesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInnerTemplateValuesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInnerTemplateValuesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInnerTemplateValuesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInnerTemplateValuesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInnerTemplateValuesRequestValidationError) ErrorName() string {
	return "GetInnerTemplateValuesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInnerTemplateValuesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInnerTemplateValuesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInnerTemplateValuesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInnerTemplateValuesRequestValidationError{}

// Validate checks the field values on GetInnerTemplateValuesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInnerTemplateValuesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInnerTemplateValuesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetInnerTemplateValuesResponseMultiError, or nil if none found.
func (m *GetInnerTemplateValuesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInnerTemplateValuesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetInnerTemplateValuesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetInnerTemplateValuesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetInnerTemplateValuesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetInnerTemplateValuesResponseMultiError(errors)
	}

	return nil
}

// GetInnerTemplateValuesResponseMultiError is an error wrapping multiple
// validation errors returned by GetInnerTemplateValuesResponse.ValidateAll()
// if the designated constraints aren't met.
type GetInnerTemplateValuesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInnerTemplateValuesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInnerTemplateValuesResponseMultiError) AllErrors() []error { return m }

// GetInnerTemplateValuesResponseValidationError is the validation error
// returned by GetInnerTemplateValuesResponse.Validate if the designated
// constraints aren't met.
type GetInnerTemplateValuesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInnerTemplateValuesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInnerTemplateValuesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInnerTemplateValuesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInnerTemplateValuesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInnerTemplateValuesResponseValidationError) ErrorName() string {
	return "GetInnerTemplateValuesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInnerTemplateValuesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInnerTemplateValuesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInnerTemplateValuesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInnerTemplateValuesResponseValidationError{}

// Validate checks the field values on TemplateValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TemplateValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TemplateValueMultiError, or
// nil if none found.
func (m *TemplateValue) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Desc

	// no validation rules for Refer

	// no validation rules for Trans

	// no validation rules for Value

	if len(errors) > 0 {
		return TemplateValueMultiError(errors)
	}

	return nil
}

// TemplateValueMultiError is an error wrapping multiple validation errors
// returned by TemplateValue.ValidateAll() if the designated constraints
// aren't met.
type TemplateValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateValueMultiError) AllErrors() []error { return m }

// TemplateValueValidationError is the validation error returned by
// TemplateValue.Validate if the designated constraints aren't met.
type TemplateValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateValueValidationError) ErrorName() string { return "TemplateValueValidationError" }

// Error satisfies the builtin error interface
func (e TemplateValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateValueValidationError{}

// Validate checks the field values on DebugBkSopsTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DebugBkSopsTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebugBkSopsTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DebugBkSopsTaskRequestMultiError, or nil if none found.
func (m *DebugBkSopsTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DebugBkSopsTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBusinessID()) < 1 {
		err := DebugBkSopsTaskRequestValidationError{
			field:  "BusinessID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTemplateID()) < 1 {
		err := DebugBkSopsTaskRequestValidationError{
			field:  "TemplateID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOperator()) < 1 {
		err := DebugBkSopsTaskRequestValidationError{
			field:  "Operator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _DebugBkSopsTaskRequest_TemplateSource_InLookup[m.GetTemplateSource()]; !ok {
		err := DebugBkSopsTaskRequestValidationError{
			field:  "TemplateSource",
			reason: "value must be in list [business common ]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Constant

	if len(errors) > 0 {
		return DebugBkSopsTaskRequestMultiError(errors)
	}

	return nil
}

// DebugBkSopsTaskRequestMultiError is an error wrapping multiple validation
// errors returned by DebugBkSopsTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type DebugBkSopsTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebugBkSopsTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebugBkSopsTaskRequestMultiError) AllErrors() []error { return m }

// DebugBkSopsTaskRequestValidationError is the validation error returned by
// DebugBkSopsTaskRequest.Validate if the designated constraints aren't met.
type DebugBkSopsTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebugBkSopsTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebugBkSopsTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebugBkSopsTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebugBkSopsTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebugBkSopsTaskRequestValidationError) ErrorName() string {
	return "DebugBkSopsTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DebugBkSopsTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebugBkSopsTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebugBkSopsTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebugBkSopsTaskRequestValidationError{}

var _DebugBkSopsTaskRequest_TemplateSource_InLookup = map[string]struct{}{
	"business": {},
	"common":   {},
	"":         {},
}

// Validate checks the field values on DebugBkSopsTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DebugBkSopsTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebugBkSopsTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DebugBkSopsTaskResponseMultiError, or nil if none found.
func (m *DebugBkSopsTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DebugBkSopsTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugBkSopsTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugBkSopsTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugBkSopsTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebugBkSopsTaskResponseMultiError(errors)
	}

	return nil
}

// DebugBkSopsTaskResponseMultiError is an error wrapping multiple validation
// errors returned by DebugBkSopsTaskResponse.ValidateAll() if the designated
// constraints aren't met.
type DebugBkSopsTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebugBkSopsTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebugBkSopsTaskResponseMultiError) AllErrors() []error { return m }

// DebugBkSopsTaskResponseValidationError is the validation error returned by
// DebugBkSopsTaskResponse.Validate if the designated constraints aren't met.
type DebugBkSopsTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebugBkSopsTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebugBkSopsTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebugBkSopsTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebugBkSopsTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebugBkSopsTaskResponseValidationError) ErrorName() string {
	return "DebugBkSopsTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DebugBkSopsTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebugBkSopsTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebugBkSopsTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebugBkSopsTaskResponseValidationError{}

// Validate checks the field values on DebugBkSopsTaskInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DebugBkSopsTaskInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebugBkSopsTaskInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DebugBkSopsTaskInfoMultiError, or nil if none found.
func (m *DebugBkSopsTaskInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DebugBkSopsTaskInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugBkSopsTaskInfoValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugBkSopsTaskInfoValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugBkSopsTaskInfoValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebugBkSopsTaskInfoMultiError(errors)
	}

	return nil
}

// DebugBkSopsTaskInfoMultiError is an error wrapping multiple validation
// errors returned by DebugBkSopsTaskInfo.ValidateAll() if the designated
// constraints aren't met.
type DebugBkSopsTaskInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebugBkSopsTaskInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebugBkSopsTaskInfoMultiError) AllErrors() []error { return m }

// DebugBkSopsTaskInfoValidationError is the validation error returned by
// DebugBkSopsTaskInfo.Validate if the designated constraints aren't met.
type DebugBkSopsTaskInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebugBkSopsTaskInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebugBkSopsTaskInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebugBkSopsTaskInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebugBkSopsTaskInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebugBkSopsTaskInfoValidationError) ErrorName() string {
	return "DebugBkSopsTaskInfoValidationError"
}

// Error satisfies the builtin error interface
func (e DebugBkSopsTaskInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebugBkSopsTaskInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebugBkSopsTaskInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebugBkSopsTaskInfoValidationError{}

// Validate checks the field values on CloudModuleFlag with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloudModuleFlag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudModuleFlag with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudModuleFlagMultiError, or nil if none found.
func (m *CloudModuleFlag) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudModuleFlag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Version

	// no validation rules for ModuleID

	// no validation rules for FlagName

	// no validation rules for FlagDesc

	// no validation rules for DefaultValue

	// no validation rules for Enable

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreatTime

	// no validation rules for UpdateTime

	// no validation rules for FlagType

	if all {
		switch v := interface{}(m.GetRegex()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudModuleFlagValidationError{
					field:  "Regex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudModuleFlagValidationError{
					field:  "Regex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRegex()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudModuleFlagValidationError{
				field:  "Regex",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudModuleFlagValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudModuleFlagValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudModuleFlagValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NetworkType

	if len(errors) > 0 {
		return CloudModuleFlagMultiError(errors)
	}

	return nil
}

// CloudModuleFlagMultiError is an error wrapping multiple validation errors
// returned by CloudModuleFlag.ValidateAll() if the designated constraints
// aren't met.
type CloudModuleFlagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudModuleFlagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudModuleFlagMultiError) AllErrors() []error { return m }

// CloudModuleFlagValidationError is the validation error returned by
// CloudModuleFlag.Validate if the designated constraints aren't met.
type CloudModuleFlagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudModuleFlagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudModuleFlagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudModuleFlagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudModuleFlagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudModuleFlagValidationError) ErrorName() string { return "CloudModuleFlagValidationError" }

// Error satisfies the builtin error interface
func (e CloudModuleFlagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudModuleFlag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudModuleFlagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudModuleFlagValidationError{}

// Validate checks the field values on FlagInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlagInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlagInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlagInfoMultiError, or nil
// if none found.
func (m *FlagInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *FlagInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FlagName

	// no validation rules for FlagDesc

	// no validation rules for DefaultValue

	if all {
		switch v := interface{}(m.GetEnable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlagInfoValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlagInfoValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlagInfoValidationError{
				field:  "Enable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FlagType

	if all {
		switch v := interface{}(m.GetRegex()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlagInfoValidationError{
					field:  "Regex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlagInfoValidationError{
					field:  "Regex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRegex()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlagInfoValidationError{
				field:  "Regex",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlagInfoValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlagInfoValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlagInfoValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NetworkType

	if len(errors) > 0 {
		return FlagInfoMultiError(errors)
	}

	return nil
}

// FlagInfoMultiError is an error wrapping multiple validation errors returned
// by FlagInfo.ValidateAll() if the designated constraints aren't met.
type FlagInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlagInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlagInfoMultiError) AllErrors() []error { return m }

// FlagInfoValidationError is the validation error returned by
// FlagInfo.Validate if the designated constraints aren't met.
type FlagInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlagInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlagInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlagInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlagInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlagInfoValidationError) ErrorName() string { return "FlagInfoValidationError" }

// Error satisfies the builtin error interface
func (e FlagInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlagInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlagInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlagInfoValidationError{}

// Validate checks the field values on ValueRegex with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ValueRegex) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValueRegex with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ValueRegexMultiError, or
// nil if none found.
func (m *ValueRegex) ValidateAll() error {
	return m.validate(true)
}

func (m *ValueRegex) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Validator

	// no validation rules for Message

	if len(errors) > 0 {
		return ValueRegexMultiError(errors)
	}

	return nil
}

// ValueRegexMultiError is an error wrapping multiple validation errors
// returned by ValueRegex.ValidateAll() if the designated constraints aren't met.
type ValueRegexMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValueRegexMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValueRegexMultiError) AllErrors() []error { return m }

// ValueRegexValidationError is the validation error returned by
// ValueRegex.Validate if the designated constraints aren't met.
type ValueRegexValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValueRegexValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValueRegexValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValueRegexValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValueRegexValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValueRegexValidationError) ErrorName() string { return "ValueRegexValidationError" }

// Error satisfies the builtin error interface
func (e ValueRegexValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValueRegex.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValueRegexValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValueRegexValidationError{}

// Validate checks the field values on NumberRange with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NumberRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumberRange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NumberRangeMultiError, or
// nil if none found.
func (m *NumberRange) ValidateAll() error {
	return m.validate(true)
}

func (m *NumberRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return NumberRangeMultiError(errors)
	}

	return nil
}

// NumberRangeMultiError is an error wrapping multiple validation errors
// returned by NumberRange.ValidateAll() if the designated constraints aren't met.
type NumberRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumberRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumberRangeMultiError) AllErrors() []error { return m }

// NumberRangeValidationError is the validation error returned by
// NumberRange.Validate if the designated constraints aren't met.
type NumberRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumberRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumberRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumberRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumberRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumberRangeValidationError) ErrorName() string { return "NumberRangeValidationError" }

// Error satisfies the builtin error interface
func (e NumberRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumberRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumberRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumberRangeValidationError{}

// Validate checks the field values on CreateCloudModuleFlagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudModuleFlagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudModuleFlagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCloudModuleFlagRequestMultiError, or nil if none found.
func (m *CreateCloudModuleFlagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudModuleFlagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Version

	if utf8.RuneCountInString(m.GetModuleID()) < 1 {
		err := CreateCloudModuleFlagRequestValidationError{
			field:  "ModuleID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetFlagList()) < 1 {
		err := CreateCloudModuleFlagRequestValidationError{
			field:  "FlagList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetFlagList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateCloudModuleFlagRequestValidationError{
						field:  fmt.Sprintf("FlagList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateCloudModuleFlagRequestValidationError{
						field:  fmt.Sprintf("FlagList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateCloudModuleFlagRequestValidationError{
					field:  fmt.Sprintf("FlagList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return CreateCloudModuleFlagRequestMultiError(errors)
	}

	return nil
}

// CreateCloudModuleFlagRequestMultiError is an error wrapping multiple
// validation errors returned by CreateCloudModuleFlagRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateCloudModuleFlagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudModuleFlagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudModuleFlagRequestMultiError) AllErrors() []error { return m }

// CreateCloudModuleFlagRequestValidationError is the validation error returned
// by CreateCloudModuleFlagRequest.Validate if the designated constraints
// aren't met.
type CreateCloudModuleFlagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudModuleFlagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudModuleFlagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudModuleFlagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudModuleFlagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudModuleFlagRequestValidationError) ErrorName() string {
	return "CreateCloudModuleFlagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudModuleFlagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudModuleFlagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudModuleFlagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudModuleFlagRequestValidationError{}

// Validate checks the field values on CreateCloudModuleFlagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCloudModuleFlagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCloudModuleFlagResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateCloudModuleFlagResponseMultiError, or nil if none found.
func (m *CreateCloudModuleFlagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCloudModuleFlagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return CreateCloudModuleFlagResponseMultiError(errors)
	}

	return nil
}

// CreateCloudModuleFlagResponseMultiError is an error wrapping multiple
// validation errors returned by CreateCloudModuleFlagResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateCloudModuleFlagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCloudModuleFlagResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCloudModuleFlagResponseMultiError) AllErrors() []error { return m }

// CreateCloudModuleFlagResponseValidationError is the validation error
// returned by CreateCloudModuleFlagResponse.Validate if the designated
// constraints aren't met.
type CreateCloudModuleFlagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCloudModuleFlagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCloudModuleFlagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCloudModuleFlagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCloudModuleFlagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCloudModuleFlagResponseValidationError) ErrorName() string {
	return "CreateCloudModuleFlagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCloudModuleFlagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCloudModuleFlagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCloudModuleFlagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCloudModuleFlagResponseValidationError{}

// Validate checks the field values on UpdateCloudModuleFlagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudModuleFlagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudModuleFlagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCloudModuleFlagRequestMultiError, or nil if none found.
func (m *UpdateCloudModuleFlagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudModuleFlagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Version

	// no validation rules for ModuleID

	if len(m.GetFlagList()) < 1 {
		err := UpdateCloudModuleFlagRequestValidationError{
			field:  "FlagList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetFlagList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateCloudModuleFlagRequestValidationError{
						field:  fmt.Sprintf("FlagList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateCloudModuleFlagRequestValidationError{
						field:  fmt.Sprintf("FlagList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateCloudModuleFlagRequestValidationError{
					field:  fmt.Sprintf("FlagList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return UpdateCloudModuleFlagRequestMultiError(errors)
	}

	return nil
}

// UpdateCloudModuleFlagRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateCloudModuleFlagRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateCloudModuleFlagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudModuleFlagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudModuleFlagRequestMultiError) AllErrors() []error { return m }

// UpdateCloudModuleFlagRequestValidationError is the validation error returned
// by UpdateCloudModuleFlagRequest.Validate if the designated constraints
// aren't met.
type UpdateCloudModuleFlagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudModuleFlagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudModuleFlagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudModuleFlagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudModuleFlagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudModuleFlagRequestValidationError) ErrorName() string {
	return "UpdateCloudModuleFlagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudModuleFlagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudModuleFlagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudModuleFlagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudModuleFlagRequestValidationError{}

// Validate checks the field values on UpdateCloudModuleFlagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCloudModuleFlagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCloudModuleFlagResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateCloudModuleFlagResponseMultiError, or nil if none found.
func (m *UpdateCloudModuleFlagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCloudModuleFlagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return UpdateCloudModuleFlagResponseMultiError(errors)
	}

	return nil
}

// UpdateCloudModuleFlagResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateCloudModuleFlagResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateCloudModuleFlagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCloudModuleFlagResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCloudModuleFlagResponseMultiError) AllErrors() []error { return m }

// UpdateCloudModuleFlagResponseValidationError is the validation error
// returned by UpdateCloudModuleFlagResponse.Validate if the designated
// constraints aren't met.
type UpdateCloudModuleFlagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCloudModuleFlagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCloudModuleFlagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCloudModuleFlagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCloudModuleFlagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCloudModuleFlagResponseValidationError) ErrorName() string {
	return "UpdateCloudModuleFlagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCloudModuleFlagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCloudModuleFlagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCloudModuleFlagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCloudModuleFlagResponseValidationError{}

// Validate checks the field values on DeleteCloudModuleFlagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudModuleFlagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudModuleFlagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCloudModuleFlagRequestMultiError, or nil if none found.
func (m *DeleteCloudModuleFlagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudModuleFlagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Version

	// no validation rules for ModuleID

	// no validation rules for Operator

	if len(errors) > 0 {
		return DeleteCloudModuleFlagRequestMultiError(errors)
	}

	return nil
}

// DeleteCloudModuleFlagRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteCloudModuleFlagRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteCloudModuleFlagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudModuleFlagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudModuleFlagRequestMultiError) AllErrors() []error { return m }

// DeleteCloudModuleFlagRequestValidationError is the validation error returned
// by DeleteCloudModuleFlagRequest.Validate if the designated constraints
// aren't met.
type DeleteCloudModuleFlagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudModuleFlagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudModuleFlagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudModuleFlagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudModuleFlagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudModuleFlagRequestValidationError) ErrorName() string {
	return "DeleteCloudModuleFlagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudModuleFlagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudModuleFlagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudModuleFlagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudModuleFlagRequestValidationError{}

// Validate checks the field values on DeleteCloudModuleFlagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCloudModuleFlagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCloudModuleFlagResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteCloudModuleFlagResponseMultiError, or nil if none found.
func (m *DeleteCloudModuleFlagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCloudModuleFlagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return DeleteCloudModuleFlagResponseMultiError(errors)
	}

	return nil
}

// DeleteCloudModuleFlagResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteCloudModuleFlagResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteCloudModuleFlagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCloudModuleFlagResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCloudModuleFlagResponseMultiError) AllErrors() []error { return m }

// DeleteCloudModuleFlagResponseValidationError is the validation error
// returned by DeleteCloudModuleFlagResponse.Validate if the designated
// constraints aren't met.
type DeleteCloudModuleFlagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCloudModuleFlagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCloudModuleFlagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCloudModuleFlagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCloudModuleFlagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCloudModuleFlagResponseValidationError) ErrorName() string {
	return "DeleteCloudModuleFlagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCloudModuleFlagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCloudModuleFlagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCloudModuleFlagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCloudModuleFlagResponseValidationError{}

// Validate checks the field values on ListCloudModuleFlagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudModuleFlagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudModuleFlagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudModuleFlagRequestMultiError, or nil if none found.
func (m *ListCloudModuleFlagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudModuleFlagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudID

	// no validation rules for Version

	// no validation rules for ModuleID

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListCloudModuleFlagRequestMultiError(errors)
	}

	return nil
}

// ListCloudModuleFlagRequestMultiError is an error wrapping multiple
// validation errors returned by ListCloudModuleFlagRequest.ValidateAll() if
// the designated constraints aren't met.
type ListCloudModuleFlagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudModuleFlagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudModuleFlagRequestMultiError) AllErrors() []error { return m }

// ListCloudModuleFlagRequestValidationError is the validation error returned
// by ListCloudModuleFlagRequest.Validate if the designated constraints aren't met.
type ListCloudModuleFlagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudModuleFlagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudModuleFlagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudModuleFlagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudModuleFlagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudModuleFlagRequestValidationError) ErrorName() string {
	return "ListCloudModuleFlagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudModuleFlagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudModuleFlagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudModuleFlagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudModuleFlagRequestValidationError{}

// Validate checks the field values on ListCloudModuleFlagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCloudModuleFlagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCloudModuleFlagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCloudModuleFlagResponseMultiError, or nil if none found.
func (m *ListCloudModuleFlagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCloudModuleFlagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCloudModuleFlagResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCloudModuleFlagResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCloudModuleFlagResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCloudModuleFlagResponseMultiError(errors)
	}

	return nil
}

// ListCloudModuleFlagResponseMultiError is an error wrapping multiple
// validation errors returned by ListCloudModuleFlagResponse.ValidateAll() if
// the designated constraints aren't met.
type ListCloudModuleFlagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCloudModuleFlagResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCloudModuleFlagResponseMultiError) AllErrors() []error { return m }

// ListCloudModuleFlagResponseValidationError is the validation error returned
// by ListCloudModuleFlagResponse.Validate if the designated constraints
// aren't met.
type ListCloudModuleFlagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCloudModuleFlagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCloudModuleFlagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCloudModuleFlagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCloudModuleFlagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCloudModuleFlagResponseValidationError) ErrorName() string {
	return "ListCloudModuleFlagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCloudModuleFlagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCloudModuleFlagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCloudModuleFlagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCloudModuleFlagResponseValidationError{}

// Validate checks the field values on GetExternalNodeScriptRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExternalNodeScriptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExternalNodeScriptRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExternalNodeScriptRequestMultiError, or nil if none found.
func (m *GetExternalNodeScriptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExternalNodeScriptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeGroupID

	// no validation rules for Operator

	// no validation rules for Internal

	if len(errors) > 0 {
		return GetExternalNodeScriptRequestMultiError(errors)
	}

	return nil
}

// GetExternalNodeScriptRequestMultiError is an error wrapping multiple
// validation errors returned by GetExternalNodeScriptRequest.ValidateAll() if
// the designated constraints aren't met.
type GetExternalNodeScriptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExternalNodeScriptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExternalNodeScriptRequestMultiError) AllErrors() []error { return m }

// GetExternalNodeScriptRequestValidationError is the validation error returned
// by GetExternalNodeScriptRequest.Validate if the designated constraints
// aren't met.
type GetExternalNodeScriptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExternalNodeScriptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExternalNodeScriptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExternalNodeScriptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExternalNodeScriptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExternalNodeScriptRequestValidationError) ErrorName() string {
	return "GetExternalNodeScriptRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetExternalNodeScriptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExternalNodeScriptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExternalNodeScriptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExternalNodeScriptRequestValidationError{}

// Validate checks the field values on GetExternalNodeScriptResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExternalNodeScriptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExternalNodeScriptResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetExternalNodeScriptResponseMultiError, or nil if none found.
func (m *GetExternalNodeScriptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExternalNodeScriptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for Data

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetExternalNodeScriptResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetExternalNodeScriptResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetExternalNodeScriptResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetExternalNodeScriptResponseMultiError(errors)
	}

	return nil
}

// GetExternalNodeScriptResponseMultiError is an error wrapping multiple
// validation errors returned by GetExternalNodeScriptResponse.ValidateAll()
// if the designated constraints aren't met.
type GetExternalNodeScriptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExternalNodeScriptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExternalNodeScriptResponseMultiError) AllErrors() []error { return m }

// GetExternalNodeScriptResponseValidationError is the validation error
// returned by GetExternalNodeScriptResponse.Validate if the designated
// constraints aren't met.
type GetExternalNodeScriptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExternalNodeScriptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExternalNodeScriptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExternalNodeScriptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExternalNodeScriptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExternalNodeScriptResponseValidationError) ErrorName() string {
	return "GetExternalNodeScriptResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetExternalNodeScriptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExternalNodeScriptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExternalNodeScriptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExternalNodeScriptResponseValidationError{}

// Validate checks the field values on MapStruct with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MapStruct) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapStruct with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MapStructMultiError, or nil
// if none found.
func (m *MapStruct) ValidateAll() error {
	return m.validate(true)
}

func (m *MapStruct) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Values

	if len(errors) > 0 {
		return MapStructMultiError(errors)
	}

	return nil
}

// MapStructMultiError is an error wrapping multiple validation errors returned
// by MapStruct.ValidateAll() if the designated constraints aren't met.
type MapStructMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapStructMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapStructMultiError) AllErrors() []error { return m }

// MapStructValidationError is the validation error returned by
// MapStruct.Validate if the designated constraints aren't met.
type MapStructValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapStructValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapStructValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapStructValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapStructValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapStructValidationError) ErrorName() string { return "MapStructValidationError" }

// Error satisfies the builtin error interface
func (e MapStructValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapStruct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapStructValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapStructValidationError{}

// Validate checks the field values on GetBatchCustomSettingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBatchCustomSettingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBatchCustomSettingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBatchCustomSettingRequestMultiError, or nil if none found.
func (m *GetBatchCustomSettingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBatchCustomSettingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeType

	// no validation rules for ScopeId

	if len(errors) > 0 {
		return GetBatchCustomSettingRequestMultiError(errors)
	}

	return nil
}

// GetBatchCustomSettingRequestMultiError is an error wrapping multiple
// validation errors returned by GetBatchCustomSettingRequest.ValidateAll() if
// the designated constraints aren't met.
type GetBatchCustomSettingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBatchCustomSettingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBatchCustomSettingRequestMultiError) AllErrors() []error { return m }

// GetBatchCustomSettingRequestValidationError is the validation error returned
// by GetBatchCustomSettingRequest.Validate if the designated constraints
// aren't met.
type GetBatchCustomSettingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBatchCustomSettingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBatchCustomSettingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBatchCustomSettingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBatchCustomSettingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBatchCustomSettingRequestValidationError) ErrorName() string {
	return "GetBatchCustomSettingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBatchCustomSettingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBatchCustomSettingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBatchCustomSettingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBatchCustomSettingRequestValidationError{}

// Validate checks the field values on GetBatchCustomSettingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBatchCustomSettingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBatchCustomSettingResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetBatchCustomSettingResponseMultiError, or nil if none found.
func (m *GetBatchCustomSettingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBatchCustomSettingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Success

	// no validation rules for ErrorMsg

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBatchCustomSettingResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBatchCustomSettingResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBatchCustomSettingResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBatchCustomSettingResponseMultiError(errors)
	}

	return nil
}

// GetBatchCustomSettingResponseMultiError is an error wrapping multiple
// validation errors returned by GetBatchCustomSettingResponse.ValidateAll()
// if the designated constraints aren't met.
type GetBatchCustomSettingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBatchCustomSettingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBatchCustomSettingResponseMultiError) AllErrors() []error { return m }

// GetBatchCustomSettingResponseValidationError is the validation error
// returned by GetBatchCustomSettingResponse.Validate if the designated
// constraints aren't met.
type GetBatchCustomSettingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBatchCustomSettingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBatchCustomSettingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBatchCustomSettingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBatchCustomSettingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBatchCustomSettingResponseValidationError) ErrorName() string {
	return "GetBatchCustomSettingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBatchCustomSettingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBatchCustomSettingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBatchCustomSettingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBatchCustomSettingResponseValidationError{}

// Validate checks the field values on ScopeInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScopeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScopeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScopeInfoMultiError, or nil
// if none found.
func (m *ScopeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ScopeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeType

	// no validation rules for ScopeId

	if len(errors) > 0 {
		return ScopeInfoMultiError(errors)
	}

	return nil
}

// ScopeInfoMultiError is an error wrapping multiple validation errors returned
// by ScopeInfo.ValidateAll() if the designated constraints aren't met.
type ScopeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScopeInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScopeInfoMultiError) AllErrors() []error { return m }

// ScopeInfoValidationError is the validation error returned by
// ScopeInfo.Validate if the designated constraints aren't met.
type ScopeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScopeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScopeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScopeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScopeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScopeInfoValidationError) ErrorName() string { return "ScopeInfoValidationError" }

// Error satisfies the builtin error interface
func (e ScopeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScopeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScopeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScopeInfoValidationError{}

// Validate checks the field values on GetBizTopologyHostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBizTopologyHostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBizTopologyHostRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBizTopologyHostRequestMultiError, or nil if none found.
func (m *GetBizTopologyHostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBizTopologyHostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeType

	// no validation rules for ScopeId

	// no validation rules for AllScope

	for idx, item := range m.GetScopeList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBizTopologyHostRequestValidationError{
						field:  fmt.Sprintf("ScopeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBizTopologyHostRequestValidationError{
						field:  fmt.Sprintf("ScopeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBizTopologyHostRequestValidationError{
					field:  fmt.Sprintf("ScopeList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBizTopologyHostRequestMultiError(errors)
	}

	return nil
}

// GetBizTopologyHostRequestMultiError is an error wrapping multiple validation
// errors returned by GetBizTopologyHostRequest.ValidateAll() if the
// designated constraints aren't met.
type GetBizTopologyHostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBizTopologyHostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBizTopologyHostRequestMultiError) AllErrors() []error { return m }

// GetBizTopologyHostRequestValidationError is the validation error returned by
// GetBizTopologyHostRequest.Validate if the designated constraints aren't met.
type GetBizTopologyHostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBizTopologyHostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBizTopologyHostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBizTopologyHostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBizTopologyHostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBizTopologyHostRequestValidationError) ErrorName() string {
	return "GetBizTopologyHostRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBizTopologyHostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBizTopologyHostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBizTopologyHostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBizTopologyHostRequestValidationError{}

// Validate checks the field values on GetBizTopologyHostResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBizTopologyHostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBizTopologyHostResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBizTopologyHostResponseMultiError, or nil if none found.
func (m *GetBizTopologyHostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBizTopologyHostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Success

	// no validation rules for ErrorMsg

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBizTopologyHostResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBizTopologyHostResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBizTopologyHostResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBizTopologyHostResponseMultiError(errors)
	}

	return nil
}

// GetBizTopologyHostResponseMultiError is an error wrapping multiple
// validation errors returned by GetBizTopologyHostResponse.ValidateAll() if
// the designated constraints aren't met.
type GetBizTopologyHostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBizTopologyHostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBizTopologyHostResponseMultiError) AllErrors() []error { return m }

// GetBizTopologyHostResponseValidationError is the validation error returned
// by GetBizTopologyHostResponse.Validate if the designated constraints aren't met.
type GetBizTopologyHostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBizTopologyHostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBizTopologyHostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBizTopologyHostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBizTopologyHostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBizTopologyHostResponseValidationError) ErrorName() string {
	return "GetBizTopologyHostResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBizTopologyHostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBizTopologyHostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBizTopologyHostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBizTopologyHostResponseValidationError{}

// Validate checks the field values on NodeData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeDataMultiError, or nil
// if none found.
func (m *NodeData) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ObjectId

	// no validation rules for InstanceId

	if len(errors) > 0 {
		return NodeDataMultiError(errors)
	}

	return nil
}

// NodeDataMultiError is an error wrapping multiple validation errors returned
// by NodeData.ValidateAll() if the designated constraints aren't met.
type NodeDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeDataMultiError) AllErrors() []error { return m }

// NodeDataValidationError is the validation error returned by
// NodeData.Validate if the designated constraints aren't met.
type NodeDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeDataValidationError) ErrorName() string { return "NodeDataValidationError" }

// Error satisfies the builtin error interface
func (e NodeDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeDataValidationError{}

// Validate checks the field values on GetTopologyNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTopologyNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTopologyNodesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTopologyNodesRequestMultiError, or nil if none found.
func (m *GetTopologyNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTopologyNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeType

	// no validation rules for ScopeId

	if len(m.GetNodeList()) < 1 {
		err := GetTopologyNodesRequestValidationError{
			field:  "NodeList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNodeList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTopologyNodesRequestValidationError{
						field:  fmt.Sprintf("NodeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTopologyNodesRequestValidationError{
						field:  fmt.Sprintf("NodeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTopologyNodesRequestValidationError{
					field:  fmt.Sprintf("NodeList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SearchContent

	if all {
		switch v := interface{}(m.GetAlive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTopologyNodesRequestValidationError{
					field:  "Alive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTopologyNodesRequestValidationError{
					field:  "Alive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTopologyNodesRequestValidationError{
				field:  "Alive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Start

	// no validation rules for PageSize

	if len(errors) > 0 {
		return GetTopologyNodesRequestMultiError(errors)
	}

	return nil
}

// GetTopologyNodesRequestMultiError is an error wrapping multiple validation
// errors returned by GetTopologyNodesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTopologyNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTopologyNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTopologyNodesRequestMultiError) AllErrors() []error { return m }

// GetTopologyNodesRequestValidationError is the validation error returned by
// GetTopologyNodesRequest.Validate if the designated constraints aren't met.
type GetTopologyNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTopologyNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTopologyNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTopologyNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTopologyNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTopologyNodesRequestValidationError) ErrorName() string {
	return "GetTopologyNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTopologyNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTopologyNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTopologyNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTopologyNodesRequestValidationError{}

// Validate checks the field values on GetTopologyNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTopologyNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTopologyNodesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTopologyNodesResponseMultiError, or nil if none found.
func (m *GetTopologyNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTopologyNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Success

	// no validation rules for ErrorMsg

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTopologyNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTopologyNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTopologyNodesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTopologyNodesResponseMultiError(errors)
	}

	return nil
}

// GetTopologyNodesResponseMultiError is an error wrapping multiple validation
// errors returned by GetTopologyNodesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTopologyNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTopologyNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTopologyNodesResponseMultiError) AllErrors() []error { return m }

// GetTopologyNodesResponseValidationError is the validation error returned by
// GetTopologyNodesResponse.Validate if the designated constraints aren't met.
type GetTopologyNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTopologyNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTopologyNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTopologyNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTopologyNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTopologyNodesResponseValidationError) ErrorName() string {
	return "GetTopologyNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTopologyNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTopologyNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTopologyNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTopologyNodesResponseValidationError{}

// Validate checks the field values on GetTopologyNodesData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTopologyNodesData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTopologyNodesData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTopologyNodesDataMultiError, or nil if none found.
func (m *GetTopologyNodesData) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTopologyNodesData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for PageSize

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTopologyNodesDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTopologyNodesDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTopologyNodesDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTopologyNodesDataMultiError(errors)
	}

	return nil
}

// GetTopologyNodesDataMultiError is an error wrapping multiple validation
// errors returned by GetTopologyNodesData.ValidateAll() if the designated
// constraints aren't met.
type GetTopologyNodesDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTopologyNodesDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTopologyNodesDataMultiError) AllErrors() []error { return m }

// GetTopologyNodesDataValidationError is the validation error returned by
// GetTopologyNodesData.Validate if the designated constraints aren't met.
type GetTopologyNodesDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTopologyNodesDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTopologyNodesDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTopologyNodesDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTopologyNodesDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTopologyNodesDataValidationError) ErrorName() string {
	return "GetTopologyNodesDataValidationError"
}

// Error satisfies the builtin error interface
func (e GetTopologyNodesDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTopologyNodesData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTopologyNodesDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTopologyNodesDataValidationError{}

// Validate checks the field values on HostData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HostData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HostDataMultiError, or nil
// if none found.
func (m *HostData) ValidateAll() error {
	return m.validate(true)
}

func (m *HostData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostId

	// no validation rules for Ip

	// no validation rules for Ipv6

	// no validation rules for HostName

	// no validation rules for Alive

	// no validation rules for OsName

	if all {
		switch v := interface{}(m.GetCloudArea()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HostDataValidationError{
					field:  "CloudArea",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HostDataValidationError{
					field:  "CloudArea",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudArea()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HostDataValidationError{
				field:  "CloudArea",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HostDataMultiError(errors)
	}

	return nil
}

// HostDataMultiError is an error wrapping multiple validation errors returned
// by HostData.ValidateAll() if the designated constraints aren't met.
type HostDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostDataMultiError) AllErrors() []error { return m }

// HostDataValidationError is the validation error returned by
// HostData.Validate if the designated constraints aren't met.
type HostDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostDataValidationError) ErrorName() string { return "HostDataValidationError" }

// Error satisfies the builtin error interface
func (e HostDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostDataValidationError{}

// Validate checks the field values on HostCloudArea with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HostCloudArea) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostCloudArea with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HostCloudAreaMultiError, or
// nil if none found.
func (m *HostCloudArea) ValidateAll() error {
	return m.validate(true)
}

func (m *HostCloudArea) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return HostCloudAreaMultiError(errors)
	}

	return nil
}

// HostCloudAreaMultiError is an error wrapping multiple validation errors
// returned by HostCloudArea.ValidateAll() if the designated constraints
// aren't met.
type HostCloudAreaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostCloudAreaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostCloudAreaMultiError) AllErrors() []error { return m }

// HostCloudAreaValidationError is the validation error returned by
// HostCloudArea.Validate if the designated constraints aren't met.
type HostCloudAreaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostCloudAreaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostCloudAreaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostCloudAreaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostCloudAreaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostCloudAreaValidationError) ErrorName() string { return "HostCloudAreaValidationError" }

// Error satisfies the builtin error interface
func (e HostCloudAreaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostCloudArea.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostCloudAreaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostCloudAreaValidationError{}

// Validate checks the field values on GetTopologyHostIdsNodesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTopologyHostIdsNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTopologyHostIdsNodesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTopologyHostIdsNodesRequestMultiError, or nil if none found.
func (m *GetTopologyHostIdsNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTopologyHostIdsNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeType

	// no validation rules for ScopeId

	if len(m.GetNodeList()) < 1 {
		err := GetTopologyHostIdsNodesRequestValidationError{
			field:  "NodeList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNodeList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTopologyHostIdsNodesRequestValidationError{
						field:  fmt.Sprintf("NodeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTopologyHostIdsNodesRequestValidationError{
						field:  fmt.Sprintf("NodeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTopologyHostIdsNodesRequestValidationError{
					field:  fmt.Sprintf("NodeList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SearchContent

	if all {
		switch v := interface{}(m.GetAlive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTopologyHostIdsNodesRequestValidationError{
					field:  "Alive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTopologyHostIdsNodesRequestValidationError{
					field:  "Alive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTopologyHostIdsNodesRequestValidationError{
				field:  "Alive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Start

	// no validation rules for PageSize

	if len(errors) > 0 {
		return GetTopologyHostIdsNodesRequestMultiError(errors)
	}

	return nil
}

// GetTopologyHostIdsNodesRequestMultiError is an error wrapping multiple
// validation errors returned by GetTopologyHostIdsNodesRequest.ValidateAll()
// if the designated constraints aren't met.
type GetTopologyHostIdsNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTopologyHostIdsNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTopologyHostIdsNodesRequestMultiError) AllErrors() []error { return m }

// GetTopologyHostIdsNodesRequestValidationError is the validation error
// returned by GetTopologyHostIdsNodesRequest.Validate if the designated
// constraints aren't met.
type GetTopologyHostIdsNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTopologyHostIdsNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTopologyHostIdsNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTopologyHostIdsNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTopologyHostIdsNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTopologyHostIdsNodesRequestValidationError) ErrorName() string {
	return "GetTopologyHostIdsNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTopologyHostIdsNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTopologyHostIdsNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTopologyHostIdsNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTopologyHostIdsNodesRequestValidationError{}

// Validate checks the field values on GetTopologyHostIdsNodesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTopologyHostIdsNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTopologyHostIdsNodesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTopologyHostIdsNodesResponseMultiError, or nil if none found.
func (m *GetTopologyHostIdsNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTopologyHostIdsNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Success

	// no validation rules for ErrorMsg

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTopologyHostIdsNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTopologyHostIdsNodesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTopologyHostIdsNodesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTopologyHostIdsNodesResponseMultiError(errors)
	}

	return nil
}

// GetTopologyHostIdsNodesResponseMultiError is an error wrapping multiple
// validation errors returned by GetTopologyHostIdsNodesResponse.ValidateAll()
// if the designated constraints aren't met.
type GetTopologyHostIdsNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTopologyHostIdsNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTopologyHostIdsNodesResponseMultiError) AllErrors() []error { return m }

// GetTopologyHostIdsNodesResponseValidationError is the validation error
// returned by GetTopologyHostIdsNodesResponse.Validate if the designated
// constraints aren't met.
type GetTopologyHostIdsNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTopologyHostIdsNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTopologyHostIdsNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTopologyHostIdsNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTopologyHostIdsNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTopologyHostIdsNodesResponseValidationError) ErrorName() string {
	return "GetTopologyHostIdsNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTopologyHostIdsNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTopologyHostIdsNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTopologyHostIdsNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTopologyHostIdsNodesResponseValidationError{}

// Validate checks the field values on GetTopologyHostIdsNodesData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTopologyHostIdsNodesData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTopologyHostIdsNodesData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTopologyHostIdsNodesDataMultiError, or nil if none found.
func (m *GetTopologyHostIdsNodesData) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTopologyHostIdsNodesData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for PageSize

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTopologyHostIdsNodesDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTopologyHostIdsNodesDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTopologyHostIdsNodesDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTopologyHostIdsNodesDataMultiError(errors)
	}

	return nil
}

// GetTopologyHostIdsNodesDataMultiError is an error wrapping multiple
// validation errors returned by GetTopologyHostIdsNodesData.ValidateAll() if
// the designated constraints aren't met.
type GetTopologyHostIdsNodesDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTopologyHostIdsNodesDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTopologyHostIdsNodesDataMultiError) AllErrors() []error { return m }

// GetTopologyHostIdsNodesDataValidationError is the validation error returned
// by GetTopologyHostIdsNodesData.Validate if the designated constraints
// aren't met.
type GetTopologyHostIdsNodesDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTopologyHostIdsNodesDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTopologyHostIdsNodesDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTopologyHostIdsNodesDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTopologyHostIdsNodesDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTopologyHostIdsNodesDataValidationError) ErrorName() string {
	return "GetTopologyHostIdsNodesDataValidationError"
}

// Error satisfies the builtin error interface
func (e GetTopologyHostIdsNodesDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTopologyHostIdsNodesData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTopologyHostIdsNodesDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTopologyHostIdsNodesDataValidationError{}

// Validate checks the field values on HostIDsNodeData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HostIDsNodeData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostIDsNodeData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostIDsNodeDataMultiError, or nil if none found.
func (m *HostIDsNodeData) ValidateAll() error {
	return m.validate(true)
}

func (m *HostIDsNodeData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostId

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HostIDsNodeDataValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HostIDsNodeDataValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HostIDsNodeDataValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HostIDsNodeDataMultiError(errors)
	}

	return nil
}

// HostIDsNodeDataMultiError is an error wrapping multiple validation errors
// returned by HostIDsNodeData.ValidateAll() if the designated constraints
// aren't met.
type HostIDsNodeDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostIDsNodeDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostIDsNodeDataMultiError) AllErrors() []error { return m }

// HostIDsNodeDataValidationError is the validation error returned by
// HostIDsNodeData.Validate if the designated constraints aren't met.
type HostIDsNodeDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostIDsNodeDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostIDsNodeDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostIDsNodeDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostIDsNodeDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostIDsNodeDataValidationError) ErrorName() string { return "HostIDsNodeDataValidationError" }

// Error satisfies the builtin error interface
func (e HostIDsNodeDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostIDsNodeData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostIDsNodeDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostIDsNodeDataValidationError{}

// Validate checks the field values on Meta with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Meta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Meta with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MetaMultiError, or nil if none found.
func (m *Meta) ValidateAll() error {
	return m.validate(true)
}

func (m *Meta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeType

	// no validation rules for ScopeId

	// no validation rules for BkBizId

	if len(errors) > 0 {
		return MetaMultiError(errors)
	}

	return nil
}

// MetaMultiError is an error wrapping multiple validation errors returned by
// Meta.ValidateAll() if the designated constraints aren't met.
type MetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetaMultiError) AllErrors() []error { return m }

// MetaValidationError is the validation error returned by Meta.Validate if the
// designated constraints aren't met.
type MetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetaValidationError) ErrorName() string { return "MetaValidationError" }

// Error satisfies the builtin error interface
func (e MetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetaValidationError{}

// Validate checks the field values on GetHostsDetailsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetHostsDetailsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHostsDetailsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHostsDetailsRequestMultiError, or nil if none found.
func (m *GetHostsDetailsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHostsDetailsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeType

	// no validation rules for ScopeId

	for idx, item := range m.GetHostList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetHostsDetailsRequestValidationError{
						field:  fmt.Sprintf("HostList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetHostsDetailsRequestValidationError{
						field:  fmt.Sprintf("HostList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetHostsDetailsRequestValidationError{
					field:  fmt.Sprintf("HostList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetHostsDetailsRequestMultiError(errors)
	}

	return nil
}

// GetHostsDetailsRequestMultiError is an error wrapping multiple validation
// errors returned by GetHostsDetailsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetHostsDetailsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHostsDetailsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHostsDetailsRequestMultiError) AllErrors() []error { return m }

// GetHostsDetailsRequestValidationError is the validation error returned by
// GetHostsDetailsRequest.Validate if the designated constraints aren't met.
type GetHostsDetailsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHostsDetailsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHostsDetailsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHostsDetailsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHostsDetailsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHostsDetailsRequestValidationError) ErrorName() string {
	return "GetHostsDetailsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetHostsDetailsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHostsDetailsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHostsDetailsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHostsDetailsRequestValidationError{}

// Validate checks the field values on GetHostsDetailsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetHostsDetailsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHostsDetailsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHostsDetailsResponseMultiError, or nil if none found.
func (m *GetHostsDetailsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHostsDetailsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Success

	// no validation rules for ErrorMsg

	// no validation rules for RequestId

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetHostsDetailsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetHostsDetailsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetHostsDetailsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetHostsDetailsResponseMultiError(errors)
	}

	return nil
}

// GetHostsDetailsResponseMultiError is an error wrapping multiple validation
// errors returned by GetHostsDetailsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetHostsDetailsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHostsDetailsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHostsDetailsResponseMultiError) AllErrors() []error { return m }

// GetHostsDetailsResponseValidationError is the validation error returned by
// GetHostsDetailsResponse.Validate if the designated constraints aren't met.
type GetHostsDetailsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHostsDetailsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHostsDetailsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHostsDetailsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHostsDetailsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHostsDetailsResponseValidationError) ErrorName() string {
	return "GetHostsDetailsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetHostsDetailsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHostsDetailsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHostsDetailsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHostsDetailsResponseValidationError{}

// Validate checks the field values on HostDataWithMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HostDataWithMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostDataWithMeta with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostDataWithMetaMultiError, or nil if none found.
func (m *HostDataWithMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *HostDataWithMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostId

	// no validation rules for Ip

	// no validation rules for Ipv6

	// no validation rules for HostName

	// no validation rules for Alive

	// no validation rules for OsName

	if all {
		switch v := interface{}(m.GetCloudArea()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HostDataWithMetaValidationError{
					field:  "CloudArea",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HostDataWithMetaValidationError{
					field:  "CloudArea",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCloudArea()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HostDataWithMetaValidationError{
				field:  "CloudArea",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HostDataWithMetaValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HostDataWithMetaValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HostDataWithMetaValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HostDataWithMetaMultiError(errors)
	}

	return nil
}

// HostDataWithMetaMultiError is an error wrapping multiple validation errors
// returned by HostDataWithMeta.ValidateAll() if the designated constraints
// aren't met.
type HostDataWithMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostDataWithMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostDataWithMetaMultiError) AllErrors() []error { return m }

// HostDataWithMetaValidationError is the validation error returned by
// HostDataWithMeta.Validate if the designated constraints aren't met.
type HostDataWithMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostDataWithMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostDataWithMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostDataWithMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostDataWithMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostDataWithMetaValidationError) ErrorName() string { return "HostDataWithMetaValidationError" }

// Error satisfies the builtin error interface
func (e HostDataWithMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostDataWithMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostDataWithMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostDataWithMetaValidationError{}

// Validate checks the field values on GetScopeHostCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetScopeHostCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetScopeHostCheckRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetScopeHostCheckRequestMultiError, or nil if none found.
func (m *GetScopeHostCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetScopeHostCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeType

	// no validation rules for ScopeId

	if len(errors) > 0 {
		return GetScopeHostCheckRequestMultiError(errors)
	}

	return nil
}

// GetScopeHostCheckRequestMultiError is an error wrapping multiple validation
// errors returned by GetScopeHostCheckRequest.ValidateAll() if the designated
// constraints aren't met.
type GetScopeHostCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetScopeHostCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetScopeHostCheckRequestMultiError) AllErrors() []error { return m }

// GetScopeHostCheckRequestValidationError is the validation error returned by
// GetScopeHostCheckRequest.Validate if the designated constraints aren't met.
type GetScopeHostCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetScopeHostCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetScopeHostCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetScopeHostCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetScopeHostCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetScopeHostCheckRequestValidationError) ErrorName() string {
	return "GetScopeHostCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetScopeHostCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetScopeHostCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetScopeHostCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetScopeHostCheckRequestValidationError{}

// Validate checks the field values on GetScopeHostCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetScopeHostCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetScopeHostCheckResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetScopeHostCheckResponseMultiError, or nil if none found.
func (m *GetScopeHostCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetScopeHostCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Success

	// no validation rules for ErrorMsg

	// no validation rules for RequestId

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetScopeHostCheckResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetScopeHostCheckResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetScopeHostCheckResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetScopeHostCheckResponseMultiError(errors)
	}

	return nil
}

// GetScopeHostCheckResponseMultiError is an error wrapping multiple validation
// errors returned by GetScopeHostCheckResponse.ValidateAll() if the
// designated constraints aren't met.
type GetScopeHostCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetScopeHostCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetScopeHostCheckResponseMultiError) AllErrors() []error { return m }

// GetScopeHostCheckResponseValidationError is the validation error returned by
// GetScopeHostCheckResponse.Validate if the designated constraints aren't met.
type GetScopeHostCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetScopeHostCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetScopeHostCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetScopeHostCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetScopeHostCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetScopeHostCheckResponseValidationError) ErrorName() string {
	return "GetScopeHostCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetScopeHostCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetScopeHostCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetScopeHostCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetScopeHostCheckResponseValidationError{}

// Validate checks the field values on NotifyConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotifyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotifyConfigMultiError, or
// nil if none found.
func (m *NotifyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Server

	// no validation rules for DataId

	// no validation rules for AccessToken

	if len(errors) > 0 {
		return NotifyConfigMultiError(errors)
	}

	return nil
}

// NotifyConfigMultiError is an error wrapping multiple validation errors
// returned by NotifyConfig.ValidateAll() if the designated constraints aren't met.
type NotifyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyConfigMultiError) AllErrors() []error { return m }

// NotifyConfigValidationError is the validation error returned by
// NotifyConfig.Validate if the designated constraints aren't met.
type NotifyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyConfigValidationError) ErrorName() string { return "NotifyConfigValidationError" }

// Error satisfies the builtin error interface
func (e NotifyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyConfigValidationError{}

// Validate checks the field values on NotifyData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotifyData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotifyDataMultiError, or
// nil if none found.
func (m *NotifyData) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enable

	// no validation rules for Title

	// no validation rules for Content

	if len(errors) > 0 {
		return NotifyDataMultiError(errors)
	}

	return nil
}

// NotifyDataMultiError is an error wrapping multiple validation errors
// returned by NotifyData.ValidateAll() if the designated constraints aren't met.
type NotifyDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyDataMultiError) AllErrors() []error { return m }

// NotifyDataValidationError is the validation error returned by
// NotifyData.Validate if the designated constraints aren't met.
type NotifyDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyDataValidationError) ErrorName() string { return "NotifyDataValidationError" }

// Error satisfies the builtin error interface
func (e NotifyDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyDataValidationError{}

// Validate checks the field values on NotifyTemplate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotifyTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotifyTemplateMultiError,
// or nil if none found.
func (m *NotifyTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NotifyTemplateID

	// no validation rules for Name

	// no validation rules for ProjectID

	// no validation rules for NotifyType

	// no validation rules for Desc

	// no validation rules for Enable

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyTemplateValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "CreateCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "CreateCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyTemplateValidationError{
				field:  "CreateCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "DeleteCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "DeleteCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyTemplateValidationError{
				field:  "DeleteCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "CreateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "CreateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyTemplateValidationError{
				field:  "CreateNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "DeleteNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "DeleteNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyTemplateValidationError{
				field:  "DeleteNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "UpdateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "UpdateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyTemplateValidationError{
				field:  "UpdateNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroupScaleOutNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "GroupScaleOutNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "GroupScaleOutNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroupScaleOutNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyTemplateValidationError{
				field:  "GroupScaleOutNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroupScaleInNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "GroupScaleInNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyTemplateValidationError{
					field:  "GroupScaleInNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroupScaleInNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyTemplateValidationError{
				field:  "GroupScaleInNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Receivers

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return NotifyTemplateMultiError(errors)
	}

	return nil
}

// NotifyTemplateMultiError is an error wrapping multiple validation errors
// returned by NotifyTemplate.ValidateAll() if the designated constraints
// aren't met.
type NotifyTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyTemplateMultiError) AllErrors() []error { return m }

// NotifyTemplateValidationError is the validation error returned by
// NotifyTemplate.Validate if the designated constraints aren't met.
type NotifyTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyTemplateValidationError) ErrorName() string { return "NotifyTemplateValidationError" }

// Error satisfies the builtin error interface
func (e NotifyTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyTemplateValidationError{}

// Validate checks the field values on CreateNotifyTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNotifyTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNotifyTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNotifyTemplateRequestMultiError, or nil if none found.
func (m *CreateNotifyTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNotifyTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 2048 {
		err := CreateNotifyTemplateRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 2048 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateNotifyTemplateRequest_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := CreateNotifyTemplateRequestValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CreateNotifyTemplateRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Desc

	if _, ok := _CreateNotifyTemplateRequest_NotifyType_InLookup[m.GetNotifyType()]; !ok {
		err := CreateNotifyTemplateRequestValidationError{
			field:  "NotifyType",
			reason: "value must be in list [bk_monitor_event bk_monitor_metrics]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetEnable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "Enable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "CreateCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "CreateCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "CreateCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "DeleteCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "DeleteCluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "DeleteCluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "CreateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "CreateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "CreateNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "DeleteNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "DeleteNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "DeleteNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateNodeGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "UpdateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "UpdateNodeGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateNodeGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "UpdateNodeGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroupScaleOutNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "GroupScaleOutNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "GroupScaleOutNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroupScaleOutNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "GroupScaleOutNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroupScaleInNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "GroupScaleInNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "GroupScaleInNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroupScaleInNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "GroupScaleInNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateRequestValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Receivers

	// no validation rules for Creator

	if len(errors) > 0 {
		return CreateNotifyTemplateRequestMultiError(errors)
	}

	return nil
}

// CreateNotifyTemplateRequestMultiError is an error wrapping multiple
// validation errors returned by CreateNotifyTemplateRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateNotifyTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNotifyTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNotifyTemplateRequestMultiError) AllErrors() []error { return m }

// CreateNotifyTemplateRequestValidationError is the validation error returned
// by CreateNotifyTemplateRequest.Validate if the designated constraints
// aren't met.
type CreateNotifyTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNotifyTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNotifyTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNotifyTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNotifyTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNotifyTemplateRequestValidationError) ErrorName() string {
	return "CreateNotifyTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNotifyTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNotifyTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNotifyTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNotifyTemplateRequestValidationError{}

var _CreateNotifyTemplateRequest_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

var _CreateNotifyTemplateRequest_NotifyType_InLookup = map[string]struct{}{
	"bk_monitor_event":   {},
	"bk_monitor_metrics": {},
}

// Validate checks the field values on CreateNotifyTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNotifyTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNotifyTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNotifyTemplateResponseMultiError, or nil if none found.
func (m *CreateNotifyTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNotifyTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotifyTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotifyTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotifyTemplateResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNotifyTemplateResponseMultiError(errors)
	}

	return nil
}

// CreateNotifyTemplateResponseMultiError is an error wrapping multiple
// validation errors returned by CreateNotifyTemplateResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateNotifyTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNotifyTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNotifyTemplateResponseMultiError) AllErrors() []error { return m }

// CreateNotifyTemplateResponseValidationError is the validation error returned
// by CreateNotifyTemplateResponse.Validate if the designated constraints
// aren't met.
type CreateNotifyTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNotifyTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNotifyTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNotifyTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNotifyTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNotifyTemplateResponseValidationError) ErrorName() string {
	return "CreateNotifyTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNotifyTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNotifyTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNotifyTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNotifyTemplateResponseValidationError{}

// Validate checks the field values on DeleteNotifyTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNotifyTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNotifyTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNotifyTemplateRequestMultiError, or nil if none found.
func (m *DeleteNotifyTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNotifyTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for NotifyTemplateID

	if len(errors) > 0 {
		return DeleteNotifyTemplateRequestMultiError(errors)
	}

	return nil
}

// DeleteNotifyTemplateRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteNotifyTemplateRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteNotifyTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNotifyTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNotifyTemplateRequestMultiError) AllErrors() []error { return m }

// DeleteNotifyTemplateRequestValidationError is the validation error returned
// by DeleteNotifyTemplateRequest.Validate if the designated constraints
// aren't met.
type DeleteNotifyTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNotifyTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNotifyTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNotifyTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNotifyTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNotifyTemplateRequestValidationError) ErrorName() string {
	return "DeleteNotifyTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNotifyTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNotifyTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNotifyTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNotifyTemplateRequestValidationError{}

// Validate checks the field values on DeleteNotifyTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNotifyTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNotifyTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNotifyTemplateResponseMultiError, or nil if none found.
func (m *DeleteNotifyTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNotifyTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNotifyTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNotifyTemplateResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNotifyTemplateResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNotifyTemplateResponseMultiError(errors)
	}

	return nil
}

// DeleteNotifyTemplateResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteNotifyTemplateResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteNotifyTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNotifyTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNotifyTemplateResponseMultiError) AllErrors() []error { return m }

// DeleteNotifyTemplateResponseValidationError is the validation error returned
// by DeleteNotifyTemplateResponse.Validate if the designated constraints
// aren't met.
type DeleteNotifyTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNotifyTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNotifyTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNotifyTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNotifyTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNotifyTemplateResponseValidationError) ErrorName() string {
	return "DeleteNotifyTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNotifyTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNotifyTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNotifyTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNotifyTemplateResponseValidationError{}

// Validate checks the field values on ListNotifyTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNotifyTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNotifyTemplateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNotifyTemplateRequestMultiError, or nil if none found.
func (m *ListNotifyTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNotifyTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for NotifyTemplateID

	if len(errors) > 0 {
		return ListNotifyTemplateRequestMultiError(errors)
	}

	return nil
}

// ListNotifyTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by ListNotifyTemplateRequest.ValidateAll() if the
// designated constraints aren't met.
type ListNotifyTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNotifyTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNotifyTemplateRequestMultiError) AllErrors() []error { return m }

// ListNotifyTemplateRequestValidationError is the validation error returned by
// ListNotifyTemplateRequest.Validate if the designated constraints aren't met.
type ListNotifyTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNotifyTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNotifyTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNotifyTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNotifyTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNotifyTemplateRequestValidationError) ErrorName() string {
	return "ListNotifyTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNotifyTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNotifyTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNotifyTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNotifyTemplateRequestValidationError{}

// Validate checks the field values on ListNotifyTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNotifyTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNotifyTemplateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNotifyTemplateResponseMultiError, or nil if none found.
func (m *ListNotifyTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNotifyTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNotifyTemplateResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNotifyTemplateResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNotifyTemplateResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNotifyTemplateResponseMultiError(errors)
	}

	return nil
}

// ListNotifyTemplateResponseMultiError is an error wrapping multiple
// validation errors returned by ListNotifyTemplateResponse.ValidateAll() if
// the designated constraints aren't met.
type ListNotifyTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNotifyTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNotifyTemplateResponseMultiError) AllErrors() []error { return m }

// ListNotifyTemplateResponseValidationError is the validation error returned
// by ListNotifyTemplateResponse.Validate if the designated constraints aren't met.
type ListNotifyTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNotifyTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNotifyTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNotifyTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNotifyTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNotifyTemplateResponseValidationError) ErrorName() string {
	return "ListNotifyTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNotifyTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNotifyTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNotifyTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNotifyTemplateResponseValidationError{}

// Validate checks the field values on GetProviderResourceUsageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProviderResourceUsageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProviderResourceUsageRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetProviderResourceUsageRequestMultiError, or nil if none found.
func (m *GetProviderResourceUsageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProviderResourceUsageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProviderID

	// no validation rules for Region

	// no validation rules for InstanceType

	if wrapper := m.GetRatio(); wrapper != nil {

		if val := wrapper.GetValue(); val < 0 || val > 100 {
			err := GetProviderResourceUsageRequestValidationError{
				field:  "Ratio",
				reason: "value must be inside range [0, 100]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetAvailable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProviderResourceUsageRequestValidationError{
					field:  "Available",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProviderResourceUsageRequestValidationError{
					field:  "Available",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvailable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProviderResourceUsageRequestValidationError{
				field:  "Available",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetProviderResourceUsageRequestMultiError(errors)
	}

	return nil
}

// GetProviderResourceUsageRequestMultiError is an error wrapping multiple
// validation errors returned by GetProviderResourceUsageRequest.ValidateAll()
// if the designated constraints aren't met.
type GetProviderResourceUsageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProviderResourceUsageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProviderResourceUsageRequestMultiError) AllErrors() []error { return m }

// GetProviderResourceUsageRequestValidationError is the validation error
// returned by GetProviderResourceUsageRequest.Validate if the designated
// constraints aren't met.
type GetProviderResourceUsageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProviderResourceUsageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProviderResourceUsageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProviderResourceUsageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProviderResourceUsageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProviderResourceUsageRequestValidationError) ErrorName() string {
	return "GetProviderResourceUsageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetProviderResourceUsageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProviderResourceUsageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProviderResourceUsageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProviderResourceUsageRequestValidationError{}

// Validate checks the field values on GetProviderResourceUsageResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetProviderResourceUsageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProviderResourceUsageResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetProviderResourceUsageResponseMultiError, or nil if none found.
func (m *GetProviderResourceUsageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProviderResourceUsageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProviderResourceUsageResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProviderResourceUsageResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProviderResourceUsageResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetProviderResourceUsageResponseMultiError(errors)
	}

	return nil
}

// GetProviderResourceUsageResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetProviderResourceUsageResponse.ValidateAll() if the designated
// constraints aren't met.
type GetProviderResourceUsageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProviderResourceUsageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProviderResourceUsageResponseMultiError) AllErrors() []error { return m }

// GetProviderResourceUsageResponseValidationError is the validation error
// returned by GetProviderResourceUsageResponse.Validate if the designated
// constraints aren't met.
type GetProviderResourceUsageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProviderResourceUsageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProviderResourceUsageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProviderResourceUsageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProviderResourceUsageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProviderResourceUsageResponseValidationError) ErrorName() string {
	return "GetProviderResourceUsageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetProviderResourceUsageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProviderResourceUsageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProviderResourceUsageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProviderResourceUsageResponseValidationError{}

// Validate checks the field values on BusinessInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BusinessInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BusinessInfoMultiError, or
// nil if none found.
func (m *BusinessInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for ProjectName

	// no validation rules for ProjectCode

	// no validation rules for ProjectUsers

	// no validation rules for BizId

	// no validation rules for BizName

	// no validation rules for BizUsers

	// no validation rules for ClusterId

	// no validation rules for ClusterName

	// no validation rules for ClusterRegion

	// no validation rules for ClusterUsers

	// no validation rules for GroupId

	// no validation rules for GroupName

	// no validation rules for InstanceType

	// no validation rules for Zones

	// no validation rules for ConsumerId

	// no validation rules for PoolId

	// no validation rules for GroupUsers

	// no validation rules for Url

	if len(errors) > 0 {
		return BusinessInfoMultiError(errors)
	}

	return nil
}

// BusinessInfoMultiError is an error wrapping multiple validation errors
// returned by BusinessInfo.ValidateAll() if the designated constraints aren't met.
type BusinessInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessInfoMultiError) AllErrors() []error { return m }

// BusinessInfoValidationError is the validation error returned by
// BusinessInfo.Validate if the designated constraints aren't met.
type BusinessInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessInfoValidationError) ErrorName() string { return "BusinessInfoValidationError" }

// Error satisfies the builtin error interface
func (e BusinessInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessInfoValidationError{}
