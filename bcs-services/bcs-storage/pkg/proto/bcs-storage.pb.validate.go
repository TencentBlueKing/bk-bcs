// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pkg/proto/bcs-storage.proto

package storage

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Alarm with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Alarm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Alarm with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AlarmMultiError, or nil if none found.
func (m *Alarm) ValidateAll() error {
	return m.validate(true)
}

func (m *Alarm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := AlarmValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := AlarmValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Alarm_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := AlarmValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for Message

	// no validation rules for Source

	// no validation rules for Module

	// no validation rules for Type

	// no validation rules for ReceivedTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlarmValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlarmValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlarmValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AlarmMultiError(errors)
	}

	return nil
}

// AlarmMultiError is an error wrapping multiple validation errors returned by
// Alarm.ValidateAll() if the designated constraints aren't met.
type AlarmMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlarmMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlarmMultiError) AllErrors() []error { return m }

// AlarmValidationError is the validation error returned by Alarm.Validate if
// the designated constraints aren't met.
type AlarmValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlarmValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlarmValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlarmValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlarmValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlarmValidationError) ErrorName() string { return "AlarmValidationError" }

// Error satisfies the builtin error interface
func (e AlarmValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlarm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlarmValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlarmValidationError{}

var _Alarm_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PostAlarmRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PostAlarmRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostAlarmRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostAlarmRequestMultiError, or nil if none found.
func (m *PostAlarmRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PostAlarmRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PostAlarmRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PostAlarmRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PostAlarmRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PostAlarmRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := PostAlarmRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for Source

	// no validation rules for Module

	// no validation rules for Type

	// no validation rules for ReceivedTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostAlarmRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostAlarmRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostAlarmRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PostAlarmRequestMultiError(errors)
	}

	return nil
}

// PostAlarmRequestMultiError is an error wrapping multiple validation errors
// returned by PostAlarmRequest.ValidateAll() if the designated constraints
// aren't met.
type PostAlarmRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostAlarmRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostAlarmRequestMultiError) AllErrors() []error { return m }

// PostAlarmRequestValidationError is the validation error returned by
// PostAlarmRequest.Validate if the designated constraints aren't met.
type PostAlarmRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostAlarmRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostAlarmRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostAlarmRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostAlarmRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostAlarmRequestValidationError) ErrorName() string { return "PostAlarmRequestValidationError" }

// Error satisfies the builtin error interface
func (e PostAlarmRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostAlarmRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostAlarmRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostAlarmRequestValidationError{}

var _PostAlarmRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PostAlarmResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PostAlarmResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostAlarmResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostAlarmResponseMultiError, or nil if none found.
func (m *PostAlarmResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PostAlarmResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostAlarmResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostAlarmResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostAlarmResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PostAlarmResponseMultiError(errors)
	}

	return nil
}

// PostAlarmResponseMultiError is an error wrapping multiple validation errors
// returned by PostAlarmResponse.ValidateAll() if the designated constraints
// aren't met.
type PostAlarmResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostAlarmResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostAlarmResponseMultiError) AllErrors() []error { return m }

// PostAlarmResponseValidationError is the validation error returned by
// PostAlarmResponse.Validate if the designated constraints aren't met.
type PostAlarmResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostAlarmResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostAlarmResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostAlarmResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostAlarmResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostAlarmResponseValidationError) ErrorName() string {
	return "PostAlarmResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PostAlarmResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostAlarmResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostAlarmResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostAlarmResponseValidationError{}

// Validate checks the field values on ListAlarmRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListAlarmRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAlarmRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAlarmRequestMultiError, or nil if none found.
func (m *ListAlarmRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAlarmRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ListAlarmRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ListAlarmRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListAlarmRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ListAlarmRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := ListAlarmRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Source

	// no validation rules for Module

	// no validation rules for Type

	// no validation rules for TimeBegin

	// no validation rules for TimeEnd

	if m.GetOffset() < 0 {
		err := ListAlarmRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := ListAlarmRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAlarmRequestMultiError(errors)
	}

	return nil
}

// ListAlarmRequestMultiError is an error wrapping multiple validation errors
// returned by ListAlarmRequest.ValidateAll() if the designated constraints
// aren't met.
type ListAlarmRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAlarmRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAlarmRequestMultiError) AllErrors() []error { return m }

// ListAlarmRequestValidationError is the validation error returned by
// ListAlarmRequest.Validate if the designated constraints aren't met.
type ListAlarmRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAlarmRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAlarmRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAlarmRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAlarmRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAlarmRequestValidationError) ErrorName() string { return "ListAlarmRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListAlarmRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAlarmRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAlarmRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAlarmRequestValidationError{}

var _ListAlarmRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ListAlarmResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListAlarmResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAlarmResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAlarmResponseMultiError, or nil if none found.
func (m *ListAlarmResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAlarmResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAlarmResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAlarmResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAlarmResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAlarmResponseValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAlarmResponseValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAlarmResponseValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListAlarmResponseMultiError(errors)
	}

	return nil
}

// ListAlarmResponseMultiError is an error wrapping multiple validation errors
// returned by ListAlarmResponse.ValidateAll() if the designated constraints
// aren't met.
type ListAlarmResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAlarmResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAlarmResponseMultiError) AllErrors() []error { return m }

// ListAlarmResponseValidationError is the validation error returned by
// ListAlarmResponse.Validate if the designated constraints aren't met.
type ListAlarmResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAlarmResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAlarmResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAlarmResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAlarmResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAlarmResponseValidationError) ErrorName() string {
	return "ListAlarmResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAlarmResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAlarmResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAlarmResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAlarmResponseValidationError{}

// Validate checks the field values on ClusterConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterConfigMultiError, or
// nil if none found.
func (m *ClusterConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ClusterConfigValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ClusterConfigValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ClusterConfig_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ClusterConfigValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Service

	if len(errors) > 0 {
		return ClusterConfigMultiError(errors)
	}

	return nil
}

// ClusterConfigMultiError is an error wrapping multiple validation errors
// returned by ClusterConfig.ValidateAll() if the designated constraints
// aren't met.
type ClusterConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfigMultiError) AllErrors() []error { return m }

// ClusterConfigValidationError is the validation error returned by
// ClusterConfig.Validate if the designated constraints aren't met.
type ClusterConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfigValidationError) ErrorName() string { return "ClusterConfigValidationError" }

// Error satisfies the builtin error interface
func (e ClusterConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfigValidationError{}

var _ClusterConfig_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetClusterConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterConfigRequestMultiError, or nil if none found.
func (m *GetClusterConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := GetClusterConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := GetClusterConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetClusterConfigRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := GetClusterConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Service

	if len(errors) > 0 {
		return GetClusterConfigRequestMultiError(errors)
	}

	return nil
}

// GetClusterConfigRequestMultiError is an error wrapping multiple validation
// errors returned by GetClusterConfigRequest.ValidateAll() if the designated
// constraints aren't met.
type GetClusterConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterConfigRequestMultiError) AllErrors() []error { return m }

// GetClusterConfigRequestValidationError is the validation error returned by
// GetClusterConfigRequest.Validate if the designated constraints aren't met.
type GetClusterConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterConfigRequestValidationError) ErrorName() string {
	return "GetClusterConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterConfigRequestValidationError{}

var _GetClusterConfigRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ConfigSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigSet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigSetMultiError, or nil
// if none found.
func (m *ConfigSet) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigSetValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigSetValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigSetValidationError{
				field:  "Common",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConf()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigSetValidationError{
					field:  "Conf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigSetValidationError{
					field:  "Conf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConf()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigSetValidationError{
				field:  "Conf",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigSetMultiError(errors)
	}

	return nil
}

// ConfigSetMultiError is an error wrapping multiple validation errors returned
// by ConfigSet.ValidateAll() if the designated constraints aren't met.
type ConfigSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigSetMultiError) AllErrors() []error { return m }

// ConfigSetValidationError is the validation error returned by
// ConfigSet.Validate if the designated constraints aren't met.
type ConfigSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigSetValidationError) ErrorName() string { return "ConfigSetValidationError" }

// Error satisfies the builtin error interface
func (e ConfigSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigSetValidationError{}

// Validate checks the field values on ClusterSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterSet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterSetMultiError, or
// nil if none found.
func (m *ClusterSet) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ClusterSetValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ClusterSetValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ClusterSet_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ClusterSetValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClusterConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterSetValidationError{
					field:  "ClusterConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterSetValidationError{
					field:  "ClusterConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterSetValidationError{
				field:  "ClusterConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterSetMultiError(errors)
	}

	return nil
}

// ClusterSetMultiError is an error wrapping multiple validation errors
// returned by ClusterSet.ValidateAll() if the designated constraints aren't met.
type ClusterSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterSetMultiError) AllErrors() []error { return m }

// ClusterSetValidationError is the validation error returned by
// ClusterSet.Validate if the designated constraints aren't met.
type ClusterSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterSetValidationError) ErrorName() string { return "ClusterSetValidationError" }

// Error satisfies the builtin error interface
func (e ClusterSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterSetValidationError{}

var _ClusterSet_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeployConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeployConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeployConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeployConfigMultiError, or
// nil if none found.
func (m *DeployConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *DeployConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Service

	if all {
		switch v := interface{}(m.GetServiceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeployConfigValidationError{
					field:  "ServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeployConfigValidationError{
					field:  "ServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeployConfigValidationError{
				field:  "ServiceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetClusters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeployConfigValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeployConfigValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeployConfigValidationError{
					field:  fmt.Sprintf("Clusters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for StableVersion

	if len(errors) > 0 {
		return DeployConfigMultiError(errors)
	}

	return nil
}

// DeployConfigMultiError is an error wrapping multiple validation errors
// returned by DeployConfig.ValidateAll() if the designated constraints aren't met.
type DeployConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeployConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeployConfigMultiError) AllErrors() []error { return m }

// DeployConfigValidationError is the validation error returned by
// DeployConfig.Validate if the designated constraints aren't met.
type DeployConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeployConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeployConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeployConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeployConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeployConfigValidationError) ErrorName() string { return "DeployConfigValidationError" }

// Error satisfies the builtin error interface
func (e DeployConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeployConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeployConfigValidationError{}

// Validate checks the field values on GetClusterConfigResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterConfigResponseMultiError, or nil if none found.
func (m *GetClusterConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterConfigResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterConfigResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterConfigResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetClusterConfigResponseMultiError(errors)
	}

	return nil
}

// GetClusterConfigResponseMultiError is an error wrapping multiple validation
// errors returned by GetClusterConfigResponse.ValidateAll() if the designated
// constraints aren't met.
type GetClusterConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterConfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterConfigResponseMultiError) AllErrors() []error { return m }

// GetClusterConfigResponseValidationError is the validation error returned by
// GetClusterConfigResponse.Validate if the designated constraints aren't met.
type GetClusterConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterConfigResponseValidationError) ErrorName() string {
	return "GetClusterConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterConfigResponseValidationError{}

// Validate checks the field values on BcsStorageCluster with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BcsStorageCluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BcsStorageCluster with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BcsStorageClusterMultiError, or nil if none found.
func (m *BcsStorageCluster) ValidateAll() error {
	return m.validate(true)
}

func (m *BcsStorageCluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Service

	// no validation rules for City

	// no validation rules for JfrogUrl

	// no validation rules for NeedNat

	if len(errors) > 0 {
		return BcsStorageClusterMultiError(errors)
	}

	return nil
}

// BcsStorageClusterMultiError is an error wrapping multiple validation errors
// returned by BcsStorageCluster.ValidateAll() if the designated constraints
// aren't met.
type BcsStorageClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BcsStorageClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BcsStorageClusterMultiError) AllErrors() []error { return m }

// BcsStorageClusterValidationError is the validation error returned by
// BcsStorageCluster.Validate if the designated constraints aren't met.
type BcsStorageClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BcsStorageClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BcsStorageClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BcsStorageClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BcsStorageClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BcsStorageClusterValidationError) ErrorName() string {
	return "BcsStorageClusterValidationError"
}

// Error satisfies the builtin error interface
func (e BcsStorageClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBcsStorageCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BcsStorageClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BcsStorageClusterValidationError{}

// Validate checks the field values on PutClusterConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutClusterConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutClusterConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutClusterConfigRequestMultiError, or nil if none found.
func (m *PutClusterConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutClusterConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PutClusterConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PutClusterConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PutClusterConfigRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PutClusterConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := PutClusterConfigRequestValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for City

	// no validation rules for JfrogUrl

	// no validation rules for NeedNat

	if len(errors) > 0 {
		return PutClusterConfigRequestMultiError(errors)
	}

	return nil
}

// PutClusterConfigRequestMultiError is an error wrapping multiple validation
// errors returned by PutClusterConfigRequest.ValidateAll() if the designated
// constraints aren't met.
type PutClusterConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutClusterConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutClusterConfigRequestMultiError) AllErrors() []error { return m }

// PutClusterConfigRequestValidationError is the validation error returned by
// PutClusterConfigRequest.Validate if the designated constraints aren't met.
type PutClusterConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutClusterConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutClusterConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutClusterConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutClusterConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutClusterConfigRequestValidationError) ErrorName() string {
	return "PutClusterConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutClusterConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutClusterConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutClusterConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutClusterConfigRequestValidationError{}

var _PutClusterConfigRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PutClusterConfigResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutClusterConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutClusterConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutClusterConfigResponseMultiError, or nil if none found.
func (m *PutClusterConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutClusterConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutClusterConfigResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutClusterConfigResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutClusterConfigResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutClusterConfigResponseMultiError(errors)
	}

	return nil
}

// PutClusterConfigResponseMultiError is an error wrapping multiple validation
// errors returned by PutClusterConfigResponse.ValidateAll() if the designated
// constraints aren't met.
type PutClusterConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutClusterConfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutClusterConfigResponseMultiError) AllErrors() []error { return m }

// PutClusterConfigResponseValidationError is the validation error returned by
// PutClusterConfigResponse.Validate if the designated constraints aren't met.
type PutClusterConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutClusterConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutClusterConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutClusterConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutClusterConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutClusterConfigResponseValidationError) ErrorName() string {
	return "PutClusterConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutClusterConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutClusterConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutClusterConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutClusterConfigResponseValidationError{}

// Validate checks the field values on GetServiceConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceConfigRequestMultiError, or nil if none found.
func (m *GetServiceConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := GetServiceConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := GetServiceConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetServiceConfigRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := GetServiceConfigRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterIdNot

	// no validation rules for Service

	if len(errors) > 0 {
		return GetServiceConfigRequestMultiError(errors)
	}

	return nil
}

// GetServiceConfigRequestMultiError is an error wrapping multiple validation
// errors returned by GetServiceConfigRequest.ValidateAll() if the designated
// constraints aren't met.
type GetServiceConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceConfigRequestMultiError) AllErrors() []error { return m }

// GetServiceConfigRequestValidationError is the validation error returned by
// GetServiceConfigRequest.Validate if the designated constraints aren't met.
type GetServiceConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfigRequestValidationError) ErrorName() string {
	return "GetServiceConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfigRequestValidationError{}

var _GetServiceConfigRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetServiceConfigResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceConfigResponseMultiError, or nil if none found.
func (m *GetServiceConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfigResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfigResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceConfigResponseMultiError(errors)
	}

	return nil
}

// GetServiceConfigResponseMultiError is an error wrapping multiple validation
// errors returned by GetServiceConfigResponse.ValidateAll() if the designated
// constraints aren't met.
type GetServiceConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceConfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceConfigResponseMultiError) AllErrors() []error { return m }

// GetServiceConfigResponseValidationError is the validation error returned by
// GetServiceConfigResponse.Validate if the designated constraints aren't met.
type GetServiceConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfigResponseValidationError) ErrorName() string {
	return "GetServiceConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfigResponseValidationError{}

// Validate checks the field values on GetStableVersionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetStableVersionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStableVersionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStableVersionRequestMultiError, or nil if none found.
func (m *GetStableVersionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStableVersionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetStableVersionRequestValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetStableVersionRequestMultiError(errors)
	}

	return nil
}

// GetStableVersionRequestMultiError is an error wrapping multiple validation
// errors returned by GetStableVersionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetStableVersionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStableVersionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStableVersionRequestMultiError) AllErrors() []error { return m }

// GetStableVersionRequestValidationError is the validation error returned by
// GetStableVersionRequest.Validate if the designated constraints aren't met.
type GetStableVersionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStableVersionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStableVersionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStableVersionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStableVersionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStableVersionRequestValidationError) ErrorName() string {
	return "GetStableVersionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetStableVersionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStableVersionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStableVersionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStableVersionRequestValidationError{}

// Validate checks the field values on GetStableVersionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetStableVersionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStableVersionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStableVersionResponseMultiError, or nil if none found.
func (m *GetStableVersionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStableVersionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for Data

	if len(errors) > 0 {
		return GetStableVersionResponseMultiError(errors)
	}

	return nil
}

// GetStableVersionResponseMultiError is an error wrapping multiple validation
// errors returned by GetStableVersionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetStableVersionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStableVersionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStableVersionResponseMultiError) AllErrors() []error { return m }

// GetStableVersionResponseValidationError is the validation error returned by
// GetStableVersionResponse.Validate if the designated constraints aren't met.
type GetStableVersionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStableVersionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStableVersionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStableVersionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStableVersionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStableVersionResponseValidationError) ErrorName() string {
	return "GetStableVersionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetStableVersionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStableVersionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStableVersionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStableVersionResponseValidationError{}

// Validate checks the field values on PutStableVersionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutStableVersionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutStableVersionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutStableVersionRequestMultiError, or nil if none found.
func (m *PutStableVersionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutStableVersionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := PutStableVersionRequestValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVersion()) < 1 {
		err := PutStableVersionRequestValidationError{
			field:  "Version",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PutStableVersionRequestMultiError(errors)
	}

	return nil
}

// PutStableVersionRequestMultiError is an error wrapping multiple validation
// errors returned by PutStableVersionRequest.ValidateAll() if the designated
// constraints aren't met.
type PutStableVersionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutStableVersionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutStableVersionRequestMultiError) AllErrors() []error { return m }

// PutStableVersionRequestValidationError is the validation error returned by
// PutStableVersionRequest.Validate if the designated constraints aren't met.
type PutStableVersionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutStableVersionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutStableVersionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutStableVersionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutStableVersionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutStableVersionRequestValidationError) ErrorName() string {
	return "PutStableVersionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutStableVersionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutStableVersionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutStableVersionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutStableVersionRequestValidationError{}

// Validate checks the field values on PutStableVersionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutStableVersionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutStableVersionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutStableVersionResponseMultiError, or nil if none found.
func (m *PutStableVersionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutStableVersionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for Data

	if len(errors) > 0 {
		return PutStableVersionResponseMultiError(errors)
	}

	return nil
}

// PutStableVersionResponseMultiError is an error wrapping multiple validation
// errors returned by PutStableVersionResponse.ValidateAll() if the designated
// constraints aren't met.
type PutStableVersionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutStableVersionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutStableVersionResponseMultiError) AllErrors() []error { return m }

// PutStableVersionResponseValidationError is the validation error returned by
// PutStableVersionResponse.Validate if the designated constraints aren't met.
type PutStableVersionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutStableVersionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutStableVersionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutStableVersionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutStableVersionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutStableVersionResponseValidationError) ErrorName() string {
	return "PutStableVersionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutStableVersionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutStableVersionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutStableVersionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutStableVersionResponseValidationError{}

// Validate checks the field values on Resources with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resources with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourcesMultiError, or nil
// if none found.
func (m *Resources) ValidateAll() error {
	return m.validate(true)
}

func (m *Resources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ResourcesValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ResourcesValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Resources_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ResourcesValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceType

	// no validation rules for ResourceName

	if len(errors) > 0 {
		return ResourcesMultiError(errors)
	}

	return nil
}

// ResourcesMultiError is an error wrapping multiple validation errors returned
// by Resources.ValidateAll() if the designated constraints aren't met.
type ResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourcesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourcesMultiError) AllErrors() []error { return m }

// ResourcesValidationError is the validation error returned by
// Resources.Validate if the designated constraints aren't met.
type ResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourcesValidationError) ErrorName() string { return "ResourcesValidationError" }

// Error satisfies the builtin error interface
func (e ResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourcesValidationError{}

var _Resources_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetNamespaceResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNamespaceResourcesRequestMultiError, or nil if none found.
func (m *GetNamespaceResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := GetNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := GetNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetNamespaceResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := GetNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := GetNamespaceResourcesRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := GetNamespaceResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := GetNamespaceResourcesRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	// no validation rules for LabelSelector

	// no validation rules for UpdateTimeBefore

	if m.GetOffset() < 0 {
		err := GetNamespaceResourcesRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := GetNamespaceResourcesRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNamespaceResourcesRequestMultiError(errors)
	}

	return nil
}

// GetNamespaceResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by GetNamespaceResourcesRequest.ValidateAll() if
// the designated constraints aren't met.
type GetNamespaceResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceResourcesRequestMultiError) AllErrors() []error { return m }

// GetNamespaceResourcesRequestValidationError is the validation error returned
// by GetNamespaceResourcesRequest.Validate if the designated constraints
// aren't met.
type GetNamespaceResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceResourcesRequestValidationError) ErrorName() string {
	return "GetNamespaceResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNamespaceResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceResourcesRequestValidationError{}

var _GetNamespaceResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetNamespaceResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetNamespaceResourcesResponseMultiError, or nil if none found.
func (m *GetNamespaceResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetNamespaceResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetNamespaceResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetNamespaceResourcesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetNamespaceResourcesResponseMultiError(errors)
	}

	return nil
}

// GetNamespaceResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by GetNamespaceResourcesResponse.ValidateAll()
// if the designated constraints aren't met.
type GetNamespaceResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceResourcesResponseMultiError) AllErrors() []error { return m }

// GetNamespaceResourcesResponseValidationError is the validation error
// returned by GetNamespaceResourcesResponse.Validate if the designated
// constraints aren't met.
type GetNamespaceResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceResourcesResponseValidationError) ErrorName() string {
	return "GetNamespaceResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNamespaceResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceResourcesResponseValidationError{}

// Validate checks the field values on PutNamespaceResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutNamespaceResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutNamespaceResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutNamespaceResourcesRequestMultiError, or nil if none found.
func (m *PutNamespaceResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutNamespaceResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PutNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PutNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PutNamespaceResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PutNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := PutNamespaceResourcesRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := PutNamespaceResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := PutNamespaceResourcesRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutNamespaceResourcesRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutNamespaceResourcesRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutNamespaceResourcesRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutNamespaceResourcesRequestMultiError(errors)
	}

	return nil
}

// PutNamespaceResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by PutNamespaceResourcesRequest.ValidateAll() if
// the designated constraints aren't met.
type PutNamespaceResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutNamespaceResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutNamespaceResourcesRequestMultiError) AllErrors() []error { return m }

// PutNamespaceResourcesRequestValidationError is the validation error returned
// by PutNamespaceResourcesRequest.Validate if the designated constraints
// aren't met.
type PutNamespaceResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutNamespaceResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutNamespaceResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutNamespaceResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutNamespaceResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutNamespaceResourcesRequestValidationError) ErrorName() string {
	return "PutNamespaceResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutNamespaceResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutNamespaceResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutNamespaceResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutNamespaceResourcesRequestValidationError{}

var _PutNamespaceResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PutNamespaceResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutNamespaceResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutNamespaceResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PutNamespaceResourcesResponseMultiError, or nil if none found.
func (m *PutNamespaceResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutNamespaceResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutNamespaceResourcesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutNamespaceResourcesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutNamespaceResourcesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutNamespaceResourcesResponseMultiError(errors)
	}

	return nil
}

// PutNamespaceResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by PutNamespaceResourcesResponse.ValidateAll()
// if the designated constraints aren't met.
type PutNamespaceResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutNamespaceResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutNamespaceResourcesResponseMultiError) AllErrors() []error { return m }

// PutNamespaceResourcesResponseValidationError is the validation error
// returned by PutNamespaceResourcesResponse.Validate if the designated
// constraints aren't met.
type PutNamespaceResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutNamespaceResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutNamespaceResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutNamespaceResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutNamespaceResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutNamespaceResourcesResponseValidationError) ErrorName() string {
	return "PutNamespaceResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutNamespaceResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutNamespaceResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutNamespaceResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutNamespaceResourcesResponseValidationError{}

// Validate checks the field values on DeleteNamespaceResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNamespaceResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceResourcesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteNamespaceResourcesRequestMultiError, or nil if none found.
func (m *DeleteNamespaceResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DeleteNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DeleteNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteNamespaceResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DeleteNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := DeleteNamespaceResourcesRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := DeleteNamespaceResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := DeleteNamespaceResourcesRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteNamespaceResourcesRequestMultiError(errors)
	}

	return nil
}

// DeleteNamespaceResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteNamespaceResourcesRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteNamespaceResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceResourcesRequestMultiError) AllErrors() []error { return m }

// DeleteNamespaceResourcesRequestValidationError is the validation error
// returned by DeleteNamespaceResourcesRequest.Validate if the designated
// constraints aren't met.
type DeleteNamespaceResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceResourcesRequestValidationError) ErrorName() string {
	return "DeleteNamespaceResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceResourcesRequestValidationError{}

var _DeleteNamespaceResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteNamespaceResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteNamespaceResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteNamespaceResourcesResponseMultiError, or nil if none found.
func (m *DeleteNamespaceResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteNamespaceResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteNamespaceResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteNamespaceResourcesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteNamespaceResourcesResponseMultiError(errors)
	}

	return nil
}

// DeleteNamespaceResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteNamespaceResourcesResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNamespaceResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceResourcesResponseMultiError) AllErrors() []error { return m }

// DeleteNamespaceResourcesResponseValidationError is the validation error
// returned by DeleteNamespaceResourcesResponse.Validate if the designated
// constraints aren't met.
type DeleteNamespaceResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceResourcesResponseValidationError) ErrorName() string {
	return "DeleteNamespaceResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceResourcesResponseValidationError{}

// Validate checks the field values on ListNamespaceResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceResourcesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNamespaceResourcesRequestMultiError, or nil if none found.
func (m *ListNamespaceResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ListNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ListNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListNamespaceResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ListNamespaceResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := ListNamespaceResourcesRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := ListNamespaceResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	// no validation rules for LabelSelector

	// no validation rules for UpdateTimeBefore

	if m.GetOffset() < 0 {
		err := ListNamespaceResourcesRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := ListNamespaceResourcesRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListNamespaceResourcesRequestMultiError(errors)
	}

	return nil
}

// ListNamespaceResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by ListNamespaceResourcesRequest.ValidateAll()
// if the designated constraints aren't met.
type ListNamespaceResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceResourcesRequestMultiError) AllErrors() []error { return m }

// ListNamespaceResourcesRequestValidationError is the validation error
// returned by ListNamespaceResourcesRequest.Validate if the designated
// constraints aren't met.
type ListNamespaceResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceResourcesRequestValidationError) ErrorName() string {
	return "ListNamespaceResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceResourcesRequestValidationError{}

var _ListNamespaceResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ListNamespaceResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNamespaceResourcesResponseMultiError, or nil if none found.
func (m *ListNamespaceResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNamespaceResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNamespaceResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNamespaceResourcesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNamespaceResourcesResponseMultiError(errors)
	}

	return nil
}

// ListNamespaceResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by ListNamespaceResourcesResponse.ValidateAll()
// if the designated constraints aren't met.
type ListNamespaceResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceResourcesResponseMultiError) AllErrors() []error { return m }

// ListNamespaceResourcesResponseValidationError is the validation error
// returned by ListNamespaceResourcesResponse.Validate if the designated
// constraints aren't met.
type ListNamespaceResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceResourcesResponseValidationError) ErrorName() string {
	return "ListNamespaceResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceResourcesResponseValidationError{}

// Validate checks the field values on DeleteBatchNamespaceResourceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteBatchNamespaceResourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBatchNamespaceResourceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteBatchNamespaceResourceRequestMultiError, or nil if none found.
func (m *DeleteBatchNamespaceResourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBatchNamespaceResourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DeleteBatchNamespaceResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DeleteBatchNamespaceResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteBatchNamespaceResourceRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DeleteBatchNamespaceResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := DeleteBatchNamespaceResourceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := DeleteBatchNamespaceResourceRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for UpdateTimeBegin

	// no validation rules for UpdateTimeEnd

	if len(errors) > 0 {
		return DeleteBatchNamespaceResourceRequestMultiError(errors)
	}

	return nil
}

// DeleteBatchNamespaceResourceRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteBatchNamespaceResourceRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBatchNamespaceResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBatchNamespaceResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBatchNamespaceResourceRequestMultiError) AllErrors() []error { return m }

// DeleteBatchNamespaceResourceRequestValidationError is the validation error
// returned by DeleteBatchNamespaceResourceRequest.Validate if the designated
// constraints aren't met.
type DeleteBatchNamespaceResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBatchNamespaceResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBatchNamespaceResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBatchNamespaceResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBatchNamespaceResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBatchNamespaceResourceRequestValidationError) ErrorName() string {
	return "DeleteBatchNamespaceResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBatchNamespaceResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBatchNamespaceResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBatchNamespaceResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBatchNamespaceResourceRequestValidationError{}

var _DeleteBatchNamespaceResourceRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteBatchNamespaceResourceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DeleteBatchNamespaceResourceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBatchNamespaceResourceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteBatchNamespaceResourceResponseMultiError, or nil if none found.
func (m *DeleteBatchNamespaceResourceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBatchNamespaceResourceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteBatchNamespaceResourceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteBatchNamespaceResourceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteBatchNamespaceResourceResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteBatchNamespaceResourceResponseMultiError(errors)
	}

	return nil
}

// DeleteBatchNamespaceResourceResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteBatchNamespaceResourceResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteBatchNamespaceResourceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBatchNamespaceResourceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBatchNamespaceResourceResponseMultiError) AllErrors() []error { return m }

// DeleteBatchNamespaceResourceResponseValidationError is the validation error
// returned by DeleteBatchNamespaceResourceResponse.Validate if the designated
// constraints aren't met.
type DeleteBatchNamespaceResourceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBatchNamespaceResourceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBatchNamespaceResourceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBatchNamespaceResourceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBatchNamespaceResourceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBatchNamespaceResourceResponseValidationError) ErrorName() string {
	return "DeleteBatchNamespaceResourceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBatchNamespaceResourceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBatchNamespaceResourceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBatchNamespaceResourceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBatchNamespaceResourceResponseValidationError{}

// Validate checks the field values on GetClusterResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterResourcesRequestMultiError, or nil if none found.
func (m *GetClusterResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := GetClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := GetClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetClusterResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := GetClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := GetClusterResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := GetClusterResourcesRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	// no validation rules for LabelSelector

	// no validation rules for UpdateTimeBefore

	if m.GetOffset() < 0 {
		err := GetClusterResourcesRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := GetClusterResourcesRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetClusterResourcesRequestMultiError(errors)
	}

	return nil
}

// GetClusterResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by GetClusterResourcesRequest.ValidateAll() if
// the designated constraints aren't met.
type GetClusterResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterResourcesRequestMultiError) AllErrors() []error { return m }

// GetClusterResourcesRequestValidationError is the validation error returned
// by GetClusterResourcesRequest.Validate if the designated constraints aren't met.
type GetClusterResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterResourcesRequestValidationError) ErrorName() string {
	return "GetClusterResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterResourcesRequestValidationError{}

var _GetClusterResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetClusterResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterResourcesResponseMultiError, or nil if none found.
func (m *GetClusterResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClusterResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClusterResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClusterResourcesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetClusterResourcesResponseMultiError(errors)
	}

	return nil
}

// GetClusterResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by GetClusterResourcesResponse.ValidateAll() if
// the designated constraints aren't met.
type GetClusterResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterResourcesResponseMultiError) AllErrors() []error { return m }

// GetClusterResourcesResponseValidationError is the validation error returned
// by GetClusterResourcesResponse.Validate if the designated constraints
// aren't met.
type GetClusterResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterResourcesResponseValidationError) ErrorName() string {
	return "GetClusterResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterResourcesResponseValidationError{}

// Validate checks the field values on PutClusterResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutClusterResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutClusterResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutClusterResourcesRequestMultiError, or nil if none found.
func (m *PutClusterResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutClusterResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PutClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PutClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PutClusterResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PutClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := PutClusterResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := PutClusterResourcesRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutClusterResourcesRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutClusterResourcesRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutClusterResourcesRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutClusterResourcesRequestMultiError(errors)
	}

	return nil
}

// PutClusterResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by PutClusterResourcesRequest.ValidateAll() if
// the designated constraints aren't met.
type PutClusterResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutClusterResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutClusterResourcesRequestMultiError) AllErrors() []error { return m }

// PutClusterResourcesRequestValidationError is the validation error returned
// by PutClusterResourcesRequest.Validate if the designated constraints aren't met.
type PutClusterResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutClusterResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutClusterResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutClusterResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutClusterResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutClusterResourcesRequestValidationError) ErrorName() string {
	return "PutClusterResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutClusterResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutClusterResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutClusterResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutClusterResourcesRequestValidationError{}

var _PutClusterResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PutClusterResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutClusterResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutClusterResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutClusterResourcesResponseMultiError, or nil if none found.
func (m *PutClusterResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutClusterResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutClusterResourcesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutClusterResourcesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutClusterResourcesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutClusterResourcesResponseMultiError(errors)
	}

	return nil
}

// PutClusterResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by PutClusterResourcesResponse.ValidateAll() if
// the designated constraints aren't met.
type PutClusterResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutClusterResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutClusterResourcesResponseMultiError) AllErrors() []error { return m }

// PutClusterResourcesResponseValidationError is the validation error returned
// by PutClusterResourcesResponse.Validate if the designated constraints
// aren't met.
type PutClusterResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutClusterResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutClusterResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutClusterResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutClusterResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutClusterResourcesResponseValidationError) ErrorName() string {
	return "PutClusterResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutClusterResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutClusterResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutClusterResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutClusterResourcesResponseValidationError{}

// Validate checks the field values on DeleteClusterResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterResourcesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteClusterResourcesRequestMultiError, or nil if none found.
func (m *DeleteClusterResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DeleteClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DeleteClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteClusterResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DeleteClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := DeleteClusterResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := DeleteClusterResourcesRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteClusterResourcesRequestMultiError(errors)
	}

	return nil
}

// DeleteClusterResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteClusterResourcesRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteClusterResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterResourcesRequestMultiError) AllErrors() []error { return m }

// DeleteClusterResourcesRequestValidationError is the validation error
// returned by DeleteClusterResourcesRequest.Validate if the designated
// constraints aren't met.
type DeleteClusterResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterResourcesRequestValidationError) ErrorName() string {
	return "DeleteClusterResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterResourcesRequestValidationError{}

var _DeleteClusterResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteClusterResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteClusterResourcesResponseMultiError, or nil if none found.
func (m *DeleteClusterResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteClusterResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteClusterResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteClusterResourcesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteClusterResourcesResponseMultiError(errors)
	}

	return nil
}

// DeleteClusterResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteClusterResourcesResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteClusterResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterResourcesResponseMultiError) AllErrors() []error { return m }

// DeleteClusterResourcesResponseValidationError is the validation error
// returned by DeleteClusterResourcesResponse.Validate if the designated
// constraints aren't met.
type DeleteClusterResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterResourcesResponseValidationError) ErrorName() string {
	return "DeleteClusterResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterResourcesResponseValidationError{}

// Validate checks the field values on ListClusterResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterResourcesRequestMultiError, or nil if none found.
func (m *ListClusterResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ListClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ListClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListClusterResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ListClusterResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := ListClusterResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	// no validation rules for LabelSelector

	// no validation rules for UpdateTimeBefore

	if m.GetOffset() < 0 {
		err := ListClusterResourcesRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := ListClusterResourcesRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListClusterResourcesRequestMultiError(errors)
	}

	return nil
}

// ListClusterResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by ListClusterResourcesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListClusterResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterResourcesRequestMultiError) AllErrors() []error { return m }

// ListClusterResourcesRequestValidationError is the validation error returned
// by ListClusterResourcesRequest.Validate if the designated constraints
// aren't met.
type ListClusterResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterResourcesRequestValidationError) ErrorName() string {
	return "ListClusterResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterResourcesRequestValidationError{}

var _ListClusterResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ListClusterResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterResourcesResponseMultiError, or nil if none found.
func (m *ListClusterResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListClusterResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListClusterResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListClusterResourcesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListClusterResourcesResponseMultiError(errors)
	}

	return nil
}

// ListClusterResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by ListClusterResourcesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListClusterResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterResourcesResponseMultiError) AllErrors() []error { return m }

// ListClusterResourcesResponseValidationError is the validation error returned
// by ListClusterResourcesResponse.Validate if the designated constraints
// aren't met.
type ListClusterResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterResourcesResponseValidationError) ErrorName() string {
	return "ListClusterResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterResourcesResponseValidationError{}

// Validate checks the field values on DeleteBatchClusterResourceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteBatchClusterResourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBatchClusterResourceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteBatchClusterResourceRequestMultiError, or nil if none found.
func (m *DeleteBatchClusterResourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBatchClusterResourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DeleteBatchClusterResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DeleteBatchClusterResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteBatchClusterResourceRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DeleteBatchClusterResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := DeleteBatchClusterResourceRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for UpdateTimeBegin

	// no validation rules for UpdateTimeEnd

	if len(errors) > 0 {
		return DeleteBatchClusterResourceRequestMultiError(errors)
	}

	return nil
}

// DeleteBatchClusterResourceRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteBatchClusterResourceRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBatchClusterResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBatchClusterResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBatchClusterResourceRequestMultiError) AllErrors() []error { return m }

// DeleteBatchClusterResourceRequestValidationError is the validation error
// returned by DeleteBatchClusterResourceRequest.Validate if the designated
// constraints aren't met.
type DeleteBatchClusterResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBatchClusterResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBatchClusterResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBatchClusterResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBatchClusterResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBatchClusterResourceRequestValidationError) ErrorName() string {
	return "DeleteBatchClusterResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBatchClusterResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBatchClusterResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBatchClusterResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBatchClusterResourceRequestValidationError{}

var _DeleteBatchClusterResourceRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteBatchClusterResourceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteBatchClusterResourceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBatchClusterResourceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteBatchClusterResourceResponseMultiError, or nil if none found.
func (m *DeleteBatchClusterResourceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBatchClusterResourceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteBatchClusterResourceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteBatchClusterResourceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteBatchClusterResourceResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteBatchClusterResourceResponseMultiError(errors)
	}

	return nil
}

// DeleteBatchClusterResourceResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteBatchClusterResourceResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteBatchClusterResourceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBatchClusterResourceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBatchClusterResourceResponseMultiError) AllErrors() []error { return m }

// DeleteBatchClusterResourceResponseValidationError is the validation error
// returned by DeleteBatchClusterResourceResponse.Validate if the designated
// constraints aren't met.
type DeleteBatchClusterResourceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBatchClusterResourceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBatchClusterResourceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBatchClusterResourceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBatchClusterResourceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBatchClusterResourceResponseValidationError) ErrorName() string {
	return "DeleteBatchClusterResourceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBatchClusterResourceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBatchClusterResourceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBatchClusterResourceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBatchClusterResourceResponseValidationError{}

// Validate checks the field values on GetCustomResourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCustomResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCustomResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCustomResourcesRequestMultiError, or nil if none found.
func (m *GetCustomResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCustomResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := GetCustomResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := GetCustomResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetCustomResourcesRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := GetCustomResourcesRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := GetCustomResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceName

	// no validation rules for Extra

	// no validation rules for LabelSelector

	// no validation rules for UpdateTimeBefore

	if m.GetOffset() < 0 {
		err := GetCustomResourcesRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := GetCustomResourcesRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCustomResourcesRequestMultiError(errors)
	}

	return nil
}

// GetCustomResourcesRequestMultiError is an error wrapping multiple validation
// errors returned by GetCustomResourcesRequest.ValidateAll() if the
// designated constraints aren't met.
type GetCustomResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCustomResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCustomResourcesRequestMultiError) AllErrors() []error { return m }

// GetCustomResourcesRequestValidationError is the validation error returned by
// GetCustomResourcesRequest.Validate if the designated constraints aren't met.
type GetCustomResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCustomResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCustomResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCustomResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCustomResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCustomResourcesRequestValidationError) ErrorName() string {
	return "GetCustomResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCustomResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCustomResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCustomResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCustomResourcesRequestValidationError{}

var _GetCustomResourcesRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetCustomResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCustomResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCustomResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCustomResourcesResponseMultiError, or nil if none found.
func (m *GetCustomResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCustomResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCustomResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCustomResourcesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCustomResourcesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for PageSize

	// no validation rules for Offset

	if len(errors) > 0 {
		return GetCustomResourcesResponseMultiError(errors)
	}

	return nil
}

// GetCustomResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by GetCustomResourcesResponse.ValidateAll() if
// the designated constraints aren't met.
type GetCustomResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCustomResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCustomResourcesResponseMultiError) AllErrors() []error { return m }

// GetCustomResourcesResponseValidationError is the validation error returned
// by GetCustomResourcesResponse.Validate if the designated constraints aren't met.
type GetCustomResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCustomResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCustomResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCustomResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCustomResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCustomResourcesResponseValidationError) ErrorName() string {
	return "GetCustomResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCustomResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCustomResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCustomResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCustomResourcesResponseValidationError{}

// Validate checks the field values on DeleteCustomResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCustomResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCustomResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCustomResourcesRequestMultiError, or nil if none found.
func (m *DeleteCustomResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCustomResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := DeleteCustomResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteCustomResourcesRequestMultiError(errors)
	}

	return nil
}

// DeleteCustomResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteCustomResourcesRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteCustomResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCustomResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCustomResourcesRequestMultiError) AllErrors() []error { return m }

// DeleteCustomResourcesRequestValidationError is the validation error returned
// by DeleteCustomResourcesRequest.Validate if the designated constraints
// aren't met.
type DeleteCustomResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCustomResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCustomResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCustomResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCustomResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCustomResourcesRequestValidationError) ErrorName() string {
	return "DeleteCustomResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCustomResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCustomResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCustomResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCustomResourcesRequestValidationError{}

// Validate checks the field values on DeleteCustomResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCustomResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCustomResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteCustomResourcesResponseMultiError, or nil if none found.
func (m *DeleteCustomResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCustomResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteCustomResourcesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteCustomResourcesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteCustomResourcesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteCustomResourcesResponseMultiError(errors)
	}

	return nil
}

// DeleteCustomResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteCustomResourcesResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteCustomResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCustomResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCustomResourcesResponseMultiError) AllErrors() []error { return m }

// DeleteCustomResourcesResponseValidationError is the validation error
// returned by DeleteCustomResourcesResponse.Validate if the designated
// constraints aren't met.
type DeleteCustomResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCustomResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCustomResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCustomResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCustomResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCustomResourcesResponseValidationError) ErrorName() string {
	return "DeleteCustomResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCustomResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCustomResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCustomResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCustomResourcesResponseValidationError{}

// Validate checks the field values on PutCustomResourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutCustomResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutCustomResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutCustomResourcesRequestMultiError, or nil if none found.
func (m *PutCustomResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutCustomResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := PutCustomResourcesRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutCustomResourcesRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutCustomResourcesRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutCustomResourcesRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutCustomResourcesRequestMultiError(errors)
	}

	return nil
}

// PutCustomResourcesRequestMultiError is an error wrapping multiple validation
// errors returned by PutCustomResourcesRequest.ValidateAll() if the
// designated constraints aren't met.
type PutCustomResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutCustomResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutCustomResourcesRequestMultiError) AllErrors() []error { return m }

// PutCustomResourcesRequestValidationError is the validation error returned by
// PutCustomResourcesRequest.Validate if the designated constraints aren't met.
type PutCustomResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutCustomResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutCustomResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutCustomResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutCustomResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutCustomResourcesRequestValidationError) ErrorName() string {
	return "PutCustomResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutCustomResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutCustomResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutCustomResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutCustomResourcesRequestValidationError{}

// Validate checks the field values on PutCustomResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutCustomResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutCustomResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutCustomResourcesResponseMultiError, or nil if none found.
func (m *PutCustomResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutCustomResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutCustomResourcesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutCustomResourcesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutCustomResourcesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutCustomResourcesResponseMultiError(errors)
	}

	return nil
}

// PutCustomResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by PutCustomResourcesResponse.ValidateAll() if
// the designated constraints aren't met.
type PutCustomResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutCustomResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutCustomResourcesResponseMultiError) AllErrors() []error { return m }

// PutCustomResourcesResponseValidationError is the validation error returned
// by PutCustomResourcesResponse.Validate if the designated constraints aren't met.
type PutCustomResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutCustomResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutCustomResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutCustomResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutCustomResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutCustomResourcesResponseValidationError) ErrorName() string {
	return "PutCustomResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutCustomResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutCustomResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutCustomResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutCustomResourcesResponseValidationError{}

// Validate checks the field values on CreateCustomResourcesIndexRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateCustomResourcesIndexRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCustomResourcesIndexRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateCustomResourcesIndexRequestMultiError, or nil if none found.
func (m *CreateCustomResourcesIndexRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCustomResourcesIndexRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := CreateCustomResourcesIndexRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIndexName()) < 1 {
		err := CreateCustomResourcesIndexRequestValidationError{
			field:  "IndexName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCustomResourcesIndexRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCustomResourcesIndexRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCustomResourcesIndexRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCustomResourcesIndexRequestMultiError(errors)
	}

	return nil
}

// CreateCustomResourcesIndexRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateCustomResourcesIndexRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateCustomResourcesIndexRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCustomResourcesIndexRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCustomResourcesIndexRequestMultiError) AllErrors() []error { return m }

// CreateCustomResourcesIndexRequestValidationError is the validation error
// returned by CreateCustomResourcesIndexRequest.Validate if the designated
// constraints aren't met.
type CreateCustomResourcesIndexRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCustomResourcesIndexRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCustomResourcesIndexRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCustomResourcesIndexRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCustomResourcesIndexRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCustomResourcesIndexRequestValidationError) ErrorName() string {
	return "CreateCustomResourcesIndexRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCustomResourcesIndexRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCustomResourcesIndexRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCustomResourcesIndexRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCustomResourcesIndexRequestValidationError{}

// Validate checks the field values on CreateCustomResourcesIndexResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateCustomResourcesIndexResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCustomResourcesIndexResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateCustomResourcesIndexResponseMultiError, or nil if none found.
func (m *CreateCustomResourcesIndexResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCustomResourcesIndexResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCustomResourcesIndexResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCustomResourcesIndexResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCustomResourcesIndexResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCustomResourcesIndexResponseMultiError(errors)
	}

	return nil
}

// CreateCustomResourcesIndexResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateCustomResourcesIndexResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCustomResourcesIndexResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCustomResourcesIndexResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCustomResourcesIndexResponseMultiError) AllErrors() []error { return m }

// CreateCustomResourcesIndexResponseValidationError is the validation error
// returned by CreateCustomResourcesIndexResponse.Validate if the designated
// constraints aren't met.
type CreateCustomResourcesIndexResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCustomResourcesIndexResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCustomResourcesIndexResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCustomResourcesIndexResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCustomResourcesIndexResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCustomResourcesIndexResponseValidationError) ErrorName() string {
	return "CreateCustomResourcesIndexResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCustomResourcesIndexResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCustomResourcesIndexResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCustomResourcesIndexResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCustomResourcesIndexResponseValidationError{}

// Validate checks the field values on DeleteCustomResourcesIndexRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteCustomResourcesIndexRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCustomResourcesIndexRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteCustomResourcesIndexRequestMultiError, or nil if none found.
func (m *DeleteCustomResourcesIndexRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCustomResourcesIndexRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := DeleteCustomResourcesIndexRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIndexName()) < 1 {
		err := DeleteCustomResourcesIndexRequestValidationError{
			field:  "IndexName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteCustomResourcesIndexRequestMultiError(errors)
	}

	return nil
}

// DeleteCustomResourcesIndexRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteCustomResourcesIndexRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteCustomResourcesIndexRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCustomResourcesIndexRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCustomResourcesIndexRequestMultiError) AllErrors() []error { return m }

// DeleteCustomResourcesIndexRequestValidationError is the validation error
// returned by DeleteCustomResourcesIndexRequest.Validate if the designated
// constraints aren't met.
type DeleteCustomResourcesIndexRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCustomResourcesIndexRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCustomResourcesIndexRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCustomResourcesIndexRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCustomResourcesIndexRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCustomResourcesIndexRequestValidationError) ErrorName() string {
	return "DeleteCustomResourcesIndexRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCustomResourcesIndexRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCustomResourcesIndexRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCustomResourcesIndexRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCustomResourcesIndexRequestValidationError{}

// Validate checks the field values on DeleteCustomResourcesIndexResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteCustomResourcesIndexResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCustomResourcesIndexResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteCustomResourcesIndexResponseMultiError, or nil if none found.
func (m *DeleteCustomResourcesIndexResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCustomResourcesIndexResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteCustomResourcesIndexResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteCustomResourcesIndexResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteCustomResourcesIndexResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteCustomResourcesIndexResponseMultiError(errors)
	}

	return nil
}

// DeleteCustomResourcesIndexResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteCustomResourcesIndexResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteCustomResourcesIndexResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCustomResourcesIndexResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCustomResourcesIndexResponseMultiError) AllErrors() []error { return m }

// DeleteCustomResourcesIndexResponseValidationError is the validation error
// returned by DeleteCustomResourcesIndexResponse.Validate if the designated
// constraints aren't met.
type DeleteCustomResourcesIndexResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCustomResourcesIndexResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCustomResourcesIndexResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCustomResourcesIndexResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCustomResourcesIndexResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCustomResourcesIndexResponseValidationError) ErrorName() string {
	return "DeleteCustomResourcesIndexResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCustomResourcesIndexResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCustomResourcesIndexResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCustomResourcesIndexResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCustomResourcesIndexResponseValidationError{}

// Validate checks the field values on IPPoolStatic with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IPPoolStatic) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPoolStatic with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IPPoolStaticMultiError, or
// nil if none found.
func (m *IPPoolStatic) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPoolStatic) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := IPPoolStaticValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := IPPoolStaticValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IPPoolStatic_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := IPPoolStaticValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPPoolStaticValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPPoolStaticValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPPoolStaticValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return IPPoolStaticMultiError(errors)
	}

	return nil
}

// IPPoolStaticMultiError is an error wrapping multiple validation errors
// returned by IPPoolStatic.ValidateAll() if the designated constraints aren't met.
type IPPoolStaticMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolStaticMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolStaticMultiError) AllErrors() []error { return m }

// IPPoolStaticValidationError is the validation error returned by
// IPPoolStatic.Validate if the designated constraints aren't met.
type IPPoolStaticValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolStaticValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolStaticValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolStaticValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolStaticValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolStaticValidationError) ErrorName() string { return "IPPoolStaticValidationError" }

// Error satisfies the builtin error interface
func (e IPPoolStaticValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPoolStatic.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolStaticValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolStaticValidationError{}

var _IPPoolStatic_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on IPPoolStaticRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IPPoolStaticRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPoolStaticRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPPoolStaticRequestMultiError, or nil if none found.
func (m *IPPoolStaticRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPoolStaticRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := IPPoolStaticRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := IPPoolStaticRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IPPoolStaticRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := IPPoolStaticRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPPoolStaticRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPPoolStaticRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPPoolStaticRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOffset() < 0 {
		err := IPPoolStaticRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := IPPoolStaticRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IPPoolStaticRequestMultiError(errors)
	}

	return nil
}

// IPPoolStaticRequestMultiError is an error wrapping multiple validation
// errors returned by IPPoolStaticRequest.ValidateAll() if the designated
// constraints aren't met.
type IPPoolStaticRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolStaticRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolStaticRequestMultiError) AllErrors() []error { return m }

// IPPoolStaticRequestValidationError is the validation error returned by
// IPPoolStaticRequest.Validate if the designated constraints aren't met.
type IPPoolStaticRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolStaticRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolStaticRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolStaticRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolStaticRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolStaticRequestValidationError) ErrorName() string {
	return "IPPoolStaticRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IPPoolStaticRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPoolStaticRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolStaticRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolStaticRequestValidationError{}

var _IPPoolStaticRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on IPPoolStaticResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IPPoolStaticResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPoolStaticResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPPoolStaticResponseMultiError, or nil if none found.
func (m *IPPoolStaticResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPoolStaticResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IPPoolStaticResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IPPoolStaticResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IPPoolStaticResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IPPoolStaticResponseMultiError(errors)
	}

	return nil
}

// IPPoolStaticResponseMultiError is an error wrapping multiple validation
// errors returned by IPPoolStaticResponse.ValidateAll() if the designated
// constraints aren't met.
type IPPoolStaticResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolStaticResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolStaticResponseMultiError) AllErrors() []error { return m }

// IPPoolStaticResponseValidationError is the validation error returned by
// IPPoolStaticResponse.Validate if the designated constraints aren't met.
type IPPoolStaticResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolStaticResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolStaticResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolStaticResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolStaticResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolStaticResponseValidationError) ErrorName() string {
	return "IPPoolStaticResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IPPoolStaticResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPoolStaticResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolStaticResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolStaticResponseValidationError{}

// Validate checks the field values on IPPoolStaticDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IPPoolStaticDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPoolStaticDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPPoolStaticDetailMultiError, or nil if none found.
func (m *IPPoolStaticDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPoolStaticDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := IPPoolStaticDetailValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := IPPoolStaticDetailValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IPPoolStaticDetail_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := IPPoolStaticDetailValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPPoolStaticDetailValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPPoolStaticDetailValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPPoolStaticDetailValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return IPPoolStaticDetailMultiError(errors)
	}

	return nil
}

// IPPoolStaticDetailMultiError is an error wrapping multiple validation errors
// returned by IPPoolStaticDetail.ValidateAll() if the designated constraints
// aren't met.
type IPPoolStaticDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolStaticDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolStaticDetailMultiError) AllErrors() []error { return m }

// IPPoolStaticDetailValidationError is the validation error returned by
// IPPoolStaticDetail.Validate if the designated constraints aren't met.
type IPPoolStaticDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolStaticDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolStaticDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolStaticDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolStaticDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolStaticDetailValidationError) ErrorName() string {
	return "IPPoolStaticDetailValidationError"
}

// Error satisfies the builtin error interface
func (e IPPoolStaticDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPoolStaticDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolStaticDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolStaticDetailValidationError{}

var _IPPoolStaticDetail_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on IPPoolStaticDetailRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IPPoolStaticDetailRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPoolStaticDetailRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPPoolStaticDetailRequestMultiError, or nil if none found.
func (m *IPPoolStaticDetailRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPoolStaticDetailRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := IPPoolStaticDetailRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := IPPoolStaticDetailRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IPPoolStaticDetailRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := IPPoolStaticDetailRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPPoolStaticDetailRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPPoolStaticDetailRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPPoolStaticDetailRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOffset() < 0 {
		err := IPPoolStaticDetailRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := IPPoolStaticDetailRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IPPoolStaticDetailRequestMultiError(errors)
	}

	return nil
}

// IPPoolStaticDetailRequestMultiError is an error wrapping multiple validation
// errors returned by IPPoolStaticDetailRequest.ValidateAll() if the
// designated constraints aren't met.
type IPPoolStaticDetailRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolStaticDetailRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolStaticDetailRequestMultiError) AllErrors() []error { return m }

// IPPoolStaticDetailRequestValidationError is the validation error returned by
// IPPoolStaticDetailRequest.Validate if the designated constraints aren't met.
type IPPoolStaticDetailRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolStaticDetailRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolStaticDetailRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolStaticDetailRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolStaticDetailRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolStaticDetailRequestValidationError) ErrorName() string {
	return "IPPoolStaticDetailRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IPPoolStaticDetailRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPoolStaticDetailRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolStaticDetailRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolStaticDetailRequestValidationError{}

var _IPPoolStaticDetailRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on IPPoolStaticDetailResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IPPoolStaticDetailResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPoolStaticDetailResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPPoolStaticDetailResponseMultiError, or nil if none found.
func (m *IPPoolStaticDetailResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPoolStaticDetailResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IPPoolStaticDetailResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IPPoolStaticDetailResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IPPoolStaticDetailResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IPPoolStaticDetailResponseMultiError(errors)
	}

	return nil
}

// IPPoolStaticDetailResponseMultiError is an error wrapping multiple
// validation errors returned by IPPoolStaticDetailResponse.ValidateAll() if
// the designated constraints aren't met.
type IPPoolStaticDetailResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolStaticDetailResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolStaticDetailResponseMultiError) AllErrors() []error { return m }

// IPPoolStaticDetailResponseValidationError is the validation error returned
// by IPPoolStaticDetailResponse.Validate if the designated constraints aren't met.
type IPPoolStaticDetailResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolStaticDetailResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolStaticDetailResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolStaticDetailResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolStaticDetailResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolStaticDetailResponseValidationError) ErrorName() string {
	return "IPPoolStaticDetailResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IPPoolStaticDetailResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPoolStaticDetailResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolStaticDetailResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolStaticDetailResponseValidationError{}

// Validate checks the field values on Pod with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Pod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pod with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PodMultiError, or nil if none found.
func (m *Pod) ValidateAll() error {
	return m.validate(true)
}

func (m *Pod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PodValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PodValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Pod_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PodValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PodValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PodValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PodValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return PodMultiError(errors)
	}

	return nil
}

// PodMultiError is an error wrapping multiple validation errors returned by
// Pod.ValidateAll() if the designated constraints aren't met.
type PodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodMultiError) AllErrors() []error { return m }

// PodValidationError is the validation error returned by Pod.Validate if the
// designated constraints aren't met.
type PodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodValidationError) ErrorName() string { return "PodValidationError" }

// Error satisfies the builtin error interface
func (e PodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodValidationError{}

var _Pod_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PodRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PodRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PodRequestMultiError, or
// nil if none found.
func (m *PodRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PodRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PodRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PodRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PodRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PodRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for HostIP

	// no validation rules for PodIP

	// no validation rules for Status

	// no validation rules for StartTimeBegin

	// no validation rules for StartTimeEnd

	if m.GetOffset() < 0 {
		err := PodRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := PodRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PodRequestMultiError(errors)
	}

	return nil
}

// PodRequestMultiError is an error wrapping multiple validation errors
// returned by PodRequest.ValidateAll() if the designated constraints aren't met.
type PodRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodRequestMultiError) AllErrors() []error { return m }

// PodRequestValidationError is the validation error returned by
// PodRequest.Validate if the designated constraints aren't met.
type PodRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodRequestValidationError) ErrorName() string { return "PodRequestValidationError" }

// Error satisfies the builtin error interface
func (e PodRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodRequestValidationError{}

var _PodRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PodResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PodResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PodResponseMultiError, or
// nil if none found.
func (m *PodResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PodResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PodResponseMultiError(errors)
	}

	return nil
}

// PodResponseMultiError is an error wrapping multiple validation errors
// returned by PodResponse.ValidateAll() if the designated constraints aren't met.
type PodResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodResponseMultiError) AllErrors() []error { return m }

// PodResponseValidationError is the validation error returned by
// PodResponse.Validate if the designated constraints aren't met.
type PodResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodResponseValidationError) ErrorName() string { return "PodResponseValidationError" }

// Error satisfies the builtin error interface
func (e PodResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodResponseValidationError{}

// Validate checks the field values on ReplicaSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReplicaSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReplicaSet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReplicaSetMultiError, or
// nil if none found.
func (m *ReplicaSet) ValidateAll() error {
	return m.validate(true)
}

func (m *ReplicaSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ReplicaSetValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ReplicaSetValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ReplicaSet_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ReplicaSetValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReplicaSetValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReplicaSetValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReplicaSetValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return ReplicaSetMultiError(errors)
	}

	return nil
}

// ReplicaSetMultiError is an error wrapping multiple validation errors
// returned by ReplicaSet.ValidateAll() if the designated constraints aren't met.
type ReplicaSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReplicaSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReplicaSetMultiError) AllErrors() []error { return m }

// ReplicaSetValidationError is the validation error returned by
// ReplicaSet.Validate if the designated constraints aren't met.
type ReplicaSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReplicaSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReplicaSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReplicaSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReplicaSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReplicaSetValidationError) ErrorName() string { return "ReplicaSetValidationError" }

// Error satisfies the builtin error interface
func (e ReplicaSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReplicaSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReplicaSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReplicaSetValidationError{}

var _ReplicaSet_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ReplicaSetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReplicaSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReplicaSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReplicaSetRequestMultiError, or nil if none found.
func (m *ReplicaSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReplicaSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ReplicaSetRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ReplicaSetRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ReplicaSetRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ReplicaSetRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Replicas

	// no validation rules for AvailableReplicas

	// no validation rules for ReadyReplicas

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	if m.GetOffset() < 0 {
		err := ReplicaSetRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := ReplicaSetRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ReplicaSetRequestMultiError(errors)
	}

	return nil
}

// ReplicaSetRequestMultiError is an error wrapping multiple validation errors
// returned by ReplicaSetRequest.ValidateAll() if the designated constraints
// aren't met.
type ReplicaSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReplicaSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReplicaSetRequestMultiError) AllErrors() []error { return m }

// ReplicaSetRequestValidationError is the validation error returned by
// ReplicaSetRequest.Validate if the designated constraints aren't met.
type ReplicaSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReplicaSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReplicaSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReplicaSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReplicaSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReplicaSetRequestValidationError) ErrorName() string {
	return "ReplicaSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReplicaSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReplicaSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReplicaSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReplicaSetRequestValidationError{}

var _ReplicaSetRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ReplicaSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReplicaSetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReplicaSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReplicaSetResponseMultiError, or nil if none found.
func (m *ReplicaSetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReplicaSetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReplicaSetResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReplicaSetResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReplicaSetResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReplicaSetResponseMultiError(errors)
	}

	return nil
}

// ReplicaSetResponseMultiError is an error wrapping multiple validation errors
// returned by ReplicaSetResponse.ValidateAll() if the designated constraints
// aren't met.
type ReplicaSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReplicaSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReplicaSetResponseMultiError) AllErrors() []error { return m }

// ReplicaSetResponseValidationError is the validation error returned by
// ReplicaSetResponse.Validate if the designated constraints aren't met.
type ReplicaSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReplicaSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReplicaSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReplicaSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReplicaSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReplicaSetResponseValidationError) ErrorName() string {
	return "ReplicaSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReplicaSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReplicaSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReplicaSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReplicaSetResponseValidationError{}

// Validate checks the field values on DeploymentK8S with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeploymentK8S) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentK8S with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeploymentK8SMultiError, or
// nil if none found.
func (m *DeploymentK8S) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentK8S) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DeploymentK8SValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DeploymentK8SValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentK8S_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DeploymentK8SValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeploymentK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeploymentK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeploymentK8SValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return DeploymentK8SMultiError(errors)
	}

	return nil
}

// DeploymentK8SMultiError is an error wrapping multiple validation errors
// returned by DeploymentK8S.ValidateAll() if the designated constraints
// aren't met.
type DeploymentK8SMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentK8SMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentK8SMultiError) AllErrors() []error { return m }

// DeploymentK8SValidationError is the validation error returned by
// DeploymentK8S.Validate if the designated constraints aren't met.
type DeploymentK8SValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentK8SValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentK8SValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentK8SValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentK8SValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentK8SValidationError) ErrorName() string { return "DeploymentK8SValidationError" }

// Error satisfies the builtin error interface
func (e DeploymentK8SValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentK8S.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentK8SValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentK8SValidationError{}

var _DeploymentK8S_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeploymentK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeploymentK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentK8SRequestMultiError, or nil if none found.
func (m *DeploymentK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DeploymentK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DeploymentK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeploymentK8SRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DeploymentK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Replicas

	// no validation rules for AvailableReplicas

	// no validation rules for UpdatedReplicas

	// no validation rules for StrategyType

	// no validation rules for DnsPolicy

	// no validation rules for RestartPolicy

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeploymentK8SRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeploymentK8SRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeploymentK8SRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOffset() < 0 {
		err := DeploymentK8SRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := DeploymentK8SRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeploymentK8SRequestMultiError(errors)
	}

	return nil
}

// DeploymentK8SRequestMultiError is an error wrapping multiple validation
// errors returned by DeploymentK8SRequest.ValidateAll() if the designated
// constraints aren't met.
type DeploymentK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentK8SRequestMultiError) AllErrors() []error { return m }

// DeploymentK8SRequestValidationError is the validation error returned by
// DeploymentK8SRequest.Validate if the designated constraints aren't met.
type DeploymentK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentK8SRequestValidationError) ErrorName() string {
	return "DeploymentK8SRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeploymentK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentK8SRequestValidationError{}

var _DeploymentK8SRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeploymentK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeploymentK8SResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentK8SResponseMultiError, or nil if none found.
func (m *DeploymentK8SResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentK8SResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeploymentK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeploymentK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeploymentK8SResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeploymentK8SResponseMultiError(errors)
	}

	return nil
}

// DeploymentK8SResponseMultiError is an error wrapping multiple validation
// errors returned by DeploymentK8SResponse.ValidateAll() if the designated
// constraints aren't met.
type DeploymentK8SResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentK8SResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentK8SResponseMultiError) AllErrors() []error { return m }

// DeploymentK8SResponseValidationError is the validation error returned by
// DeploymentK8SResponse.Validate if the designated constraints aren't met.
type DeploymentK8SResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentK8SResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentK8SResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentK8SResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentK8SResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentK8SResponseValidationError) ErrorName() string {
	return "DeploymentK8SResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeploymentK8SResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentK8SResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentK8SResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentK8SResponseValidationError{}

// Validate checks the field values on ServiceK8S with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceK8S) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceK8S with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceK8SMultiError, or
// nil if none found.
func (m *ServiceK8S) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceK8S) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ServiceK8SValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ServiceK8SValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceK8S_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ServiceK8SValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceK8SValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return ServiceK8SMultiError(errors)
	}

	return nil
}

// ServiceK8SMultiError is an error wrapping multiple validation errors
// returned by ServiceK8S.ValidateAll() if the designated constraints aren't met.
type ServiceK8SMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceK8SMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceK8SMultiError) AllErrors() []error { return m }

// ServiceK8SValidationError is the validation error returned by
// ServiceK8S.Validate if the designated constraints aren't met.
type ServiceK8SValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceK8SValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceK8SValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceK8SValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceK8SValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceK8SValidationError) ErrorName() string { return "ServiceK8SValidationError" }

// Error satisfies the builtin error interface
func (e ServiceK8SValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceK8S.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceK8SValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceK8SValidationError{}

var _ServiceK8S_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ServiceK8SRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceK8SRequestMultiError, or nil if none found.
func (m *ServiceK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ServiceK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ServiceK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceK8SRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ServiceK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for ClusterIP

	// no validation rules for Type

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	if m.GetOffset() < 0 {
		err := ServiceK8SRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := ServiceK8SRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServiceK8SRequestMultiError(errors)
	}

	return nil
}

// ServiceK8SRequestMultiError is an error wrapping multiple validation errors
// returned by ServiceK8SRequest.ValidateAll() if the designated constraints
// aren't met.
type ServiceK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceK8SRequestMultiError) AllErrors() []error { return m }

// ServiceK8SRequestValidationError is the validation error returned by
// ServiceK8SRequest.Validate if the designated constraints aren't met.
type ServiceK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceK8SRequestValidationError) ErrorName() string {
	return "ServiceK8SRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceK8SRequestValidationError{}

var _ServiceK8SRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ServiceK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceK8SResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceK8SResponseMultiError, or nil if none found.
func (m *ServiceK8SResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceK8SResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceK8SResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceK8SResponseMultiError(errors)
	}

	return nil
}

// ServiceK8SResponseMultiError is an error wrapping multiple validation errors
// returned by ServiceK8SResponse.ValidateAll() if the designated constraints
// aren't met.
type ServiceK8SResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceK8SResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceK8SResponseMultiError) AllErrors() []error { return m }

// ServiceK8SResponseValidationError is the validation error returned by
// ServiceK8SResponse.Validate if the designated constraints aren't met.
type ServiceK8SResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceK8SResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceK8SResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceK8SResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceK8SResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceK8SResponseValidationError) ErrorName() string {
	return "ServiceK8SResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceK8SResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceK8SResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceK8SResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceK8SResponseValidationError{}

// Validate checks the field values on ConfigMapK8S with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigMapK8S) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigMapK8S with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigMapK8SMultiError, or
// nil if none found.
func (m *ConfigMapK8S) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigMapK8S) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ConfigMapK8SValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ConfigMapK8SValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigMapK8S_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ConfigMapK8SValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigMapK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigMapK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigMapK8SValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return ConfigMapK8SMultiError(errors)
	}

	return nil
}

// ConfigMapK8SMultiError is an error wrapping multiple validation errors
// returned by ConfigMapK8S.ValidateAll() if the designated constraints aren't met.
type ConfigMapK8SMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMapK8SMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMapK8SMultiError) AllErrors() []error { return m }

// ConfigMapK8SValidationError is the validation error returned by
// ConfigMapK8S.Validate if the designated constraints aren't met.
type ConfigMapK8SValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMapK8SValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMapK8SValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMapK8SValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMapK8SValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMapK8SValidationError) ErrorName() string { return "ConfigMapK8SValidationError" }

// Error satisfies the builtin error interface
func (e ConfigMapK8SValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMapK8S.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMapK8SValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMapK8SValidationError{}

var _ConfigMapK8S_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ConfigMapK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigMapK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigMapK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigMapK8SRequestMultiError, or nil if none found.
func (m *ConfigMapK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigMapK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ConfigMapK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ConfigMapK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigMapK8SRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ConfigMapK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigMapK8SRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigMapK8SRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigMapK8SRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOffset() < 0 {
		err := ConfigMapK8SRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := ConfigMapK8SRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConfigMapK8SRequestMultiError(errors)
	}

	return nil
}

// ConfigMapK8SRequestMultiError is an error wrapping multiple validation
// errors returned by ConfigMapK8SRequest.ValidateAll() if the designated
// constraints aren't met.
type ConfigMapK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMapK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMapK8SRequestMultiError) AllErrors() []error { return m }

// ConfigMapK8SRequestValidationError is the validation error returned by
// ConfigMapK8SRequest.Validate if the designated constraints aren't met.
type ConfigMapK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMapK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMapK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMapK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMapK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMapK8SRequestValidationError) ErrorName() string {
	return "ConfigMapK8SRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigMapK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMapK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMapK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMapK8SRequestValidationError{}

var _ConfigMapK8SRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ConfigMapK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigMapK8SResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigMapK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigMapK8SResponseMultiError, or nil if none found.
func (m *ConfigMapK8SResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigMapK8SResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigMapK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigMapK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigMapK8SResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConfigMapK8SResponseMultiError(errors)
	}

	return nil
}

// ConfigMapK8SResponseMultiError is an error wrapping multiple validation
// errors returned by ConfigMapK8SResponse.ValidateAll() if the designated
// constraints aren't met.
type ConfigMapK8SResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMapK8SResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMapK8SResponseMultiError) AllErrors() []error { return m }

// ConfigMapK8SResponseValidationError is the validation error returned by
// ConfigMapK8SResponse.Validate if the designated constraints aren't met.
type ConfigMapK8SResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMapK8SResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMapK8SResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMapK8SResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMapK8SResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMapK8SResponseValidationError) ErrorName() string {
	return "ConfigMapK8SResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigMapK8SResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMapK8SResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMapK8SResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMapK8SResponseValidationError{}

// Validate checks the field values on SecretK8S with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretK8S) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretK8S with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretK8SMultiError, or nil
// if none found.
func (m *SecretK8S) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretK8S) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := SecretK8SValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := SecretK8SValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SecretK8S_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := SecretK8SValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecretK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecretK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecretK8SValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return SecretK8SMultiError(errors)
	}

	return nil
}

// SecretK8SMultiError is an error wrapping multiple validation errors returned
// by SecretK8S.ValidateAll() if the designated constraints aren't met.
type SecretK8SMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretK8SMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretK8SMultiError) AllErrors() []error { return m }

// SecretK8SValidationError is the validation error returned by
// SecretK8S.Validate if the designated constraints aren't met.
type SecretK8SValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretK8SValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretK8SValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretK8SValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretK8SValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretK8SValidationError) ErrorName() string { return "SecretK8SValidationError" }

// Error satisfies the builtin error interface
func (e SecretK8SValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretK8S.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretK8SValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretK8SValidationError{}

var _SecretK8S_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on SecretK8SRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SecretK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecretK8SRequestMultiError, or nil if none found.
func (m *SecretK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := SecretK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := SecretK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SecretK8SRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := SecretK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecretK8SRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecretK8SRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecretK8SRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOffset() < 0 {
		err := SecretK8SRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := SecretK8SRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SecretK8SRequestMultiError(errors)
	}

	return nil
}

// SecretK8SRequestMultiError is an error wrapping multiple validation errors
// returned by SecretK8SRequest.ValidateAll() if the designated constraints
// aren't met.
type SecretK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretK8SRequestMultiError) AllErrors() []error { return m }

// SecretK8SRequestValidationError is the validation error returned by
// SecretK8SRequest.Validate if the designated constraints aren't met.
type SecretK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretK8SRequestValidationError) ErrorName() string { return "SecretK8SRequestValidationError" }

// Error satisfies the builtin error interface
func (e SecretK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretK8SRequestValidationError{}

var _SecretK8SRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on SecretK8SResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SecretK8SResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecretK8SResponseMultiError, or nil if none found.
func (m *SecretK8SResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretK8SResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecretK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecretK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecretK8SResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SecretK8SResponseMultiError(errors)
	}

	return nil
}

// SecretK8SResponseMultiError is an error wrapping multiple validation errors
// returned by SecretK8SResponse.ValidateAll() if the designated constraints
// aren't met.
type SecretK8SResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretK8SResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretK8SResponseMultiError) AllErrors() []error { return m }

// SecretK8SResponseValidationError is the validation error returned by
// SecretK8SResponse.Validate if the designated constraints aren't met.
type SecretK8SResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretK8SResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretK8SResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretK8SResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretK8SResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretK8SResponseValidationError) ErrorName() string {
	return "SecretK8SResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SecretK8SResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretK8SResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretK8SResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretK8SResponseValidationError{}

// Validate checks the field values on EndpointsK8S with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EndpointsK8S) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EndpointsK8S with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EndpointsK8SMultiError, or
// nil if none found.
func (m *EndpointsK8S) ValidateAll() error {
	return m.validate(true)
}

func (m *EndpointsK8S) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := EndpointsK8SValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := EndpointsK8SValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EndpointsK8S_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := EndpointsK8SValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EndpointsK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EndpointsK8SValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EndpointsK8SValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return EndpointsK8SMultiError(errors)
	}

	return nil
}

// EndpointsK8SMultiError is an error wrapping multiple validation errors
// returned by EndpointsK8S.ValidateAll() if the designated constraints aren't met.
type EndpointsK8SMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EndpointsK8SMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EndpointsK8SMultiError) AllErrors() []error { return m }

// EndpointsK8SValidationError is the validation error returned by
// EndpointsK8S.Validate if the designated constraints aren't met.
type EndpointsK8SValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndpointsK8SValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndpointsK8SValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndpointsK8SValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndpointsK8SValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndpointsK8SValidationError) ErrorName() string { return "EndpointsK8SValidationError" }

// Error satisfies the builtin error interface
func (e EndpointsK8SValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndpointsK8S.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndpointsK8SValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndpointsK8SValidationError{}

var _EndpointsK8S_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on EndpointsK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EndpointsK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EndpointsK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EndpointsK8SRequestMultiError, or nil if none found.
func (m *EndpointsK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EndpointsK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := EndpointsK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := EndpointsK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EndpointsK8SRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := EndpointsK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	if m.GetOffset() < 0 {
		err := EndpointsK8SRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := EndpointsK8SRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EndpointsK8SRequestMultiError(errors)
	}

	return nil
}

// EndpointsK8SRequestMultiError is an error wrapping multiple validation
// errors returned by EndpointsK8SRequest.ValidateAll() if the designated
// constraints aren't met.
type EndpointsK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EndpointsK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EndpointsK8SRequestMultiError) AllErrors() []error { return m }

// EndpointsK8SRequestValidationError is the validation error returned by
// EndpointsK8SRequest.Validate if the designated constraints aren't met.
type EndpointsK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndpointsK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndpointsK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndpointsK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndpointsK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndpointsK8SRequestValidationError) ErrorName() string {
	return "EndpointsK8SRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EndpointsK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndpointsK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndpointsK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndpointsK8SRequestValidationError{}

var _EndpointsK8SRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on EndpointsK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EndpointsK8SResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EndpointsK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EndpointsK8SResponseMultiError, or nil if none found.
func (m *EndpointsK8SResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EndpointsK8SResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EndpointsK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EndpointsK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EndpointsK8SResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EndpointsK8SResponseMultiError(errors)
	}

	return nil
}

// EndpointsK8SResponseMultiError is an error wrapping multiple validation
// errors returned by EndpointsK8SResponse.ValidateAll() if the designated
// constraints aren't met.
type EndpointsK8SResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EndpointsK8SResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EndpointsK8SResponseMultiError) AllErrors() []error { return m }

// EndpointsK8SResponseValidationError is the validation error returned by
// EndpointsK8SResponse.Validate if the designated constraints aren't met.
type EndpointsK8SResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndpointsK8SResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndpointsK8SResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndpointsK8SResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndpointsK8SResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndpointsK8SResponseValidationError) ErrorName() string {
	return "EndpointsK8SResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EndpointsK8SResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndpointsK8SResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndpointsK8SResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndpointsK8SResponseValidationError{}

// Validate checks the field values on Ingress with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Ingress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ingress with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IngressMultiError, or nil if none found.
func (m *Ingress) ValidateAll() error {
	return m.validate(true)
}

func (m *Ingress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := IngressValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := IngressValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Ingress_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := IngressValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IngressValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IngressValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IngressValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return IngressMultiError(errors)
	}

	return nil
}

// IngressMultiError is an error wrapping multiple validation errors returned
// by Ingress.ValidateAll() if the designated constraints aren't met.
type IngressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngressMultiError) AllErrors() []error { return m }

// IngressValidationError is the validation error returned by Ingress.Validate
// if the designated constraints aren't met.
type IngressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngressValidationError) ErrorName() string { return "IngressValidationError" }

// Error satisfies the builtin error interface
func (e IngressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngressValidationError{}

var _Ingress_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on IngressRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IngressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngressRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IngressRequestMultiError,
// or nil if none found.
func (m *IngressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IngressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := IngressRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := IngressRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IngressRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := IngressRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	if m.GetOffset() < 0 {
		err := IngressRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := IngressRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IngressRequestMultiError(errors)
	}

	return nil
}

// IngressRequestMultiError is an error wrapping multiple validation errors
// returned by IngressRequest.ValidateAll() if the designated constraints
// aren't met.
type IngressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngressRequestMultiError) AllErrors() []error { return m }

// IngressRequestValidationError is the validation error returned by
// IngressRequest.Validate if the designated constraints aren't met.
type IngressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngressRequestValidationError) ErrorName() string { return "IngressRequestValidationError" }

// Error satisfies the builtin error interface
func (e IngressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngressRequestValidationError{}

var _IngressRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on IngressResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IngressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IngressResponseMultiError, or nil if none found.
func (m *IngressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IngressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IngressResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IngressResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IngressResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IngressResponseMultiError(errors)
	}

	return nil
}

// IngressResponseMultiError is an error wrapping multiple validation errors
// returned by IngressResponse.ValidateAll() if the designated constraints
// aren't met.
type IngressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngressResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngressResponseMultiError) AllErrors() []error { return m }

// IngressResponseValidationError is the validation error returned by
// IngressResponse.Validate if the designated constraints aren't met.
type IngressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngressResponseValidationError) ErrorName() string { return "IngressResponseValidationError" }

// Error satisfies the builtin error interface
func (e IngressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngressResponseValidationError{}

// Validate checks the field values on Namespace with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Namespace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Namespace with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamespaceMultiError, or nil
// if none found.
func (m *Namespace) ValidateAll() error {
	return m.validate(true)
}

func (m *Namespace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := NamespaceValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := NamespaceValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Namespace_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := NamespaceValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamespaceValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamespaceValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamespaceValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return NamespaceMultiError(errors)
	}

	return nil
}

// NamespaceMultiError is an error wrapping multiple validation errors returned
// by Namespace.ValidateAll() if the designated constraints aren't met.
type NamespaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceMultiError) AllErrors() []error { return m }

// NamespaceValidationError is the validation error returned by
// Namespace.Validate if the designated constraints aren't met.
type NamespaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceValidationError) ErrorName() string { return "NamespaceValidationError" }

// Error satisfies the builtin error interface
func (e NamespaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceValidationError{}

var _Namespace_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on NamespaceK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamespaceK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamespaceK8SRequestMultiError, or nil if none found.
func (m *NamespaceK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := NamespaceK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := NamespaceK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_NamespaceK8SRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := NamespaceK8SRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamespaceK8SRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamespaceK8SRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamespaceK8SRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Used

	if m.GetOffset() < 0 {
		err := NamespaceK8SRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := NamespaceK8SRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NamespaceK8SRequestMultiError(errors)
	}

	return nil
}

// NamespaceK8SRequestMultiError is an error wrapping multiple validation
// errors returned by NamespaceK8SRequest.ValidateAll() if the designated
// constraints aren't met.
type NamespaceK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceK8SRequestMultiError) AllErrors() []error { return m }

// NamespaceK8SRequestValidationError is the validation error returned by
// NamespaceK8SRequest.Validate if the designated constraints aren't met.
type NamespaceK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceK8SRequestValidationError) ErrorName() string {
	return "NamespaceK8SRequestValidationError"
}

// Error satisfies the builtin error interface
func (e NamespaceK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceK8SRequestValidationError{}

var _NamespaceK8SRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on NamespaceK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamespaceK8SResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceK8SResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamespaceK8SResponseMultiError, or nil if none found.
func (m *NamespaceK8SResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceK8SResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NamespaceK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NamespaceK8SResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NamespaceK8SResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NamespaceK8SResponseMultiError(errors)
	}

	return nil
}

// NamespaceK8SResponseMultiError is an error wrapping multiple validation
// errors returned by NamespaceK8SResponse.ValidateAll() if the designated
// constraints aren't met.
type NamespaceK8SResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceK8SResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceK8SResponseMultiError) AllErrors() []error { return m }

// NamespaceK8SResponseValidationError is the validation error returned by
// NamespaceK8SResponse.Validate if the designated constraints aren't met.
type NamespaceK8SResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceK8SResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceK8SResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceK8SResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceK8SResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceK8SResponseValidationError) ErrorName() string {
	return "NamespaceK8SResponseValidationError"
}

// Error satisfies the builtin error interface
func (e NamespaceK8SResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceK8SResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceK8SResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceK8SResponseValidationError{}

// Validate checks the field values on Node with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Node) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Node with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NodeMultiError, or nil if none found.
func (m *Node) ValidateAll() error {
	return m.validate(true)
}

func (m *Node) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := NodeValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := NodeValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Node_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := NodeValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return NodeMultiError(errors)
	}

	return nil
}

// NodeMultiError is an error wrapping multiple validation errors returned by
// Node.ValidateAll() if the designated constraints aren't met.
type NodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeMultiError) AllErrors() []error { return m }

// NodeValidationError is the validation error returned by Node.Validate if the
// designated constraints aren't met.
type NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeValidationError) ErrorName() string { return "NodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeValidationError{}

var _Node_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on NodeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeRequestMultiError, or
// nil if none found.
func (m *NodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := NodeRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := NodeRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_NodeRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := NodeRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for ExternalID

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOffset() < 0 {
		err := NodeRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := NodeRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NodeRequestMultiError(errors)
	}

	return nil
}

// NodeRequestMultiError is an error wrapping multiple validation errors
// returned by NodeRequest.ValidateAll() if the designated constraints aren't met.
type NodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeRequestMultiError) AllErrors() []error { return m }

// NodeRequestValidationError is the validation error returned by
// NodeRequest.Validate if the designated constraints aren't met.
type NodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeRequestValidationError) ErrorName() string { return "NodeRequestValidationError" }

// Error satisfies the builtin error interface
func (e NodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeRequestValidationError{}

var _NodeRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on NodeResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeResponseMultiError, or
// nil if none found.
func (m *NodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeResponseMultiError(errors)
	}

	return nil
}

// NodeResponseMultiError is an error wrapping multiple validation errors
// returned by NodeResponse.ValidateAll() if the designated constraints aren't met.
type NodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeResponseMultiError) AllErrors() []error { return m }

// NodeResponseValidationError is the validation error returned by
// NodeResponse.Validate if the designated constraints aren't met.
type NodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeResponseValidationError) ErrorName() string { return "NodeResponseValidationError" }

// Error satisfies the builtin error interface
func (e NodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeResponseValidationError{}

// Validate checks the field values on DaemonSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DaemonSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DaemonSet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DaemonSetMultiError, or nil
// if none found.
func (m *DaemonSet) ValidateAll() error {
	return m.validate(true)
}

func (m *DaemonSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DaemonSetValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DaemonSetValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DaemonSet_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DaemonSetValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DaemonSetValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DaemonSetValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DaemonSetValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return DaemonSetMultiError(errors)
	}

	return nil
}

// DaemonSetMultiError is an error wrapping multiple validation errors returned
// by DaemonSet.ValidateAll() if the designated constraints aren't met.
type DaemonSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DaemonSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DaemonSetMultiError) AllErrors() []error { return m }

// DaemonSetValidationError is the validation error returned by
// DaemonSet.Validate if the designated constraints aren't met.
type DaemonSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DaemonSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DaemonSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DaemonSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DaemonSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DaemonSetValidationError) ErrorName() string { return "DaemonSetValidationError" }

// Error satisfies the builtin error interface
func (e DaemonSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDaemonSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DaemonSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DaemonSetValidationError{}

var _DaemonSet_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DaemonSetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DaemonSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DaemonSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DaemonSetRequestMultiError, or nil if none found.
func (m *DaemonSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DaemonSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DaemonSetRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DaemonSetRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DaemonSetRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DaemonSetRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	// no validation rules for ResourceVersion

	// no validation rules for UID

	// no validation rules for Generation

	// no validation rules for TemplateGen

	// no validation rules for StrategyType

	if m.GetOffset() < 0 {
		err := DaemonSetRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := DaemonSetRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DaemonSetRequestMultiError(errors)
	}

	return nil
}

// DaemonSetRequestMultiError is an error wrapping multiple validation errors
// returned by DaemonSetRequest.ValidateAll() if the designated constraints
// aren't met.
type DaemonSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DaemonSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DaemonSetRequestMultiError) AllErrors() []error { return m }

// DaemonSetRequestValidationError is the validation error returned by
// DaemonSetRequest.Validate if the designated constraints aren't met.
type DaemonSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DaemonSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DaemonSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DaemonSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DaemonSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DaemonSetRequestValidationError) ErrorName() string { return "DaemonSetRequestValidationError" }

// Error satisfies the builtin error interface
func (e DaemonSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDaemonSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DaemonSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DaemonSetRequestValidationError{}

var _DaemonSetRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DaemonSetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DaemonSetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DaemonSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DaemonSetResponseMultiError, or nil if none found.
func (m *DaemonSetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DaemonSetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DaemonSetResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DaemonSetResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DaemonSetResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DaemonSetResponseMultiError(errors)
	}

	return nil
}

// DaemonSetResponseMultiError is an error wrapping multiple validation errors
// returned by DaemonSetResponse.ValidateAll() if the designated constraints
// aren't met.
type DaemonSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DaemonSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DaemonSetResponseMultiError) AllErrors() []error { return m }

// DaemonSetResponseValidationError is the validation error returned by
// DaemonSetResponse.Validate if the designated constraints aren't met.
type DaemonSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DaemonSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DaemonSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DaemonSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DaemonSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DaemonSetResponseValidationError) ErrorName() string {
	return "DaemonSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DaemonSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDaemonSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DaemonSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DaemonSetResponseValidationError{}

// Validate checks the field values on Job with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Job) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Job with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobMultiError, or nil if none found.
func (m *Job) ValidateAll() error {
	return m.validate(true)
}

func (m *Job) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := JobValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := JobValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Job_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := JobValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return JobMultiError(errors)
	}

	return nil
}

// JobMultiError is an error wrapping multiple validation errors returned by
// Job.ValidateAll() if the designated constraints aren't met.
type JobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobMultiError) AllErrors() []error { return m }

// JobValidationError is the validation error returned by Job.Validate if the
// designated constraints aren't met.
type JobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobValidationError) ErrorName() string { return "JobValidationError" }

// Error satisfies the builtin error interface
func (e JobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobValidationError{}

var _Job_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on JobRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JobRequestMultiError, or
// nil if none found.
func (m *JobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *JobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := JobRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := JobRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_JobRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := JobRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	// no validation rules for ResourceVersion

	// no validation rules for UID

	if m.GetOffset() < 0 {
		err := JobRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := JobRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return JobRequestMultiError(errors)
	}

	return nil
}

// JobRequestMultiError is an error wrapping multiple validation errors
// returned by JobRequest.ValidateAll() if the designated constraints aren't met.
type JobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobRequestMultiError) AllErrors() []error { return m }

// JobRequestValidationError is the validation error returned by
// JobRequest.Validate if the designated constraints aren't met.
type JobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobRequestValidationError) ErrorName() string { return "JobRequestValidationError" }

// Error satisfies the builtin error interface
func (e JobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobRequestValidationError{}

var _JobRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on JobResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JobResponseMultiError, or
// nil if none found.
func (m *JobResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *JobResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JobResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JobResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JobResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return JobResponseMultiError(errors)
	}

	return nil
}

// JobResponseMultiError is an error wrapping multiple validation errors
// returned by JobResponse.ValidateAll() if the designated constraints aren't met.
type JobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobResponseMultiError) AllErrors() []error { return m }

// JobResponseValidationError is the validation error returned by
// JobResponse.Validate if the designated constraints aren't met.
type JobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobResponseValidationError) ErrorName() string { return "JobResponseValidationError" }

// Error satisfies the builtin error interface
func (e JobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobResponseValidationError{}

// Validate checks the field values on StatefulSet with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatefulSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatefulSet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatefulSetMultiError, or
// nil if none found.
func (m *StatefulSet) ValidateAll() error {
	return m.validate(true)
}

func (m *StatefulSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := StatefulSetValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := StatefulSetValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_StatefulSet_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := StatefulSetValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceName

	// no validation rules for ResourceType

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatefulSetValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatefulSetValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatefulSetValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for XId

	if len(errors) > 0 {
		return StatefulSetMultiError(errors)
	}

	return nil
}

// StatefulSetMultiError is an error wrapping multiple validation errors
// returned by StatefulSet.ValidateAll() if the designated constraints aren't met.
type StatefulSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatefulSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatefulSetMultiError) AllErrors() []error { return m }

// StatefulSetValidationError is the validation error returned by
// StatefulSet.Validate if the designated constraints aren't met.
type StatefulSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatefulSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatefulSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatefulSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatefulSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatefulSetValidationError) ErrorName() string { return "StatefulSetValidationError" }

// Error satisfies the builtin error interface
func (e StatefulSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatefulSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatefulSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatefulSetValidationError{}

var _StatefulSet_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on StatefulSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatefulSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatefulSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatefulSetRequestMultiError, or nil if none found.
func (m *StatefulSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatefulSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := StatefulSetRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := StatefulSetRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_StatefulSetRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := StatefulSetRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for CreateTimeBegin

	// no validation rules for CreateTimeEnd

	// no validation rules for ResourceVersion

	// no validation rules for UID

	// no validation rules for Generation

	// no validation rules for PodMPolicy

	// no validation rules for StrategyType

	// no validation rules for ServiceName

	if m.GetOffset() < 0 {
		err := StatefulSetRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := StatefulSetRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StatefulSetRequestMultiError(errors)
	}

	return nil
}

// StatefulSetRequestMultiError is an error wrapping multiple validation errors
// returned by StatefulSetRequest.ValidateAll() if the designated constraints
// aren't met.
type StatefulSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatefulSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatefulSetRequestMultiError) AllErrors() []error { return m }

// StatefulSetRequestValidationError is the validation error returned by
// StatefulSetRequest.Validate if the designated constraints aren't met.
type StatefulSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatefulSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatefulSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatefulSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatefulSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatefulSetRequestValidationError) ErrorName() string {
	return "StatefulSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StatefulSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatefulSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatefulSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatefulSetRequestValidationError{}

var _StatefulSetRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on StatefulSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatefulSetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatefulSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatefulSetResponseMultiError, or nil if none found.
func (m *StatefulSetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StatefulSetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StatefulSetResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StatefulSetResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StatefulSetResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StatefulSetResponseMultiError(errors)
	}

	return nil
}

// StatefulSetResponseMultiError is an error wrapping multiple validation
// errors returned by StatefulSetResponse.ValidateAll() if the designated
// constraints aren't met.
type StatefulSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatefulSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatefulSetResponseMultiError) AllErrors() []error { return m }

// StatefulSetResponseValidationError is the validation error returned by
// StatefulSetResponse.Validate if the designated constraints aren't met.
type StatefulSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatefulSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatefulSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatefulSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatefulSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatefulSetResponseValidationError) ErrorName() string {
	return "StatefulSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StatefulSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatefulSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatefulSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatefulSetResponseValidationError{}

// Validate checks the field values on WatchDynamicRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchDynamicRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchDynamicRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchDynamicRequestMultiError, or nil if none found.
func (m *WatchDynamicRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchDynamicRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := WatchDynamicRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := WatchDynamicRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_WatchDynamicRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := WatchDynamicRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := WatchDynamicRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOption()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchDynamicRequestValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchDynamicRequestValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOption()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchDynamicRequestValidationError{
				field:  "Option",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchDynamicRequestMultiError(errors)
	}

	return nil
}

// WatchDynamicRequestMultiError is an error wrapping multiple validation
// errors returned by WatchDynamicRequest.ValidateAll() if the designated
// constraints aren't met.
type WatchDynamicRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchDynamicRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchDynamicRequestMultiError) AllErrors() []error { return m }

// WatchDynamicRequestValidationError is the validation error returned by
// WatchDynamicRequest.Validate if the designated constraints aren't met.
type WatchDynamicRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchDynamicRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchDynamicRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchDynamicRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchDynamicRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchDynamicRequestValidationError) ErrorName() string {
	return "WatchDynamicRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WatchDynamicRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchDynamicRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchDynamicRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchDynamicRequestValidationError{}

var _WatchDynamicRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on WatchDynamicResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchDynamicResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchDynamicResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchDynamicResponseMultiError, or nil if none found.
func (m *WatchDynamicResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchDynamicResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchDynamicResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchDynamicResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchDynamicResponseValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchDynamicResponseMultiError(errors)
	}

	return nil
}

// WatchDynamicResponseMultiError is an error wrapping multiple validation
// errors returned by WatchDynamicResponse.ValidateAll() if the designated
// constraints aren't met.
type WatchDynamicResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchDynamicResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchDynamicResponseMultiError) AllErrors() []error { return m }

// WatchDynamicResponseValidationError is the validation error returned by
// WatchDynamicResponse.Validate if the designated constraints aren't met.
type WatchDynamicResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchDynamicResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchDynamicResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchDynamicResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchDynamicResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchDynamicResponseValidationError) ErrorName() string {
	return "WatchDynamicResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WatchDynamicResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchDynamicResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchDynamicResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchDynamicResponseValidationError{}

// Validate checks the field values on WatchContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchContainerRequestMultiError, or nil if none found.
func (m *WatchContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := WatchContainerRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := WatchContainerRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_WatchContainerRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := WatchContainerRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOption()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchContainerRequestValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchContainerRequestValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOption()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchContainerRequestValidationError{
				field:  "Option",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchContainerRequestMultiError(errors)
	}

	return nil
}

// WatchContainerRequestMultiError is an error wrapping multiple validation
// errors returned by WatchContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type WatchContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchContainerRequestMultiError) AllErrors() []error { return m }

// WatchContainerRequestValidationError is the validation error returned by
// WatchContainerRequest.Validate if the designated constraints aren't met.
type WatchContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchContainerRequestValidationError) ErrorName() string {
	return "WatchContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WatchContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchContainerRequestValidationError{}

var _WatchContainerRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on WatchContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchContainerResponseMultiError, or nil if none found.
func (m *WatchContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchContainerResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchContainerResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchContainerResponseValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchContainerResponseMultiError(errors)
	}

	return nil
}

// WatchContainerResponseMultiError is an error wrapping multiple validation
// errors returned by WatchContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type WatchContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchContainerResponseMultiError) AllErrors() []error { return m }

// WatchContainerResponseValidationError is the validation error returned by
// WatchContainerResponse.Validate if the designated constraints aren't met.
type WatchContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchContainerResponseValidationError) ErrorName() string {
	return "WatchContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WatchContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchContainerResponseValidationError{}

// Validate checks the field values on EventExtraInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EventExtraInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventExtraInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EventExtraInfoMultiError,
// or nil if none found.
func (m *EventExtraInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *EventExtraInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Kind

	if len(errors) > 0 {
		return EventExtraInfoMultiError(errors)
	}

	return nil
}

// EventExtraInfoMultiError is an error wrapping multiple validation errors
// returned by EventExtraInfo.ValidateAll() if the designated constraints
// aren't met.
type EventExtraInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventExtraInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventExtraInfoMultiError) AllErrors() []error { return m }

// EventExtraInfoValidationError is the validation error returned by
// EventExtraInfo.Validate if the designated constraints aren't met.
type EventExtraInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventExtraInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventExtraInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventExtraInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventExtraInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventExtraInfoValidationError) ErrorName() string { return "EventExtraInfoValidationError" }

// Error satisfies the builtin error interface
func (e EventExtraInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventExtraInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventExtraInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventExtraInfoValidationError{}

// Validate checks the field values on BcsStorageEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BcsStorageEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BcsStorageEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BcsStorageEventMultiError, or nil if none found.
func (m *BcsStorageEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *BcsStorageEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := BcsStorageEventValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := BcsStorageEventValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BcsStorageEvent_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := BcsStorageEventValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Kind

	if all {
		switch v := interface{}(m.GetExtraInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BcsStorageEventValidationError{
					field:  "ExtraInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BcsStorageEventValidationError{
					field:  "ExtraInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtraInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BcsStorageEventValidationError{
				field:  "ExtraInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreateTime

	// no validation rules for Env

	// no validation rules for Component

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BcsStorageEventValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BcsStorageEventValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BcsStorageEventValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Level

	// no validation rules for EventTime

	// no validation rules for Describe

	// no validation rules for XId

	if len(errors) > 0 {
		return BcsStorageEventMultiError(errors)
	}

	return nil
}

// BcsStorageEventMultiError is an error wrapping multiple validation errors
// returned by BcsStorageEvent.ValidateAll() if the designated constraints
// aren't met.
type BcsStorageEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BcsStorageEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BcsStorageEventMultiError) AllErrors() []error { return m }

// BcsStorageEventValidationError is the validation error returned by
// BcsStorageEvent.Validate if the designated constraints aren't met.
type BcsStorageEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BcsStorageEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BcsStorageEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BcsStorageEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BcsStorageEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BcsStorageEventValidationError) ErrorName() string { return "BcsStorageEventValidationError" }

// Error satisfies the builtin error interface
func (e BcsStorageEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBcsStorageEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BcsStorageEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BcsStorageEventValidationError{}

var _BcsStorageEvent_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PutEventRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutEventRequestMultiError, or nil if none found.
func (m *PutEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Env

	// no validation rules for Kind

	// no validation rules for Level

	// no validation rules for Component

	// no validation rules for Type

	// no validation rules for Describe

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PutEventRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PutEventRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PutEventRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PutEventRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for EventTime

	if all {
		switch v := interface{}(m.GetExtraInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutEventRequestValidationError{
					field:  "ExtraInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutEventRequestValidationError{
					field:  "ExtraInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtraInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutEventRequestValidationError{
				field:  "ExtraInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutEventRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutEventRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutEventRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Field

	if m.GetOffset() < 0 {
		err := PutEventRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := PutEventRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PutEventRequestMultiError(errors)
	}

	return nil
}

// PutEventRequestMultiError is an error wrapping multiple validation errors
// returned by PutEventRequest.ValidateAll() if the designated constraints
// aren't met.
type PutEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutEventRequestMultiError) AllErrors() []error { return m }

// PutEventRequestValidationError is the validation error returned by
// PutEventRequest.Validate if the designated constraints aren't met.
type PutEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutEventRequestValidationError) ErrorName() string { return "PutEventRequestValidationError" }

// Error satisfies the builtin error interface
func (e PutEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutEventRequestValidationError{}

var _PutEventRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PutEventResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutEventResponseMultiError, or nil if none found.
func (m *PutEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutEventResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutEventResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutEventResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutEventResponseMultiError(errors)
	}

	return nil
}

// PutEventResponseMultiError is an error wrapping multiple validation errors
// returned by PutEventResponse.ValidateAll() if the designated constraints
// aren't met.
type PutEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutEventResponseMultiError) AllErrors() []error { return m }

// PutEventResponseValidationError is the validation error returned by
// PutEventResponse.Validate if the designated constraints aren't met.
type PutEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutEventResponseValidationError) ErrorName() string { return "PutEventResponseValidationError" }

// Error satisfies the builtin error interface
func (e PutEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutEventResponseValidationError{}

// Validate checks the field values on ListEventRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListEventRequestMultiError, or nil if none found.
func (m *ListEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Env

	// no validation rules for Kind

	// no validation rules for Level

	// no validation rules for Component

	// no validation rules for Type

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ListEventRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ListEventRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListEventRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ListEventRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetExtraInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListEventRequestValidationError{
					field:  "ExtraInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListEventRequestValidationError{
					field:  "ExtraInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtraInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListEventRequestValidationError{
				field:  "ExtraInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListEventRequestValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListEventRequestValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListEventRequestValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExtraContain()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListEventRequestValidationError{
					field:  "ExtraContain",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListEventRequestValidationError{
					field:  "ExtraContain",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtraContain()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListEventRequestValidationError{
				field:  "ExtraContain",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeBegin

	// no validation rules for TimeEnd

	if m.GetOffset() < 0 {
		err := ListEventRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLength() > 10 {
		err := ListEventRequestValidationError{
			field:  "Length",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListEventRequestMultiError(errors)
	}

	return nil
}

// ListEventRequestMultiError is an error wrapping multiple validation errors
// returned by ListEventRequest.ValidateAll() if the designated constraints
// aren't met.
type ListEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListEventRequestMultiError) AllErrors() []error { return m }

// ListEventRequestValidationError is the validation error returned by
// ListEventRequest.Validate if the designated constraints aren't met.
type ListEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEventRequestValidationError) ErrorName() string { return "ListEventRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEventRequestValidationError{}

var _ListEventRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ListEventResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListEventResponseMultiError, or nil if none found.
func (m *ListEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListEventResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListEventResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListEventResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListEventResponseValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListEventResponseValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListEventResponseValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListEventResponseMultiError(errors)
	}

	return nil
}

// ListEventResponseMultiError is an error wrapping multiple validation errors
// returned by ListEventResponse.ValidateAll() if the designated constraints
// aren't met.
type ListEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListEventResponseMultiError) AllErrors() []error { return m }

// ListEventResponseValidationError is the validation error returned by
// ListEventResponse.Validate if the designated constraints aren't met.
type ListEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEventResponseValidationError) ErrorName() string {
	return "ListEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEventResponseValidationError{}

// Validate checks the field values on StoreWatchOption with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StoreWatchOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreWatchOption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StoreWatchOptionMultiError, or nil if none found.
func (m *StoreWatchOption) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreWatchOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCond()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StoreWatchOptionValidationError{
					field:  "Cond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StoreWatchOptionValidationError{
					field:  "Cond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCond()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StoreWatchOptionValidationError{
				field:  "Cond",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SelfOnly

	// no validation rules for MaxEvents

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StoreWatchOptionValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StoreWatchOptionValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StoreWatchOptionValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MustDiff

	if len(errors) > 0 {
		return StoreWatchOptionMultiError(errors)
	}

	return nil
}

// StoreWatchOptionMultiError is an error wrapping multiple validation errors
// returned by StoreWatchOption.ValidateAll() if the designated constraints
// aren't met.
type StoreWatchOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreWatchOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreWatchOptionMultiError) AllErrors() []error { return m }

// StoreWatchOptionValidationError is the validation error returned by
// StoreWatchOption.Validate if the designated constraints aren't met.
type StoreWatchOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreWatchOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreWatchOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreWatchOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreWatchOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreWatchOptionValidationError) ErrorName() string { return "StoreWatchOptionValidationError" }

// Error satisfies the builtin error interface
func (e StoreWatchOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreWatchOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreWatchOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreWatchOptionValidationError{}

// Validate checks the field values on WatchEventRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WatchEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchEventRequestMultiError, or nil if none found.
func (m *WatchEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := WatchEventRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := WatchEventRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_WatchEventRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := WatchEventRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOption()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchEventRequestValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchEventRequestValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOption()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchEventRequestValidationError{
				field:  "Option",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchEventRequestMultiError(errors)
	}

	return nil
}

// WatchEventRequestMultiError is an error wrapping multiple validation errors
// returned by WatchEventRequest.ValidateAll() if the designated constraints
// aren't met.
type WatchEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchEventRequestMultiError) AllErrors() []error { return m }

// WatchEventRequestValidationError is the validation error returned by
// WatchEventRequest.Validate if the designated constraints aren't met.
type WatchEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchEventRequestValidationError) ErrorName() string {
	return "WatchEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WatchEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchEventRequestValidationError{}

var _WatchEventRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on WatchEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchEventResponseMultiError, or nil if none found.
func (m *WatchEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchEventResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchEventResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchEventResponseValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchEventResponseMultiError(errors)
	}

	return nil
}

// WatchEventResponseMultiError is an error wrapping multiple validation errors
// returned by WatchEventResponse.ValidateAll() if the designated constraints
// aren't met.
type WatchEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchEventResponseMultiError) AllErrors() []error { return m }

// WatchEventResponseValidationError is the validation error returned by
// WatchEventResponse.Validate if the designated constraints aren't met.
type WatchEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchEventResponseValidationError) ErrorName() string {
	return "WatchEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WatchEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchEventResponseValidationError{}

// Validate checks the field values on BcsStorageHost with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BcsStorageHost) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BcsStorageHost with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BcsStorageHostMultiError,
// or nil if none found.
func (m *BcsStorageHost) ValidateAll() error {
	return m.validate(true)
}

func (m *BcsStorageHost) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ip

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := BcsStorageHostValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := BcsStorageHostValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BcsStorageHost_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := BcsStorageHostValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BcsStorageHostValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BcsStorageHostValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BcsStorageHostValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BcsStorageHostMultiError(errors)
	}

	return nil
}

// BcsStorageHostMultiError is an error wrapping multiple validation errors
// returned by BcsStorageHost.ValidateAll() if the designated constraints
// aren't met.
type BcsStorageHostMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BcsStorageHostMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BcsStorageHostMultiError) AllErrors() []error { return m }

// BcsStorageHostValidationError is the validation error returned by
// BcsStorageHost.Validate if the designated constraints aren't met.
type BcsStorageHostValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BcsStorageHostValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BcsStorageHostValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BcsStorageHostValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BcsStorageHostValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BcsStorageHostValidationError) ErrorName() string { return "BcsStorageHostValidationError" }

// Error satisfies the builtin error interface
func (e BcsStorageHostValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBcsStorageHost.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BcsStorageHostValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BcsStorageHostValidationError{}

var _BcsStorageHost_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetHostRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetHostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetHostRequestMultiError,
// or nil if none found.
func (m *GetHostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetIp()); ip == nil {
		err := GetHostRequestValidationError{
			field:  "Ip",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetHostRequestMultiError(errors)
	}

	return nil
}

// GetHostRequestMultiError is an error wrapping multiple validation errors
// returned by GetHostRequest.ValidateAll() if the designated constraints
// aren't met.
type GetHostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHostRequestMultiError) AllErrors() []error { return m }

// GetHostRequestValidationError is the validation error returned by
// GetHostRequest.Validate if the designated constraints aren't met.
type GetHostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHostRequestValidationError) ErrorName() string { return "GetHostRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetHostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHostRequestValidationError{}

// Validate checks the field values on GetHostResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetHostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHostResponseMultiError, or nil if none found.
func (m *GetHostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetHostResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetHostResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetHostResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetHostResponseMultiError(errors)
	}

	return nil
}

// GetHostResponseMultiError is an error wrapping multiple validation errors
// returned by GetHostResponse.ValidateAll() if the designated constraints
// aren't met.
type GetHostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHostResponseMultiError) AllErrors() []error { return m }

// GetHostResponseValidationError is the validation error returned by
// GetHostResponse.Validate if the designated constraints aren't met.
type GetHostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHostResponseValidationError) ErrorName() string { return "GetHostResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetHostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHostResponseValidationError{}

// Validate checks the field values on PutHostRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PutHostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutHostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PutHostRequestMultiError,
// or nil if none found.
func (m *PutHostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutHostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetIp()); ip == nil {
		err := PutHostRequestValidationError{
			field:  "Ip",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PutHostRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PutHostRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PutHostRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PutHostRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutHostRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutHostRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutHostRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutHostRequestMultiError(errors)
	}

	return nil
}

// PutHostRequestMultiError is an error wrapping multiple validation errors
// returned by PutHostRequest.ValidateAll() if the designated constraints
// aren't met.
type PutHostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutHostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutHostRequestMultiError) AllErrors() []error { return m }

// PutHostRequestValidationError is the validation error returned by
// PutHostRequest.Validate if the designated constraints aren't met.
type PutHostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutHostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutHostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutHostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutHostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutHostRequestValidationError) ErrorName() string { return "PutHostRequestValidationError" }

// Error satisfies the builtin error interface
func (e PutHostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutHostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutHostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutHostRequestValidationError{}

var _PutHostRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PutHostResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutHostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutHostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutHostResponseMultiError, or nil if none found.
func (m *PutHostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutHostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutHostResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutHostResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutHostResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutHostResponseMultiError(errors)
	}

	return nil
}

// PutHostResponseMultiError is an error wrapping multiple validation errors
// returned by PutHostResponse.ValidateAll() if the designated constraints
// aren't met.
type PutHostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutHostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutHostResponseMultiError) AllErrors() []error { return m }

// PutHostResponseValidationError is the validation error returned by
// PutHostResponse.Validate if the designated constraints aren't met.
type PutHostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutHostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutHostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutHostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutHostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutHostResponseValidationError) ErrorName() string { return "PutHostResponseValidationError" }

// Error satisfies the builtin error interface
func (e PutHostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutHostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutHostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutHostResponseValidationError{}

// Validate checks the field values on DeleteHostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteHostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteHostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteHostRequestMultiError, or nil if none found.
func (m *DeleteHostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteHostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetIp()); ip == nil {
		err := DeleteHostRequestValidationError{
			field:  "Ip",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteHostRequestMultiError(errors)
	}

	return nil
}

// DeleteHostRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteHostRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteHostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteHostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteHostRequestMultiError) AllErrors() []error { return m }

// DeleteHostRequestValidationError is the validation error returned by
// DeleteHostRequest.Validate if the designated constraints aren't met.
type DeleteHostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteHostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteHostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteHostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteHostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteHostRequestValidationError) ErrorName() string {
	return "DeleteHostRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteHostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteHostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteHostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteHostRequestValidationError{}

// Validate checks the field values on DeleteHostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteHostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteHostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteHostResponseMultiError, or nil if none found.
func (m *DeleteHostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteHostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteHostResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteHostResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteHostResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteHostResponseMultiError(errors)
	}

	return nil
}

// DeleteHostResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteHostResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteHostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteHostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteHostResponseMultiError) AllErrors() []error { return m }

// DeleteHostResponseValidationError is the validation error returned by
// DeleteHostResponse.Validate if the designated constraints aren't met.
type DeleteHostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteHostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteHostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteHostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteHostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteHostResponseValidationError) ErrorName() string {
	return "DeleteHostResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteHostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteHostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteHostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteHostResponseValidationError{}

// Validate checks the field values on ListHostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListHostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListHostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListHostRequestMultiError, or nil if none found.
func (m *ListHostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := ListHostRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := ListHostRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListHostRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := ListHostRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListHostRequestMultiError(errors)
	}

	return nil
}

// ListHostRequestMultiError is an error wrapping multiple validation errors
// returned by ListHostRequest.ValidateAll() if the designated constraints
// aren't met.
type ListHostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHostRequestMultiError) AllErrors() []error { return m }

// ListHostRequestValidationError is the validation error returned by
// ListHostRequest.Validate if the designated constraints aren't met.
type ListHostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHostRequestValidationError) ErrorName() string { return "ListHostRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListHostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHostRequestValidationError{}

var _ListHostRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ListHostResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListHostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListHostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListHostResponseMultiError, or nil if none found.
func (m *ListHostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListHostResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListHostResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListHostResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListHostResponseMultiError(errors)
	}

	return nil
}

// ListHostResponseMultiError is an error wrapping multiple validation errors
// returned by ListHostResponse.ValidateAll() if the designated constraints
// aren't met.
type ListHostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHostResponseMultiError) AllErrors() []error { return m }

// ListHostResponseValidationError is the validation error returned by
// ListHostResponse.Validate if the designated constraints aren't met.
type ListHostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHostResponseValidationError) ErrorName() string { return "ListHostResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListHostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHostResponseValidationError{}

// Validate checks the field values on PutClusterRelationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutClusterRelationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutClusterRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutClusterRelationRequestMultiError, or nil if none found.
func (m *PutClusterRelationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutClusterRelationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PutClusterRelationRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PutClusterRelationRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PutClusterRelationRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PutClusterRelationRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetIps()) < 1 {
		err := PutClusterRelationRequestValidationError{
			field:  "Ips",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PutClusterRelationRequestMultiError(errors)
	}

	return nil
}

// PutClusterRelationRequestMultiError is an error wrapping multiple validation
// errors returned by PutClusterRelationRequest.ValidateAll() if the
// designated constraints aren't met.
type PutClusterRelationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutClusterRelationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutClusterRelationRequestMultiError) AllErrors() []error { return m }

// PutClusterRelationRequestValidationError is the validation error returned by
// PutClusterRelationRequest.Validate if the designated constraints aren't met.
type PutClusterRelationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutClusterRelationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutClusterRelationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutClusterRelationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutClusterRelationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutClusterRelationRequestValidationError) ErrorName() string {
	return "PutClusterRelationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutClusterRelationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutClusterRelationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutClusterRelationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutClusterRelationRequestValidationError{}

var _PutClusterRelationRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PutClusterRelationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutClusterRelationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutClusterRelationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutClusterRelationResponseMultiError, or nil if none found.
func (m *PutClusterRelationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutClusterRelationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutClusterRelationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutClusterRelationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutClusterRelationResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutClusterRelationResponseMultiError(errors)
	}

	return nil
}

// PutClusterRelationResponseMultiError is an error wrapping multiple
// validation errors returned by PutClusterRelationResponse.ValidateAll() if
// the designated constraints aren't met.
type PutClusterRelationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutClusterRelationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutClusterRelationResponseMultiError) AllErrors() []error { return m }

// PutClusterRelationResponseValidationError is the validation error returned
// by PutClusterRelationResponse.Validate if the designated constraints aren't met.
type PutClusterRelationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutClusterRelationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutClusterRelationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutClusterRelationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutClusterRelationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutClusterRelationResponseValidationError) ErrorName() string {
	return "PutClusterRelationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutClusterRelationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutClusterRelationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutClusterRelationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutClusterRelationResponseValidationError{}

// Validate checks the field values on PostClusterRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostClusterRelationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostClusterRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostClusterRelationRequestMultiError, or nil if none found.
func (m *PostClusterRelationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PostClusterRelationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PostClusterRelationRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PostClusterRelationRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PostClusterRelationRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PostClusterRelationRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetIps()) < 1 {
		err := PostClusterRelationRequestValidationError{
			field:  "Ips",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PostClusterRelationRequestMultiError(errors)
	}

	return nil
}

// PostClusterRelationRequestMultiError is an error wrapping multiple
// validation errors returned by PostClusterRelationRequest.ValidateAll() if
// the designated constraints aren't met.
type PostClusterRelationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostClusterRelationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostClusterRelationRequestMultiError) AllErrors() []error { return m }

// PostClusterRelationRequestValidationError is the validation error returned
// by PostClusterRelationRequest.Validate if the designated constraints aren't met.
type PostClusterRelationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostClusterRelationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostClusterRelationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostClusterRelationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostClusterRelationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostClusterRelationRequestValidationError) ErrorName() string {
	return "PostClusterRelationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PostClusterRelationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostClusterRelationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostClusterRelationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostClusterRelationRequestValidationError{}

var _PostClusterRelationRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PostClusterRelationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostClusterRelationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostClusterRelationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostClusterRelationResponseMultiError, or nil if none found.
func (m *PostClusterRelationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PostClusterRelationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostClusterRelationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostClusterRelationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostClusterRelationResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PostClusterRelationResponseMultiError(errors)
	}

	return nil
}

// PostClusterRelationResponseMultiError is an error wrapping multiple
// validation errors returned by PostClusterRelationResponse.ValidateAll() if
// the designated constraints aren't met.
type PostClusterRelationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostClusterRelationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostClusterRelationResponseMultiError) AllErrors() []error { return m }

// PostClusterRelationResponseValidationError is the validation error returned
// by PostClusterRelationResponse.Validate if the designated constraints
// aren't met.
type PostClusterRelationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostClusterRelationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostClusterRelationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostClusterRelationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostClusterRelationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostClusterRelationResponseValidationError) ErrorName() string {
	return "PostClusterRelationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PostClusterRelationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostClusterRelationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostClusterRelationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostClusterRelationResponseValidationError{}

// Validate checks the field values on Metric with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metric) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metric with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MetricMultiError, or nil if none found.
func (m *Metric) ValidateAll() error {
	return m.validate(true)
}

func (m *Metric) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := MetricValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := MetricValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Metric_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := MetricValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for Type

	// no validation rules for Name

	if len(errors) > 0 {
		return MetricMultiError(errors)
	}

	return nil
}

// MetricMultiError is an error wrapping multiple validation errors returned by
// Metric.ValidateAll() if the designated constraints aren't met.
type MetricMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricMultiError) AllErrors() []error { return m }

// MetricValidationError is the validation error returned by Metric.Validate if
// the designated constraints aren't met.
type MetricValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricValidationError) ErrorName() string { return "MetricValidationError" }

// Error satisfies the builtin error interface
func (e MetricValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetric.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricValidationError{}

var _Metric_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetMetricRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetMetricRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMetricRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMetricRequestMultiError, or nil if none found.
func (m *GetMetricRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMetricRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := GetMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := GetMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetMetricRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := GetMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := GetMetricRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := GetMetricRequestValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetMetricRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	if m.GetOffset() < 0 {
		err := GetMetricRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := GetMetricRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMetricRequestMultiError(errors)
	}

	return nil
}

// GetMetricRequestMultiError is an error wrapping multiple validation errors
// returned by GetMetricRequest.ValidateAll() if the designated constraints
// aren't met.
type GetMetricRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMetricRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMetricRequestMultiError) AllErrors() []error { return m }

// GetMetricRequestValidationError is the validation error returned by
// GetMetricRequest.Validate if the designated constraints aren't met.
type GetMetricRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMetricRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMetricRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMetricRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMetricRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMetricRequestValidationError) ErrorName() string { return "GetMetricRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetMetricRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMetricRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMetricRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMetricRequestValidationError{}

var _GetMetricRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on GetMetricResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetMetricResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMetricResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMetricResponseMultiError, or nil if none found.
func (m *GetMetricResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMetricResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetMetricResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetMetricResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetMetricResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetMetricResponseMultiError(errors)
	}

	return nil
}

// GetMetricResponseMultiError is an error wrapping multiple validation errors
// returned by GetMetricResponse.ValidateAll() if the designated constraints
// aren't met.
type GetMetricResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMetricResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMetricResponseMultiError) AllErrors() []error { return m }

// GetMetricResponseValidationError is the validation error returned by
// GetMetricResponse.Validate if the designated constraints aren't met.
type GetMetricResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMetricResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMetricResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMetricResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMetricResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMetricResponseValidationError) ErrorName() string {
	return "GetMetricResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMetricResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMetricResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMetricResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMetricResponseValidationError{}

// Validate checks the field values on PutMetricRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutMetricRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutMetricRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutMetricRequestMultiError, or nil if none found.
func (m *PutMetricRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutMetricRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := PutMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := PutMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PutMetricRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := PutMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := PutMetricRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := PutMetricRequestValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := PutMetricRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extra

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutMetricRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutMetricRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutMetricRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutMetricRequestMultiError(errors)
	}

	return nil
}

// PutMetricRequestMultiError is an error wrapping multiple validation errors
// returned by PutMetricRequest.ValidateAll() if the designated constraints
// aren't met.
type PutMetricRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutMetricRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutMetricRequestMultiError) AllErrors() []error { return m }

// PutMetricRequestValidationError is the validation error returned by
// PutMetricRequest.Validate if the designated constraints aren't met.
type PutMetricRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutMetricRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutMetricRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutMetricRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutMetricRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutMetricRequestValidationError) ErrorName() string { return "PutMetricRequestValidationError" }

// Error satisfies the builtin error interface
func (e PutMetricRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutMetricRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutMetricRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutMetricRequestValidationError{}

var _PutMetricRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on PutMetricResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutMetricResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutMetricResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutMetricResponseMultiError, or nil if none found.
func (m *PutMetricResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutMetricResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutMetricResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutMetricResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutMetricResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutMetricResponseMultiError(errors)
	}

	return nil
}

// PutMetricResponseMultiError is an error wrapping multiple validation errors
// returned by PutMetricResponse.ValidateAll() if the designated constraints
// aren't met.
type PutMetricResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutMetricResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutMetricResponseMultiError) AllErrors() []error { return m }

// PutMetricResponseValidationError is the validation error returned by
// PutMetricResponse.Validate if the designated constraints aren't met.
type PutMetricResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutMetricResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutMetricResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutMetricResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutMetricResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutMetricResponseValidationError) ErrorName() string {
	return "PutMetricResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutMetricResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutMetricResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutMetricResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutMetricResponseValidationError{}

// Validate checks the field values on DeleteMetricRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMetricRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMetricRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMetricRequestMultiError, or nil if none found.
func (m *DeleteMetricRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMetricRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := DeleteMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := DeleteMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteMetricRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := DeleteMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := DeleteMetricRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := DeleteMetricRequestValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DeleteMetricRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteMetricRequestMultiError(errors)
	}

	return nil
}

// DeleteMetricRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteMetricRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteMetricRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMetricRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMetricRequestMultiError) AllErrors() []error { return m }

// DeleteMetricRequestValidationError is the validation error returned by
// DeleteMetricRequest.Validate if the designated constraints aren't met.
type DeleteMetricRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMetricRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMetricRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMetricRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMetricRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMetricRequestValidationError) ErrorName() string {
	return "DeleteMetricRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMetricRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMetricRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMetricRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMetricRequestValidationError{}

var _DeleteMetricRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteMetricResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMetricResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMetricResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMetricResponseMultiError, or nil if none found.
func (m *DeleteMetricResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMetricResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteMetricResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteMetricResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteMetricResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteMetricResponseMultiError(errors)
	}

	return nil
}

// DeleteMetricResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteMetricResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteMetricResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMetricResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMetricResponseMultiError) AllErrors() []error { return m }

// DeleteMetricResponseValidationError is the validation error returned by
// DeleteMetricResponse.Validate if the designated constraints aren't met.
type DeleteMetricResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMetricResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMetricResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMetricResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMetricResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMetricResponseValidationError) ErrorName() string {
	return "DeleteMetricResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMetricResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMetricResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMetricResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMetricResponseValidationError{}

// Validate checks the field values on QueryMetricRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryMetricRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryMetricRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryMetricRequestMultiError, or nil if none found.
func (m *QueryMetricRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryMetricRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := QueryMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := QueryMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_QueryMetricRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := QueryMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Extra

	if m.GetOffset() < 0 {
		err := QueryMetricRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() > 10 {
		err := QueryMetricRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 10",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QueryMetricRequestMultiError(errors)
	}

	return nil
}

// QueryMetricRequestMultiError is an error wrapping multiple validation errors
// returned by QueryMetricRequest.ValidateAll() if the designated constraints
// aren't met.
type QueryMetricRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMetricRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMetricRequestMultiError) AllErrors() []error { return m }

// QueryMetricRequestValidationError is the validation error returned by
// QueryMetricRequest.Validate if the designated constraints aren't met.
type QueryMetricRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryMetricRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryMetricRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryMetricRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryMetricRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryMetricRequestValidationError) ErrorName() string {
	return "QueryMetricRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryMetricRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryMetricRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryMetricRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryMetricRequestValidationError{}

var _QueryMetricRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on QueryMetricResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryMetricResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryMetricResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryMetricResponseMultiError, or nil if none found.
func (m *QueryMetricResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryMetricResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryMetricResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryMetricResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryMetricResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryMetricResponseMultiError(errors)
	}

	return nil
}

// QueryMetricResponseMultiError is an error wrapping multiple validation
// errors returned by QueryMetricResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryMetricResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMetricResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMetricResponseMultiError) AllErrors() []error { return m }

// QueryMetricResponseValidationError is the validation error returned by
// QueryMetricResponse.Validate if the designated constraints aren't met.
type QueryMetricResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryMetricResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryMetricResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryMetricResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryMetricResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryMetricResponseValidationError) ErrorName() string {
	return "QueryMetricResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryMetricResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryMetricResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryMetricResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryMetricResponseValidationError{}

// Validate checks the field values on ListMetricTablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMetricTablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetricTablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMetricTablesRequestMultiError, or nil if none found.
func (m *ListMetricTablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetricTablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListMetricTablesRequestMultiError(errors)
	}

	return nil
}

// ListMetricTablesRequestMultiError is an error wrapping multiple validation
// errors returned by ListMetricTablesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListMetricTablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetricTablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetricTablesRequestMultiError) AllErrors() []error { return m }

// ListMetricTablesRequestValidationError is the validation error returned by
// ListMetricTablesRequest.Validate if the designated constraints aren't met.
type ListMetricTablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetricTablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetricTablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetricTablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetricTablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetricTablesRequestValidationError) ErrorName() string {
	return "ListMetricTablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMetricTablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetricTablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetricTablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetricTablesRequestValidationError{}

// Validate checks the field values on ListMetricTablesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMetricTablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetricTablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMetricTablesResponseMultiError, or nil if none found.
func (m *ListMetricTablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetricTablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return ListMetricTablesResponseMultiError(errors)
	}

	return nil
}

// ListMetricTablesResponseMultiError is an error wrapping multiple validation
// errors returned by ListMetricTablesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListMetricTablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetricTablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetricTablesResponseMultiError) AllErrors() []error { return m }

// ListMetricTablesResponseValidationError is the validation error returned by
// ListMetricTablesResponse.Validate if the designated constraints aren't met.
type ListMetricTablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetricTablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetricTablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetricTablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetricTablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetricTablesResponseValidationError) ErrorName() string {
	return "ListMetricTablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMetricTablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetricTablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetricTablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetricTablesResponseValidationError{}

// Validate checks the field values on WatchMetricRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchMetricRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchMetricRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchMetricRequestMultiError, or nil if none found.
func (m *WatchMetricRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchMetricRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := WatchMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := WatchMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_WatchMetricRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := WatchMetricRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := WatchMetricRequestValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOption()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchMetricRequestValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchMetricRequestValidationError{
					field:  "Option",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOption()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchMetricRequestValidationError{
				field:  "Option",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchMetricRequestMultiError(errors)
	}

	return nil
}

// WatchMetricRequestMultiError is an error wrapping multiple validation errors
// returned by WatchMetricRequest.ValidateAll() if the designated constraints
// aren't met.
type WatchMetricRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchMetricRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchMetricRequestMultiError) AllErrors() []error { return m }

// WatchMetricRequestValidationError is the validation error returned by
// WatchMetricRequest.Validate if the designated constraints aren't met.
type WatchMetricRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchMetricRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchMetricRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchMetricRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchMetricRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchMetricRequestValidationError) ErrorName() string {
	return "WatchMetricRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WatchMetricRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchMetricRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchMetricRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchMetricRequestValidationError{}

var _WatchMetricRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on WatchMetricResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchMetricResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchMetricResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchMetricResponseMultiError, or nil if none found.
func (m *WatchMetricResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchMetricResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchMetricResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchMetricResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchMetricResponseValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchMetricResponseMultiError(errors)
	}

	return nil
}

// WatchMetricResponseMultiError is an error wrapping multiple validation
// errors returned by WatchMetricResponse.ValidateAll() if the designated
// constraints aren't met.
type WatchMetricResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchMetricResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchMetricResponseMultiError) AllErrors() []error { return m }

// WatchMetricResponseValidationError is the validation error returned by
// WatchMetricResponse.Validate if the designated constraints aren't met.
type WatchMetricResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchMetricResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchMetricResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchMetricResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchMetricResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchMetricResponseValidationError) ErrorName() string {
	return "WatchMetricResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WatchMetricResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchMetricResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchMetricResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchMetricResponseValidationError{}

// Validate checks the field values on WatchResource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WatchResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchResource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WatchResourceMultiError, or
// nil if none found.
func (m *WatchResource) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := WatchResourceValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := WatchResourceValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_WatchResource_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := WatchResourceValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for ResourceType

	// no validation rules for ResourceName

	if len(errors) > 0 {
		return WatchResourceMultiError(errors)
	}

	return nil
}

// WatchResourceMultiError is an error wrapping multiple validation errors
// returned by WatchResource.ValidateAll() if the designated constraints
// aren't met.
type WatchResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchResourceMultiError) AllErrors() []error { return m }

// WatchResourceValidationError is the validation error returned by
// WatchResource.Validate if the designated constraints aren't met.
type WatchResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchResourceValidationError) ErrorName() string { return "WatchResourceValidationError" }

// Error satisfies the builtin error interface
func (e WatchResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchResourceValidationError{}

var _WatchResource_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on K8SGetWatchResourceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SGetWatchResourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SGetWatchResourceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// K8SGetWatchResourceRequestMultiError, or nil if none found.
func (m *K8SGetWatchResourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SGetWatchResourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := K8SGetWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := K8SGetWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_K8SGetWatchResourceRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := K8SGetWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := K8SGetWatchResourceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := K8SGetWatchResourceRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := K8SGetWatchResourceRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return K8SGetWatchResourceRequestMultiError(errors)
	}

	return nil
}

// K8SGetWatchResourceRequestMultiError is an error wrapping multiple
// validation errors returned by K8SGetWatchResourceRequest.ValidateAll() if
// the designated constraints aren't met.
type K8SGetWatchResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SGetWatchResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SGetWatchResourceRequestMultiError) AllErrors() []error { return m }

// K8SGetWatchResourceRequestValidationError is the validation error returned
// by K8SGetWatchResourceRequest.Validate if the designated constraints aren't met.
type K8SGetWatchResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SGetWatchResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SGetWatchResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SGetWatchResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SGetWatchResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SGetWatchResourceRequestValidationError) ErrorName() string {
	return "K8SGetWatchResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e K8SGetWatchResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SGetWatchResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SGetWatchResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SGetWatchResourceRequestValidationError{}

var _K8SGetWatchResourceRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on K8SGetWatchResourceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SGetWatchResourceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SGetWatchResourceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// K8SGetWatchResourceResponseMultiError, or nil if none found.
func (m *K8SGetWatchResourceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SGetWatchResourceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, K8SGetWatchResourceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, K8SGetWatchResourceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return K8SGetWatchResourceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return K8SGetWatchResourceResponseMultiError(errors)
	}

	return nil
}

// K8SGetWatchResourceResponseMultiError is an error wrapping multiple
// validation errors returned by K8SGetWatchResourceResponse.ValidateAll() if
// the designated constraints aren't met.
type K8SGetWatchResourceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SGetWatchResourceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SGetWatchResourceResponseMultiError) AllErrors() []error { return m }

// K8SGetWatchResourceResponseValidationError is the validation error returned
// by K8SGetWatchResourceResponse.Validate if the designated constraints
// aren't met.
type K8SGetWatchResourceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SGetWatchResourceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SGetWatchResourceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SGetWatchResourceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SGetWatchResourceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SGetWatchResourceResponseValidationError) ErrorName() string {
	return "K8SGetWatchResourceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e K8SGetWatchResourceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SGetWatchResourceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SGetWatchResourceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SGetWatchResourceResponseValidationError{}

// Validate checks the field values on K8SPutWatchResourceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SPutWatchResourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SPutWatchResourceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// K8SPutWatchResourceRequestMultiError, or nil if none found.
func (m *K8SPutWatchResourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SPutWatchResourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := K8SPutWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := K8SPutWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_K8SPutWatchResourceRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := K8SPutWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := K8SPutWatchResourceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := K8SPutWatchResourceRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := K8SPutWatchResourceRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, K8SPutWatchResourceRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, K8SPutWatchResourceRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return K8SPutWatchResourceRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return K8SPutWatchResourceRequestMultiError(errors)
	}

	return nil
}

// K8SPutWatchResourceRequestMultiError is an error wrapping multiple
// validation errors returned by K8SPutWatchResourceRequest.ValidateAll() if
// the designated constraints aren't met.
type K8SPutWatchResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SPutWatchResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SPutWatchResourceRequestMultiError) AllErrors() []error { return m }

// K8SPutWatchResourceRequestValidationError is the validation error returned
// by K8SPutWatchResourceRequest.Validate if the designated constraints aren't met.
type K8SPutWatchResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SPutWatchResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SPutWatchResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SPutWatchResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SPutWatchResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SPutWatchResourceRequestValidationError) ErrorName() string {
	return "K8SPutWatchResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e K8SPutWatchResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SPutWatchResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SPutWatchResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SPutWatchResourceRequestValidationError{}

var _K8SPutWatchResourceRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on K8SPutWatchResourceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SPutWatchResourceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SPutWatchResourceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// K8SPutWatchResourceResponseMultiError, or nil if none found.
func (m *K8SPutWatchResourceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SPutWatchResourceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, K8SPutWatchResourceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, K8SPutWatchResourceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return K8SPutWatchResourceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return K8SPutWatchResourceResponseMultiError(errors)
	}

	return nil
}

// K8SPutWatchResourceResponseMultiError is an error wrapping multiple
// validation errors returned by K8SPutWatchResourceResponse.ValidateAll() if
// the designated constraints aren't met.
type K8SPutWatchResourceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SPutWatchResourceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SPutWatchResourceResponseMultiError) AllErrors() []error { return m }

// K8SPutWatchResourceResponseValidationError is the validation error returned
// by K8SPutWatchResourceResponse.Validate if the designated constraints
// aren't met.
type K8SPutWatchResourceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SPutWatchResourceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SPutWatchResourceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SPutWatchResourceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SPutWatchResourceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SPutWatchResourceResponseValidationError) ErrorName() string {
	return "K8SPutWatchResourceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e K8SPutWatchResourceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SPutWatchResourceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SPutWatchResourceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SPutWatchResourceResponseValidationError{}

// Validate checks the field values on K8SDeleteWatchResourceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SDeleteWatchResourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SDeleteWatchResourceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// K8SDeleteWatchResourceRequestMultiError, or nil if none found.
func (m *K8SDeleteWatchResourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SDeleteWatchResourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := K8SDeleteWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := K8SDeleteWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_K8SDeleteWatchResourceRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := K8SDeleteWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := K8SDeleteWatchResourceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := K8SDeleteWatchResourceRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceName()) < 1 {
		err := K8SDeleteWatchResourceRequestValidationError{
			field:  "ResourceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return K8SDeleteWatchResourceRequestMultiError(errors)
	}

	return nil
}

// K8SDeleteWatchResourceRequestMultiError is an error wrapping multiple
// validation errors returned by K8SDeleteWatchResourceRequest.ValidateAll()
// if the designated constraints aren't met.
type K8SDeleteWatchResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SDeleteWatchResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SDeleteWatchResourceRequestMultiError) AllErrors() []error { return m }

// K8SDeleteWatchResourceRequestValidationError is the validation error
// returned by K8SDeleteWatchResourceRequest.Validate if the designated
// constraints aren't met.
type K8SDeleteWatchResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SDeleteWatchResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SDeleteWatchResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SDeleteWatchResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SDeleteWatchResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SDeleteWatchResourceRequestValidationError) ErrorName() string {
	return "K8SDeleteWatchResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e K8SDeleteWatchResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SDeleteWatchResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SDeleteWatchResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SDeleteWatchResourceRequestValidationError{}

var _K8SDeleteWatchResourceRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on K8SDeleteWatchResourceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SDeleteWatchResourceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SDeleteWatchResourceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// K8SDeleteWatchResourceResponseMultiError, or nil if none found.
func (m *K8SDeleteWatchResourceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SDeleteWatchResourceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, K8SDeleteWatchResourceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, K8SDeleteWatchResourceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return K8SDeleteWatchResourceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return K8SDeleteWatchResourceResponseMultiError(errors)
	}

	return nil
}

// K8SDeleteWatchResourceResponseMultiError is an error wrapping multiple
// validation errors returned by K8SDeleteWatchResourceResponse.ValidateAll()
// if the designated constraints aren't met.
type K8SDeleteWatchResourceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SDeleteWatchResourceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SDeleteWatchResourceResponseMultiError) AllErrors() []error { return m }

// K8SDeleteWatchResourceResponseValidationError is the validation error
// returned by K8SDeleteWatchResourceResponse.Validate if the designated
// constraints aren't met.
type K8SDeleteWatchResourceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SDeleteWatchResourceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SDeleteWatchResourceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SDeleteWatchResourceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SDeleteWatchResourceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SDeleteWatchResourceResponseValidationError) ErrorName() string {
	return "K8SDeleteWatchResourceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e K8SDeleteWatchResourceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SDeleteWatchResourceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SDeleteWatchResourceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SDeleteWatchResourceResponseValidationError{}

// Validate checks the field values on K8SListWatchResourceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SListWatchResourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SListWatchResourceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// K8SListWatchResourceRequestMultiError, or nil if none found.
func (m *K8SListWatchResourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SListWatchResourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 2 || l > 100 {
		err := K8SListWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 2 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasPrefix(m.GetClusterId(), "BCS-") {
		err := K8SListWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not have prefix \"BCS-\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_K8SListWatchResourceRequest_ClusterId_Pattern.MatchString(m.GetClusterId()) {
		err := K8SListWatchResourceRequestValidationError{
			field:  "ClusterId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := K8SListWatchResourceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceType()) < 1 {
		err := K8SListWatchResourceRequestValidationError{
			field:  "ResourceType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return K8SListWatchResourceRequestMultiError(errors)
	}

	return nil
}

// K8SListWatchResourceRequestMultiError is an error wrapping multiple
// validation errors returned by K8SListWatchResourceRequest.ValidateAll() if
// the designated constraints aren't met.
type K8SListWatchResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SListWatchResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SListWatchResourceRequestMultiError) AllErrors() []error { return m }

// K8SListWatchResourceRequestValidationError is the validation error returned
// by K8SListWatchResourceRequest.Validate if the designated constraints
// aren't met.
type K8SListWatchResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SListWatchResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SListWatchResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SListWatchResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SListWatchResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SListWatchResourceRequestValidationError) ErrorName() string {
	return "K8SListWatchResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e K8SListWatchResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SListWatchResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SListWatchResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SListWatchResourceRequestValidationError{}

var _K8SListWatchResourceRequest_ClusterId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on K8SListWatchResourceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SListWatchResourceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SListWatchResourceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// K8SListWatchResourceResponseMultiError, or nil if none found.
func (m *K8SListWatchResourceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SListWatchResourceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return K8SListWatchResourceResponseMultiError(errors)
	}

	return nil
}

// K8SListWatchResourceResponseMultiError is an error wrapping multiple
// validation errors returned by K8SListWatchResourceResponse.ValidateAll() if
// the designated constraints aren't met.
type K8SListWatchResourceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SListWatchResourceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SListWatchResourceResponseMultiError) AllErrors() []error { return m }

// K8SListWatchResourceResponseValidationError is the validation error returned
// by K8SListWatchResourceResponse.Validate if the designated constraints
// aren't met.
type K8SListWatchResourceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SListWatchResourceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SListWatchResourceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SListWatchResourceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SListWatchResourceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SListWatchResourceResponseValidationError) ErrorName() string {
	return "K8SListWatchResourceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e K8SListWatchResourceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SListWatchResourceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SListWatchResourceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SListWatchResourceResponseValidationError{}
