// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: bcs-helm-manager.proto

package helmmanager

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AvailableReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AvailableReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvailableReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailableReqMultiError, or
// nil if none found.
func (m *AvailableReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AvailableReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AvailableReqMultiError(errors)
	}

	return nil
}

// AvailableReqMultiError is an error wrapping multiple validation errors
// returned by AvailableReq.ValidateAll() if the designated constraints aren't met.
type AvailableReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailableReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailableReqMultiError) AllErrors() []error { return m }

// AvailableReqValidationError is the validation error returned by
// AvailableReq.Validate if the designated constraints aren't met.
type AvailableReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailableReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailableReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailableReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailableReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailableReqValidationError) ErrorName() string { return "AvailableReqValidationError" }

// Error satisfies the builtin error interface
func (e AvailableReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailableReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailableReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailableReqValidationError{}

// Validate checks the field values on AvailableResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AvailableResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvailableResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailableRespMultiError, or
// nil if none found.
func (m *AvailableResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AvailableResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return AvailableRespMultiError(errors)
	}

	return nil
}

// AvailableRespMultiError is an error wrapping multiple validation errors
// returned by AvailableResp.ValidateAll() if the designated constraints
// aren't met.
type AvailableRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailableRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailableRespMultiError) AllErrors() []error { return m }

// AvailableRespValidationError is the validation error returned by
// AvailableResp.Validate if the designated constraints aren't met.
type AvailableRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailableRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailableRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailableRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailableRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailableRespValidationError) ErrorName() string { return "AvailableRespValidationError" }

// Error satisfies the builtin error interface
func (e AvailableRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailableResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailableRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailableRespValidationError{}

// Validate checks the field values on CreateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryReqMultiError, or nil if none found.
func (m *CreateRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := CreateRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := CreateRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	// no validation rules for Takeover

	// no validation rules for RepoURL

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for RemoteUsername

	// no validation rules for RemotePassword

	// no validation rules for DisplayName

	if len(errors) > 0 {
		return CreateRepositoryReqMultiError(errors)
	}

	return nil
}

// CreateRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by CreateRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type CreateRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryReqMultiError) AllErrors() []error { return m }

// CreateRepositoryReqValidationError is the validation error returned by
// CreateRepositoryReq.Validate if the designated constraints aren't met.
type CreateRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryReqValidationError) ErrorName() string {
	return "CreateRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryReqValidationError{}

// Validate checks the field values on CreateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryRespMultiError, or nil if none found.
func (m *CreateRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return CreateRepositoryRespMultiError(errors)
	}

	return nil
}

// CreateRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by CreateRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type CreateRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryRespMultiError) AllErrors() []error { return m }

// CreateRepositoryRespValidationError is the validation error returned by
// CreateRepositoryResp.Validate if the designated constraints aren't met.
type CreateRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryRespValidationError) ErrorName() string {
	return "CreateRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryRespValidationError{}

// Validate checks the field values on UpdateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRepositoryReqMultiError, or nil if none found.
func (m *UpdateRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UpdateRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := UpdateRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return UpdateRepositoryReqMultiError(errors)
	}

	return nil
}

// UpdateRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by UpdateRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryReqMultiError) AllErrors() []error { return m }

// UpdateRepositoryReqValidationError is the validation error returned by
// UpdateRepositoryReq.Validate if the designated constraints aren't met.
type UpdateRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryReqValidationError) ErrorName() string {
	return "UpdateRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryReqValidationError{}

// Validate checks the field values on UpdateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRepositoryRespMultiError, or nil if none found.
func (m *UpdateRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UpdateRepositoryRespMultiError(errors)
	}

	return nil
}

// UpdateRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by UpdateRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type UpdateRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryRespMultiError) AllErrors() []error { return m }

// UpdateRepositoryRespValidationError is the validation error returned by
// UpdateRepositoryResp.Validate if the designated constraints aren't met.
type UpdateRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryRespValidationError) ErrorName() string {
	return "UpdateRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryRespValidationError{}

// Validate checks the field values on GetRepositoryReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryReqMultiError, or nil if none found.
func (m *GetRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := GetRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRepositoryReqMultiError(errors)
	}

	return nil
}

// GetRepositoryReqMultiError is an error wrapping multiple validation errors
// returned by GetRepositoryReq.ValidateAll() if the designated constraints
// aren't met.
type GetRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryReqMultiError) AllErrors() []error { return m }

// GetRepositoryReqValidationError is the validation error returned by
// GetRepositoryReq.Validate if the designated constraints aren't met.
type GetRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryReqValidationError) ErrorName() string { return "GetRepositoryReqValidationError" }

// Error satisfies the builtin error interface
func (e GetRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryReqValidationError{}

// Validate checks the field values on GetRepositoryResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryRespMultiError, or nil if none found.
func (m *GetRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetRepositoryRespMultiError(errors)
	}

	return nil
}

// GetRepositoryRespMultiError is an error wrapping multiple validation errors
// returned by GetRepositoryResp.ValidateAll() if the designated constraints
// aren't met.
type GetRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryRespMultiError) AllErrors() []error { return m }

// GetRepositoryRespValidationError is the validation error returned by
// GetRepositoryResp.Validate if the designated constraints aren't met.
type GetRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryRespValidationError) ErrorName() string {
	return "GetRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryRespValidationError{}

// Validate checks the field values on ListRepositoryReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryReqMultiError, or nil if none found.
func (m *ListRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRepositoryReqMultiError(errors)
	}

	return nil
}

// ListRepositoryReqMultiError is an error wrapping multiple validation errors
// returned by ListRepositoryReq.ValidateAll() if the designated constraints
// aren't met.
type ListRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryReqMultiError) AllErrors() []error { return m }

// ListRepositoryReqValidationError is the validation error returned by
// ListRepositoryReq.Validate if the designated constraints aren't met.
type ListRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryReqValidationError) ErrorName() string {
	return "ListRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryReqValidationError{}

// Validate checks the field values on ListRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryRespMultiError, or nil if none found.
func (m *ListRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRepositoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRepositoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRepositoryRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListRepositoryRespMultiError(errors)
	}

	return nil
}

// ListRepositoryRespMultiError is an error wrapping multiple validation errors
// returned by ListRepositoryResp.ValidateAll() if the designated constraints
// aren't met.
type ListRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryRespMultiError) AllErrors() []error { return m }

// ListRepositoryRespValidationError is the validation error returned by
// ListRepositoryResp.Validate if the designated constraints aren't met.
type ListRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryRespValidationError) ErrorName() string {
	return "ListRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryRespValidationError{}

// Validate checks the field values on DeleteRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepositoryReqMultiError, or nil if none found.
func (m *DeleteRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DeleteRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := DeleteRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRepositoryReqMultiError(errors)
	}

	return nil
}

// DeleteRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by DeleteRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepositoryReqMultiError) AllErrors() []error { return m }

// DeleteRepositoryReqValidationError is the validation error returned by
// DeleteRepositoryReq.Validate if the designated constraints aren't met.
type DeleteRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepositoryReqValidationError) ErrorName() string {
	return "DeleteRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepositoryReqValidationError{}

// Validate checks the field values on DeleteRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepositoryRespMultiError, or nil if none found.
func (m *DeleteRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return DeleteRepositoryRespMultiError(errors)
	}

	return nil
}

// DeleteRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by DeleteRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepositoryRespMultiError) AllErrors() []error { return m }

// DeleteRepositoryRespValidationError is the validation error returned by
// DeleteRepositoryResp.Validate if the designated constraints aren't met.
type DeleteRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepositoryRespValidationError) ErrorName() string {
	return "DeleteRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepositoryRespValidationError{}

// Validate checks the field values on Repository with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Repository) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Repository with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepositoryMultiError, or
// nil if none found.
func (m *Repository) ValidateAll() error {
	return m.validate(true)
}

func (m *Repository) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for RepoURL

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for RemoteUsername

	// no validation rules for RemotePassword

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for DisplayName

	// no validation rules for Public

	if len(errors) > 0 {
		return RepositoryMultiError(errors)
	}

	return nil
}

// RepositoryMultiError is an error wrapping multiple validation errors
// returned by Repository.ValidateAll() if the designated constraints aren't met.
type RepositoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepositoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepositoryMultiError) AllErrors() []error { return m }

// RepositoryValidationError is the validation error returned by
// Repository.Validate if the designated constraints aren't met.
type RepositoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepositoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepositoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepositoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepositoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepositoryValidationError) ErrorName() string { return "RepositoryValidationError" }

// Error satisfies the builtin error interface
func (e RepositoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepository.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepositoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepositoryValidationError{}

// Validate checks the field values on ListChartReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListChartReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListChartReqMultiError, or
// nil if none found.
func (m *ListChartReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := ListChartReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := ListChartReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListChartReqMultiError(errors)
	}

	return nil
}

// ListChartReqMultiError is an error wrapping multiple validation errors
// returned by ListChartReq.ValidateAll() if the designated constraints aren't met.
type ListChartReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartReqMultiError) AllErrors() []error { return m }

// ListChartReqValidationError is the validation error returned by
// ListChartReq.Validate if the designated constraints aren't met.
type ListChartReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartReqValidationError) ErrorName() string { return "ListChartReqValidationError" }

// Error satisfies the builtin error interface
func (e ListChartReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartReqValidationError{}

// Validate checks the field values on ListChartResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListChartResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListChartRespMultiError, or
// nil if none found.
func (m *ListChartResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListChartRespMultiError(errors)
	}

	return nil
}

// ListChartRespMultiError is an error wrapping multiple validation errors
// returned by ListChartResp.ValidateAll() if the designated constraints
// aren't met.
type ListChartRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartRespMultiError) AllErrors() []error { return m }

// ListChartRespValidationError is the validation error returned by
// ListChartResp.Validate if the designated constraints aren't met.
type ListChartRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartRespValidationError) ErrorName() string { return "ListChartRespValidationError" }

// Error satisfies the builtin error interface
func (e ListChartRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartRespValidationError{}

// Validate checks the field values on ChartListData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartListData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartListDataMultiError, or
// nil if none found.
func (m *ChartListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChartListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChartListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChartListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChartListDataMultiError(errors)
	}

	return nil
}

// ChartListDataMultiError is an error wrapping multiple validation errors
// returned by ChartListData.ValidateAll() if the designated constraints
// aren't met.
type ChartListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartListDataMultiError) AllErrors() []error { return m }

// ChartListDataValidationError is the validation error returned by
// ChartListData.Validate if the designated constraints aren't met.
type ChartListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartListDataValidationError) ErrorName() string { return "ChartListDataValidationError" }

// Error satisfies the builtin error interface
func (e ChartListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartListDataValidationError{}

// Validate checks the field values on Chart with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Chart) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Chart with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChartMultiError, or nil if none found.
func (m *Chart) ValidateAll() error {
	return m.validate(true)
}

func (m *Chart) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for Repository

	// no validation rules for Type

	// no validation rules for Key

	// no validation rules for Name

	// no validation rules for LatestVersion

	// no validation rules for LatestAppVersion

	// no validation rules for LatestDescription

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for ProjectCode

	// no validation rules for Icon

	if len(errors) > 0 {
		return ChartMultiError(errors)
	}

	return nil
}

// ChartMultiError is an error wrapping multiple validation errors returned by
// Chart.ValidateAll() if the designated constraints aren't met.
type ChartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartMultiError) AllErrors() []error { return m }

// ChartValidationError is the validation error returned by Chart.Validate if
// the designated constraints aren't met.
type ChartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartValidationError) ErrorName() string { return "ChartValidationError" }

// Error satisfies the builtin error interface
func (e ChartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartValidationError{}

// Validate checks the field values on ListChartVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChartVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartVersionReqMultiError, or nil if none found.
func (m *ListChartVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := ListChartVersionReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := ListChartVersionReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := ListChartVersionReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListChartVersionReqMultiError(errors)
	}

	return nil
}

// ListChartVersionReqMultiError is an error wrapping multiple validation
// errors returned by ListChartVersionReq.ValidateAll() if the designated
// constraints aren't met.
type ListChartVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartVersionReqMultiError) AllErrors() []error { return m }

// ListChartVersionReqValidationError is the validation error returned by
// ListChartVersionReq.Validate if the designated constraints aren't met.
type ListChartVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartVersionReqValidationError) ErrorName() string {
	return "ListChartVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListChartVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartVersionReqValidationError{}

// Validate checks the field values on ListChartVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChartVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartVersionRespMultiError, or nil if none found.
func (m *ListChartVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartVersionRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartVersionRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartVersionRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListChartVersionRespMultiError(errors)
	}

	return nil
}

// ListChartVersionRespMultiError is an error wrapping multiple validation
// errors returned by ListChartVersionResp.ValidateAll() if the designated
// constraints aren't met.
type ListChartVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartVersionRespMultiError) AllErrors() []error { return m }

// ListChartVersionRespValidationError is the validation error returned by
// ListChartVersionResp.Validate if the designated constraints aren't met.
type ListChartVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartVersionRespValidationError) ErrorName() string {
	return "ListChartVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListChartVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartVersionRespValidationError{}

// Validate checks the field values on ChartVersionListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChartVersionListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartVersionListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChartVersionListDataMultiError, or nil if none found.
func (m *ChartVersionListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartVersionListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChartVersionListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChartVersionListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChartVersionListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChartVersionListDataMultiError(errors)
	}

	return nil
}

// ChartVersionListDataMultiError is an error wrapping multiple validation
// errors returned by ChartVersionListData.ValidateAll() if the designated
// constraints aren't met.
type ChartVersionListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartVersionListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartVersionListDataMultiError) AllErrors() []error { return m }

// ChartVersionListDataValidationError is the validation error returned by
// ChartVersionListData.Validate if the designated constraints aren't met.
type ChartVersionListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartVersionListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartVersionListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartVersionListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartVersionListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartVersionListDataValidationError) ErrorName() string {
	return "ChartVersionListDataValidationError"
}

// Error satisfies the builtin error interface
func (e ChartVersionListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartVersionListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartVersionListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartVersionListDataValidationError{}

// Validate checks the field values on ChartVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartVersion with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartVersionMultiError, or
// nil if none found.
func (m *ChartVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for AppVersion

	// no validation rules for Description

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return ChartVersionMultiError(errors)
	}

	return nil
}

// ChartVersionMultiError is an error wrapping multiple validation errors
// returned by ChartVersion.ValidateAll() if the designated constraints aren't met.
type ChartVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartVersionMultiError) AllErrors() []error { return m }

// ChartVersionValidationError is the validation error returned by
// ChartVersion.Validate if the designated constraints aren't met.
type ChartVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartVersionValidationError) ErrorName() string { return "ChartVersionValidationError" }

// Error satisfies the builtin error interface
func (e ChartVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartVersionValidationError{}

// Validate checks the field values on GetVersionDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVersionDetailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVersionDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVersionDetailReqMultiError, or nil if none found.
func (m *GetVersionDetailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVersionDetailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := GetVersionDetailReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := GetVersionDetailReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetVersionDetailReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := GetVersionDetailReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return GetVersionDetailReqMultiError(errors)
	}

	return nil
}

// GetVersionDetailReqMultiError is an error wrapping multiple validation
// errors returned by GetVersionDetailReq.ValidateAll() if the designated
// constraints aren't met.
type GetVersionDetailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVersionDetailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVersionDetailReqMultiError) AllErrors() []error { return m }

// GetVersionDetailReqValidationError is the validation error returned by
// GetVersionDetailReq.Validate if the designated constraints aren't met.
type GetVersionDetailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVersionDetailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVersionDetailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVersionDetailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVersionDetailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVersionDetailReqValidationError) ErrorName() string {
	return "GetVersionDetailReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetVersionDetailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVersionDetailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVersionDetailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVersionDetailReqValidationError{}

// Validate checks the field values on GetVersionDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVersionDetailResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVersionDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVersionDetailRespMultiError, or nil if none found.
func (m *GetVersionDetailResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVersionDetailResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetVersionDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetVersionDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetVersionDetailRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetVersionDetailRespMultiError(errors)
	}

	return nil
}

// GetVersionDetailRespMultiError is an error wrapping multiple validation
// errors returned by GetVersionDetailResp.ValidateAll() if the designated
// constraints aren't met.
type GetVersionDetailRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVersionDetailRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVersionDetailRespMultiError) AllErrors() []error { return m }

// GetVersionDetailRespValidationError is the validation error returned by
// GetVersionDetailResp.Validate if the designated constraints aren't met.
type GetVersionDetailRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVersionDetailRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVersionDetailRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVersionDetailRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVersionDetailRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVersionDetailRespValidationError) ErrorName() string {
	return "GetVersionDetailRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetVersionDetailRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVersionDetailResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVersionDetailRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVersionDetailRespValidationError{}

// Validate checks the field values on ChartDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartDetailMultiError, or
// nil if none found.
func (m *ChartDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Readme

	{
		sorted_keys := make([]string, len(m.GetContents()))
		i := 0
		for key := range m.GetContents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetContents()[key]
			_ = val

			// no validation rules for Contents[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ChartDetailValidationError{
							field:  fmt.Sprintf("Contents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ChartDetailValidationError{
							field:  fmt.Sprintf("Contents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ChartDetailValidationError{
						field:  fmt.Sprintf("Contents[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ChartDetailMultiError(errors)
	}

	return nil
}

// ChartDetailMultiError is an error wrapping multiple validation errors
// returned by ChartDetail.ValidateAll() if the designated constraints aren't met.
type ChartDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartDetailMultiError) AllErrors() []error { return m }

// ChartDetailValidationError is the validation error returned by
// ChartDetail.Validate if the designated constraints aren't met.
type ChartDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartDetailValidationError) ErrorName() string { return "ChartDetailValidationError" }

// Error satisfies the builtin error interface
func (e ChartDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartDetailValidationError{}

// Validate checks the field values on FileContent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileContent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileContent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileContentMultiError, or
// nil if none found.
func (m *FileContent) ValidateAll() error {
	return m.validate(true)
}

func (m *FileContent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Content

	if len(errors) > 0 {
		return FileContentMultiError(errors)
	}

	return nil
}

// FileContentMultiError is an error wrapping multiple validation errors
// returned by FileContent.ValidateAll() if the designated constraints aren't met.
type FileContentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileContentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileContentMultiError) AllErrors() []error { return m }

// FileContentValidationError is the validation error returned by
// FileContent.Validate if the designated constraints aren't met.
type FileContentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileContentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileContentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileContentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileContentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileContentValidationError) ErrorName() string { return "FileContentValidationError" }

// Error satisfies the builtin error interface
func (e FileContentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileContent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileContentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileContentValidationError{}

// Validate checks the field values on ListChartV1Req with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListChartV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartV1Req with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListChartV1ReqMultiError,
// or nil if none found.
func (m *ListChartV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListChartV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := ListChartV1ReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return ListChartV1ReqMultiError(errors)
	}

	return nil
}

// ListChartV1ReqMultiError is an error wrapping multiple validation errors
// returned by ListChartV1Req.ValidateAll() if the designated constraints
// aren't met.
type ListChartV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartV1ReqMultiError) AllErrors() []error { return m }

// ListChartV1ReqValidationError is the validation error returned by
// ListChartV1Req.Validate if the designated constraints aren't met.
type ListChartV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartV1ReqValidationError) ErrorName() string { return "ListChartV1ReqValidationError" }

// Error satisfies the builtin error interface
func (e ListChartV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartV1ReqValidationError{}

// Validate checks the field values on ListChartV1Resp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListChartV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartV1RespMultiError, or nil if none found.
func (m *ListChartV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListChartV1RespMultiError(errors)
	}

	return nil
}

// ListChartV1RespMultiError is an error wrapping multiple validation errors
// returned by ListChartV1Resp.ValidateAll() if the designated constraints
// aren't met.
type ListChartV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartV1RespMultiError) AllErrors() []error { return m }

// ListChartV1RespValidationError is the validation error returned by
// ListChartV1Resp.Validate if the designated constraints aren't met.
type ListChartV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartV1RespValidationError) ErrorName() string { return "ListChartV1RespValidationError" }

// Error satisfies the builtin error interface
func (e ListChartV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartV1RespValidationError{}

// Validate checks the field values on GetChartDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartDetailV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartDetailV1ReqMultiError, or nil if none found.
func (m *GetChartDetailV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartDetailV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetChartDetailV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := GetChartDetailV1ReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetChartDetailV1ReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetChartDetailV1ReqMultiError(errors)
	}

	return nil
}

// GetChartDetailV1ReqMultiError is an error wrapping multiple validation
// errors returned by GetChartDetailV1Req.ValidateAll() if the designated
// constraints aren't met.
type GetChartDetailV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartDetailV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartDetailV1ReqMultiError) AllErrors() []error { return m }

// GetChartDetailV1ReqValidationError is the validation error returned by
// GetChartDetailV1Req.Validate if the designated constraints aren't met.
type GetChartDetailV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartDetailV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartDetailV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartDetailV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartDetailV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartDetailV1ReqValidationError) ErrorName() string {
	return "GetChartDetailV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartDetailV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartDetailV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartDetailV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartDetailV1ReqValidationError{}

// Validate checks the field values on GetChartDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartDetailV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartDetailV1RespMultiError, or nil if none found.
func (m *GetChartDetailV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartDetailV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetChartDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetChartDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetChartDetailV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetChartDetailV1RespMultiError(errors)
	}

	return nil
}

// GetChartDetailV1RespMultiError is an error wrapping multiple validation
// errors returned by GetChartDetailV1Resp.ValidateAll() if the designated
// constraints aren't met.
type GetChartDetailV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartDetailV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartDetailV1RespMultiError) AllErrors() []error { return m }

// GetChartDetailV1RespValidationError is the validation error returned by
// GetChartDetailV1Resp.Validate if the designated constraints aren't met.
type GetChartDetailV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartDetailV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartDetailV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartDetailV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartDetailV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartDetailV1RespValidationError) ErrorName() string {
	return "GetChartDetailV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartDetailV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartDetailV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartDetailV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartDetailV1RespValidationError{}

// Validate checks the field values on ListChartVersionV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChartVersionV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartVersionV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartVersionV1ReqMultiError, or nil if none found.
func (m *ListChartVersionV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartVersionV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListChartVersionV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := ListChartVersionV1ReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := ListChartVersionV1ReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListChartVersionV1ReqMultiError(errors)
	}

	return nil
}

// ListChartVersionV1ReqMultiError is an error wrapping multiple validation
// errors returned by ListChartVersionV1Req.ValidateAll() if the designated
// constraints aren't met.
type ListChartVersionV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartVersionV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartVersionV1ReqMultiError) AllErrors() []error { return m }

// ListChartVersionV1ReqValidationError is the validation error returned by
// ListChartVersionV1Req.Validate if the designated constraints aren't met.
type ListChartVersionV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartVersionV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartVersionV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartVersionV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartVersionV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartVersionV1ReqValidationError) ErrorName() string {
	return "ListChartVersionV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListChartVersionV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartVersionV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartVersionV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartVersionV1ReqValidationError{}

// Validate checks the field values on ListChartVersionV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChartVersionV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartVersionV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartVersionV1RespMultiError, or nil if none found.
func (m *ListChartVersionV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartVersionV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartVersionV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartVersionV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartVersionV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListChartVersionV1RespMultiError(errors)
	}

	return nil
}

// ListChartVersionV1RespMultiError is an error wrapping multiple validation
// errors returned by ListChartVersionV1Resp.ValidateAll() if the designated
// constraints aren't met.
type ListChartVersionV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartVersionV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartVersionV1RespMultiError) AllErrors() []error { return m }

// ListChartVersionV1RespValidationError is the validation error returned by
// ListChartVersionV1Resp.Validate if the designated constraints aren't met.
type ListChartVersionV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartVersionV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartVersionV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartVersionV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartVersionV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartVersionV1RespValidationError) ErrorName() string {
	return "ListChartVersionV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e ListChartVersionV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartVersionV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartVersionV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartVersionV1RespValidationError{}

// Validate checks the field values on GetVersionDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVersionDetailV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVersionDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVersionDetailV1ReqMultiError, or nil if none found.
func (m *GetVersionDetailV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVersionDetailV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetVersionDetailV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := GetVersionDetailV1ReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetVersionDetailV1ReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := GetVersionDetailV1ReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetVersionDetailV1ReqMultiError(errors)
	}

	return nil
}

// GetVersionDetailV1ReqMultiError is an error wrapping multiple validation
// errors returned by GetVersionDetailV1Req.ValidateAll() if the designated
// constraints aren't met.
type GetVersionDetailV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVersionDetailV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVersionDetailV1ReqMultiError) AllErrors() []error { return m }

// GetVersionDetailV1ReqValidationError is the validation error returned by
// GetVersionDetailV1Req.Validate if the designated constraints aren't met.
type GetVersionDetailV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVersionDetailV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVersionDetailV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVersionDetailV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVersionDetailV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVersionDetailV1ReqValidationError) ErrorName() string {
	return "GetVersionDetailV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetVersionDetailV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVersionDetailV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVersionDetailV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVersionDetailV1ReqValidationError{}

// Validate checks the field values on GetVersionDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVersionDetailV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVersionDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVersionDetailV1RespMultiError, or nil if none found.
func (m *GetVersionDetailV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVersionDetailV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetVersionDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetVersionDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetVersionDetailV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetVersionDetailV1RespMultiError(errors)
	}

	return nil
}

// GetVersionDetailV1RespMultiError is an error wrapping multiple validation
// errors returned by GetVersionDetailV1Resp.ValidateAll() if the designated
// constraints aren't met.
type GetVersionDetailV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVersionDetailV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVersionDetailV1RespMultiError) AllErrors() []error { return m }

// GetVersionDetailV1RespValidationError is the validation error returned by
// GetVersionDetailV1Resp.Validate if the designated constraints aren't met.
type GetVersionDetailV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVersionDetailV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVersionDetailV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVersionDetailV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVersionDetailV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVersionDetailV1RespValidationError) ErrorName() string {
	return "GetVersionDetailV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e GetVersionDetailV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVersionDetailV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVersionDetailV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVersionDetailV1RespValidationError{}

// Validate checks the field values on DeleteChartReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteChartReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteChartReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteChartReqMultiError,
// or nil if none found.
func (m *DeleteChartReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteChartReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DeleteChartReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := DeleteChartReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := DeleteChartReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteChartReqMultiError(errors)
	}

	return nil
}

// DeleteChartReqMultiError is an error wrapping multiple validation errors
// returned by DeleteChartReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteChartReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteChartReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteChartReqMultiError) AllErrors() []error { return m }

// DeleteChartReqValidationError is the validation error returned by
// DeleteChartReq.Validate if the designated constraints aren't met.
type DeleteChartReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteChartReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteChartReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteChartReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteChartReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteChartReqValidationError) ErrorName() string { return "DeleteChartReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteChartReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteChartReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteChartReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteChartReqValidationError{}

// Validate checks the field values on DeleteChartResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteChartResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteChartResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteChartRespMultiError, or nil if none found.
func (m *DeleteChartResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteChartResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return DeleteChartRespMultiError(errors)
	}

	return nil
}

// DeleteChartRespMultiError is an error wrapping multiple validation errors
// returned by DeleteChartResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteChartRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteChartRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteChartRespMultiError) AllErrors() []error { return m }

// DeleteChartRespValidationError is the validation error returned by
// DeleteChartResp.Validate if the designated constraints aren't met.
type DeleteChartRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteChartRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteChartRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteChartRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteChartRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteChartRespValidationError) ErrorName() string { return "DeleteChartRespValidationError" }

// Error satisfies the builtin error interface
func (e DeleteChartRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteChartResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteChartRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteChartRespValidationError{}

// Validate checks the field values on DeleteChartVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteChartVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteChartVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteChartVersionReqMultiError, or nil if none found.
func (m *DeleteChartVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteChartVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DeleteChartVersionReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := DeleteChartVersionReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := DeleteChartVersionReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := DeleteChartVersionReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteChartVersionReqMultiError(errors)
	}

	return nil
}

// DeleteChartVersionReqMultiError is an error wrapping multiple validation
// errors returned by DeleteChartVersionReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteChartVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteChartVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteChartVersionReqMultiError) AllErrors() []error { return m }

// DeleteChartVersionReqValidationError is the validation error returned by
// DeleteChartVersionReq.Validate if the designated constraints aren't met.
type DeleteChartVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteChartVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteChartVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteChartVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteChartVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteChartVersionReqValidationError) ErrorName() string {
	return "DeleteChartVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteChartVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteChartVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteChartVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteChartVersionReqValidationError{}

// Validate checks the field values on DeleteChartVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteChartVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteChartVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteChartVersionRespMultiError, or nil if none found.
func (m *DeleteChartVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteChartVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return DeleteChartVersionRespMultiError(errors)
	}

	return nil
}

// DeleteChartVersionRespMultiError is an error wrapping multiple validation
// errors returned by DeleteChartVersionResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteChartVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteChartVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteChartVersionRespMultiError) AllErrors() []error { return m }

// DeleteChartVersionRespValidationError is the validation error returned by
// DeleteChartVersionResp.Validate if the designated constraints aren't met.
type DeleteChartVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteChartVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteChartVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteChartVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteChartVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteChartVersionRespValidationError) ErrorName() string {
	return "DeleteChartVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteChartVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteChartVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteChartVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteChartVersionRespValidationError{}

// Validate checks the field values on DownloadChartReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DownloadChartReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadChartReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadChartReqMultiError, or nil if none found.
func (m *DownloadChartReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadChartReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DownloadChartReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := DownloadChartReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := DownloadChartReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := DownloadChartReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DownloadChartReqMultiError(errors)
	}

	return nil
}

// DownloadChartReqMultiError is an error wrapping multiple validation errors
// returned by DownloadChartReq.ValidateAll() if the designated constraints
// aren't met.
type DownloadChartReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadChartReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadChartReqMultiError) AllErrors() []error { return m }

// DownloadChartReqValidationError is the validation error returned by
// DownloadChartReq.Validate if the designated constraints aren't met.
type DownloadChartReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadChartReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadChartReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadChartReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadChartReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadChartReqValidationError) ErrorName() string { return "DownloadChartReqValidationError" }

// Error satisfies the builtin error interface
func (e DownloadChartReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadChartReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadChartReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadChartReqValidationError{}

// Validate checks the field values on GetChartReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartReleaseReqMultiError, or nil if none found.
func (m *GetChartReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetChartReleaseReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := GetChartReleaseReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetChartReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetChartReleaseReqMultiError(errors)
	}

	return nil
}

// GetChartReleaseReqMultiError is an error wrapping multiple validation errors
// returned by GetChartReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type GetChartReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartReleaseReqMultiError) AllErrors() []error { return m }

// GetChartReleaseReqValidationError is the validation error returned by
// GetChartReleaseReq.Validate if the designated constraints aren't met.
type GetChartReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartReleaseReqValidationError) ErrorName() string {
	return "GetChartReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartReleaseReqValidationError{}

// Validate checks the field values on GetChartReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartReleaseRespMultiError, or nil if none found.
func (m *GetChartReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetChartReleaseRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetChartReleaseRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetChartReleaseRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetChartReleaseRespMultiError(errors)
	}

	return nil
}

// GetChartReleaseRespMultiError is an error wrapping multiple validation
// errors returned by GetChartReleaseResp.ValidateAll() if the designated
// constraints aren't met.
type GetChartReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartReleaseRespMultiError) AllErrors() []error { return m }

// GetChartReleaseRespValidationError is the validation error returned by
// GetChartReleaseResp.Validate if the designated constraints aren't met.
type GetChartReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartReleaseRespValidationError) ErrorName() string {
	return "GetChartReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartReleaseRespValidationError{}

// Validate checks the field values on ListReleaseReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReleaseReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListReleaseReqMultiError,
// or nil if none found.
func (m *ListReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := ListReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for Name

	if len(errors) > 0 {
		return ListReleaseReqMultiError(errors)
	}

	return nil
}

// ListReleaseReqMultiError is an error wrapping multiple validation errors
// returned by ListReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type ListReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReleaseReqMultiError) AllErrors() []error { return m }

// ListReleaseReqValidationError is the validation error returned by
// ListReleaseReq.Validate if the designated constraints aren't met.
type ListReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReleaseReqValidationError) ErrorName() string { return "ListReleaseReqValidationError" }

// Error satisfies the builtin error interface
func (e ListReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReleaseReqValidationError{}

// Validate checks the field values on ListReleaseResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReleaseRespMultiError, or nil if none found.
func (m *ListReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReleaseRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListReleaseRespMultiError(errors)
	}

	return nil
}

// ListReleaseRespMultiError is an error wrapping multiple validation errors
// returned by ListReleaseResp.ValidateAll() if the designated constraints
// aren't met.
type ListReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReleaseRespMultiError) AllErrors() []error { return m }

// ListReleaseRespValidationError is the validation error returned by
// ListReleaseResp.Validate if the designated constraints aren't met.
type ListReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReleaseRespValidationError) ErrorName() string { return "ListReleaseRespValidationError" }

// Error satisfies the builtin error interface
func (e ListReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReleaseRespValidationError{}

// Validate checks the field values on GetReleaseDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseDetailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseDetailReqMultiError, or nil if none found.
func (m *GetReleaseDetailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseDetailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseDetailReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseDetailReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetReleaseDetailReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetReleaseDetailReqMultiError(errors)
	}

	return nil
}

// GetReleaseDetailReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseDetailReq.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseDetailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseDetailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseDetailReqMultiError) AllErrors() []error { return m }

// GetReleaseDetailReqValidationError is the validation error returned by
// GetReleaseDetailReq.Validate if the designated constraints aren't met.
type GetReleaseDetailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseDetailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseDetailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseDetailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseDetailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseDetailReqValidationError) ErrorName() string {
	return "GetReleaseDetailReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseDetailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseDetailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseDetailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseDetailReqValidationError{}

// Validate checks the field values on GetReleaseDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseDetailResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseDetailRespMultiError, or nil if none found.
func (m *GetReleaseDetailResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseDetailResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReleaseDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReleaseDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReleaseDetailRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetReleaseDetailRespMultiError(errors)
	}

	return nil
}

// GetReleaseDetailRespMultiError is an error wrapping multiple validation
// errors returned by GetReleaseDetailResp.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseDetailRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseDetailRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseDetailRespMultiError) AllErrors() []error { return m }

// GetReleaseDetailRespValidationError is the validation error returned by
// GetReleaseDetailResp.Validate if the designated constraints aren't met.
type GetReleaseDetailRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseDetailRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseDetailRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseDetailRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseDetailRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseDetailRespValidationError) ErrorName() string {
	return "GetReleaseDetailRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseDetailRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseDetailResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseDetailRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseDetailRespValidationError{}

// Validate checks the field values on ReleaseListData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReleaseListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleaseListDataMultiError, or nil if none found.
func (m *ReleaseListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReleaseListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReleaseListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReleaseListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReleaseListDataMultiError(errors)
	}

	return nil
}

// ReleaseListDataMultiError is an error wrapping multiple validation errors
// returned by ReleaseListData.ValidateAll() if the designated constraints
// aren't met.
type ReleaseListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseListDataMultiError) AllErrors() []error { return m }

// ReleaseListDataValidationError is the validation error returned by
// ReleaseListData.Validate if the designated constraints aren't met.
type ReleaseListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseListDataValidationError) ErrorName() string { return "ReleaseListDataValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseListDataValidationError{}

// Validate checks the field values on Release with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Release) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Release with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReleaseMultiError, or nil if none found.
func (m *Release) ValidateAll() error {
	return m.validate(true)
}

func (m *Release) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Revision

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for AppVersion

	// no validation rules for UpdateTime

	// no validation rules for ChartVersion

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for Message

	// no validation rules for Repo

	// no validation rules for IamNamespaceID

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ReleaseMultiError(errors)
	}

	return nil
}

// ReleaseMultiError is an error wrapping multiple validation errors returned
// by Release.ValidateAll() if the designated constraints aren't met.
type ReleaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseMultiError) AllErrors() []error { return m }

// ReleaseValidationError is the validation error returned by Release.Validate
// if the designated constraints aren't met.
type ReleaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseValidationError) ErrorName() string { return "ReleaseValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelease.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseValidationError{}

// Validate checks the field values on ReleaseDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseDetailMultiError, or
// nil if none found.
func (m *ReleaseDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Revision

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for AppVersion

	// no validation rules for UpdateTime

	// no validation rules for ChartVersion

	// no validation rules for Description

	// no validation rules for Notes

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for Message

	// no validation rules for Repo

	// no validation rules for ValueFile

	if len(errors) > 0 {
		return ReleaseDetailMultiError(errors)
	}

	return nil
}

// ReleaseDetailMultiError is an error wrapping multiple validation errors
// returned by ReleaseDetail.ValidateAll() if the designated constraints
// aren't met.
type ReleaseDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseDetailMultiError) AllErrors() []error { return m }

// ReleaseDetailValidationError is the validation error returned by
// ReleaseDetail.Validate if the designated constraints aren't met.
type ReleaseDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseDetailValidationError) ErrorName() string { return "ReleaseDetailValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseDetailValidationError{}

// Validate checks the field values on InstallReleaseReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InstallReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallReleaseReqMultiError, or nil if none found.
func (m *InstallReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetChart()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Chart",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	// no validation rules for BcsSysVar

	if len(errors) > 0 {
		return InstallReleaseReqMultiError(errors)
	}

	return nil
}

// InstallReleaseReqMultiError is an error wrapping multiple validation errors
// returned by InstallReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type InstallReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallReleaseReqMultiError) AllErrors() []error { return m }

// InstallReleaseReqValidationError is the validation error returned by
// InstallReleaseReq.Validate if the designated constraints aren't met.
type InstallReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallReleaseReqValidationError) ErrorName() string {
	return "InstallReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e InstallReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallReleaseReqValidationError{}

// Validate checks the field values on InstallReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallReleaseRespMultiError, or nil if none found.
func (m *InstallReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstallReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstallReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstallReleaseRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return InstallReleaseRespMultiError(errors)
	}

	return nil
}

// InstallReleaseRespMultiError is an error wrapping multiple validation errors
// returned by InstallReleaseResp.ValidateAll() if the designated constraints
// aren't met.
type InstallReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallReleaseRespMultiError) AllErrors() []error { return m }

// InstallReleaseRespValidationError is the validation error returned by
// InstallReleaseResp.Validate if the designated constraints aren't met.
type InstallReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallReleaseRespValidationError) ErrorName() string {
	return "InstallReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e InstallReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallReleaseRespValidationError{}

// Validate checks the field values on UninstallReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallReleaseReqMultiError, or nil if none found.
func (m *UninstallReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := UninstallReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := UninstallReleaseReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UninstallReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return UninstallReleaseReqMultiError(errors)
	}

	return nil
}

// UninstallReleaseReqMultiError is an error wrapping multiple validation
// errors returned by UninstallReleaseReq.ValidateAll() if the designated
// constraints aren't met.
type UninstallReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallReleaseReqMultiError) AllErrors() []error { return m }

// UninstallReleaseReqValidationError is the validation error returned by
// UninstallReleaseReq.Validate if the designated constraints aren't met.
type UninstallReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallReleaseReqValidationError) ErrorName() string {
	return "UninstallReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallReleaseReqValidationError{}

// Validate checks the field values on UninstallReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallReleaseRespMultiError, or nil if none found.
func (m *UninstallReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UninstallReleaseRespMultiError(errors)
	}

	return nil
}

// UninstallReleaseRespMultiError is an error wrapping multiple validation
// errors returned by UninstallReleaseResp.ValidateAll() if the designated
// constraints aren't met.
type UninstallReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallReleaseRespMultiError) AllErrors() []error { return m }

// UninstallReleaseRespValidationError is the validation error returned by
// UninstallReleaseResp.Validate if the designated constraints aren't met.
type UninstallReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallReleaseRespValidationError) ErrorName() string {
	return "UninstallReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallReleaseRespValidationError{}

// Validate checks the field values on UpgradeReleaseReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpgradeReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeReleaseReqMultiError, or nil if none found.
func (m *UpgradeReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetChart()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Chart",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	// no validation rules for BcsSysVar

	if len(errors) > 0 {
		return UpgradeReleaseReqMultiError(errors)
	}

	return nil
}

// UpgradeReleaseReqMultiError is an error wrapping multiple validation errors
// returned by UpgradeReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type UpgradeReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeReleaseReqMultiError) AllErrors() []error { return m }

// UpgradeReleaseReqValidationError is the validation error returned by
// UpgradeReleaseReq.Validate if the designated constraints aren't met.
type UpgradeReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeReleaseReqValidationError) ErrorName() string {
	return "UpgradeReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeReleaseReqValidationError{}

// Validate checks the field values on UpgradeReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradeReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeReleaseRespMultiError, or nil if none found.
func (m *UpgradeReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeReleaseRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UpgradeReleaseRespMultiError(errors)
	}

	return nil
}

// UpgradeReleaseRespMultiError is an error wrapping multiple validation errors
// returned by UpgradeReleaseResp.ValidateAll() if the designated constraints
// aren't met.
type UpgradeReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeReleaseRespMultiError) AllErrors() []error { return m }

// UpgradeReleaseRespValidationError is the validation error returned by
// UpgradeReleaseResp.Validate if the designated constraints aren't met.
type UpgradeReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeReleaseRespValidationError) ErrorName() string {
	return "UpgradeReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeReleaseRespValidationError{}

// Validate checks the field values on RollbackReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackReleaseReqMultiError, or nil if none found.
func (m *RollbackReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := RollbackReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := RollbackReleaseReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := RollbackReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Revision

	// no validation rules for Operator

	if len(errors) > 0 {
		return RollbackReleaseReqMultiError(errors)
	}

	return nil
}

// RollbackReleaseReqMultiError is an error wrapping multiple validation errors
// returned by RollbackReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type RollbackReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackReleaseReqMultiError) AllErrors() []error { return m }

// RollbackReleaseReqValidationError is the validation error returned by
// RollbackReleaseReq.Validate if the designated constraints aren't met.
type RollbackReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackReleaseReqValidationError) ErrorName() string {
	return "RollbackReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackReleaseReqValidationError{}

// Validate checks the field values on RollbackReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackReleaseRespMultiError, or nil if none found.
func (m *RollbackReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return RollbackReleaseRespMultiError(errors)
	}

	return nil
}

// RollbackReleaseRespMultiError is an error wrapping multiple validation
// errors returned by RollbackReleaseResp.ValidateAll() if the designated
// constraints aren't met.
type RollbackReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackReleaseRespMultiError) AllErrors() []error { return m }

// RollbackReleaseRespValidationError is the validation error returned by
// RollbackReleaseResp.Validate if the designated constraints aren't met.
type RollbackReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackReleaseRespValidationError) ErrorName() string {
	return "RollbackReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackReleaseRespValidationError{}

// Validate checks the field values on ListReleaseV1Req with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReleaseV1ReqMultiError, or nil if none found.
func (m *ListReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := ListReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return ListReleaseV1ReqMultiError(errors)
	}

	return nil
}

// ListReleaseV1ReqMultiError is an error wrapping multiple validation errors
// returned by ListReleaseV1Req.ValidateAll() if the designated constraints
// aren't met.
type ListReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReleaseV1ReqMultiError) AllErrors() []error { return m }

// ListReleaseV1ReqValidationError is the validation error returned by
// ListReleaseV1Req.Validate if the designated constraints aren't met.
type ListReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReleaseV1ReqValidationError) ErrorName() string { return "ListReleaseV1ReqValidationError" }

// Error satisfies the builtin error interface
func (e ListReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReleaseV1ReqValidationError{}

// Validate checks the field values on ListReleaseV1Resp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReleaseV1RespMultiError, or nil if none found.
func (m *ListReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReleaseV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReleaseV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReleaseV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReleaseV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListReleaseV1RespMultiError(errors)
	}

	return nil
}

// ListReleaseV1RespMultiError is an error wrapping multiple validation errors
// returned by ListReleaseV1Resp.ValidateAll() if the designated constraints
// aren't met.
type ListReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReleaseV1RespMultiError) AllErrors() []error { return m }

// ListReleaseV1RespValidationError is the validation error returned by
// ListReleaseV1Resp.Validate if the designated constraints aren't met.
type ListReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReleaseV1RespValidationError) ErrorName() string {
	return "ListReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e ListReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReleaseV1RespValidationError{}

// Validate checks the field values on GetReleaseDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseDetailV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseDetailV1ReqMultiError, or nil if none found.
func (m *GetReleaseDetailV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseDetailV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetReleaseDetailV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseDetailV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseDetailV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetReleaseDetailV1ReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetReleaseDetailV1ReqMultiError(errors)
	}

	return nil
}

// GetReleaseDetailV1ReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseDetailV1Req.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseDetailV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseDetailV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseDetailV1ReqMultiError) AllErrors() []error { return m }

// GetReleaseDetailV1ReqValidationError is the validation error returned by
// GetReleaseDetailV1Req.Validate if the designated constraints aren't met.
type GetReleaseDetailV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseDetailV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseDetailV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseDetailV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseDetailV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseDetailV1ReqValidationError) ErrorName() string {
	return "GetReleaseDetailV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseDetailV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseDetailV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseDetailV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseDetailV1ReqValidationError{}

// Validate checks the field values on GetReleaseDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseDetailV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseDetailV1RespMultiError, or nil if none found.
func (m *GetReleaseDetailV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseDetailV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReleaseDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReleaseDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReleaseDetailV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetReleaseDetailV1RespMultiError(errors)
	}

	return nil
}

// GetReleaseDetailV1RespMultiError is an error wrapping multiple validation
// errors returned by GetReleaseDetailV1Resp.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseDetailV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseDetailV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseDetailV1RespMultiError) AllErrors() []error { return m }

// GetReleaseDetailV1RespValidationError is the validation error returned by
// GetReleaseDetailV1Resp.Validate if the designated constraints aren't met.
type GetReleaseDetailV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseDetailV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseDetailV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseDetailV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseDetailV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseDetailV1RespValidationError) ErrorName() string {
	return "GetReleaseDetailV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseDetailV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseDetailV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseDetailV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseDetailV1RespValidationError{}

// Validate checks the field values on InstallReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallReleaseV1ReqMultiError, or nil if none found.
func (m *InstallReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := InstallReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetChart()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Chart",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ValueFile

	if len(errors) > 0 {
		return InstallReleaseV1ReqMultiError(errors)
	}

	return nil
}

// InstallReleaseV1ReqMultiError is an error wrapping multiple validation
// errors returned by InstallReleaseV1Req.ValidateAll() if the designated
// constraints aren't met.
type InstallReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallReleaseV1ReqMultiError) AllErrors() []error { return m }

// InstallReleaseV1ReqValidationError is the validation error returned by
// InstallReleaseV1Req.Validate if the designated constraints aren't met.
type InstallReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallReleaseV1ReqValidationError) ErrorName() string {
	return "InstallReleaseV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e InstallReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallReleaseV1ReqValidationError{}

// Validate checks the field values on InstallReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallReleaseV1RespMultiError, or nil if none found.
func (m *InstallReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return InstallReleaseV1RespMultiError(errors)
	}

	return nil
}

// InstallReleaseV1RespMultiError is an error wrapping multiple validation
// errors returned by InstallReleaseV1Resp.ValidateAll() if the designated
// constraints aren't met.
type InstallReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallReleaseV1RespMultiError) AllErrors() []error { return m }

// InstallReleaseV1RespValidationError is the validation error returned by
// InstallReleaseV1Resp.Validate if the designated constraints aren't met.
type InstallReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallReleaseV1RespValidationError) ErrorName() string {
	return "InstallReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e InstallReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallReleaseV1RespValidationError{}

// Validate checks the field values on UninstallReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallReleaseV1ReqMultiError, or nil if none found.
func (m *UninstallReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UninstallReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UninstallReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := UninstallReleaseV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := UninstallReleaseV1ReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UninstallReleaseV1ReqMultiError(errors)
	}

	return nil
}

// UninstallReleaseV1ReqMultiError is an error wrapping multiple validation
// errors returned by UninstallReleaseV1Req.ValidateAll() if the designated
// constraints aren't met.
type UninstallReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallReleaseV1ReqMultiError) AllErrors() []error { return m }

// UninstallReleaseV1ReqValidationError is the validation error returned by
// UninstallReleaseV1Req.Validate if the designated constraints aren't met.
type UninstallReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallReleaseV1ReqValidationError) ErrorName() string {
	return "UninstallReleaseV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallReleaseV1ReqValidationError{}

// Validate checks the field values on UninstallReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallReleaseV1RespMultiError, or nil if none found.
func (m *UninstallReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UninstallReleaseV1RespMultiError(errors)
	}

	return nil
}

// UninstallReleaseV1RespMultiError is an error wrapping multiple validation
// errors returned by UninstallReleaseV1Resp.ValidateAll() if the designated
// constraints aren't met.
type UninstallReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallReleaseV1RespMultiError) AllErrors() []error { return m }

// UninstallReleaseV1RespValidationError is the validation error returned by
// UninstallReleaseV1Resp.Validate if the designated constraints aren't met.
type UninstallReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallReleaseV1RespValidationError) ErrorName() string {
	return "UninstallReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallReleaseV1RespValidationError{}

// Validate checks the field values on UpgradeReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradeReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeReleaseV1ReqMultiError, or nil if none found.
func (m *UpgradeReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetChart()); l < 1 || l > 64 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "Chart",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ValueFile

	if len(errors) > 0 {
		return UpgradeReleaseV1ReqMultiError(errors)
	}

	return nil
}

// UpgradeReleaseV1ReqMultiError is an error wrapping multiple validation
// errors returned by UpgradeReleaseV1Req.ValidateAll() if the designated
// constraints aren't met.
type UpgradeReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeReleaseV1ReqMultiError) AllErrors() []error { return m }

// UpgradeReleaseV1ReqValidationError is the validation error returned by
// UpgradeReleaseV1Req.Validate if the designated constraints aren't met.
type UpgradeReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeReleaseV1ReqValidationError) ErrorName() string {
	return "UpgradeReleaseV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeReleaseV1ReqValidationError{}

// Validate checks the field values on UpgradeReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradeReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeReleaseV1RespMultiError, or nil if none found.
func (m *UpgradeReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UpgradeReleaseV1RespMultiError(errors)
	}

	return nil
}

// UpgradeReleaseV1RespMultiError is an error wrapping multiple validation
// errors returned by UpgradeReleaseV1Resp.ValidateAll() if the designated
// constraints aren't met.
type UpgradeReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeReleaseV1RespMultiError) AllErrors() []error { return m }

// UpgradeReleaseV1RespValidationError is the validation error returned by
// UpgradeReleaseV1Resp.Validate if the designated constraints aren't met.
type UpgradeReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeReleaseV1RespValidationError) ErrorName() string {
	return "UpgradeReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeReleaseV1RespValidationError{}

// Validate checks the field values on RollbackReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackReleaseV1ReqMultiError, or nil if none found.
func (m *RollbackReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := RollbackReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := RollbackReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := RollbackReleaseV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := RollbackReleaseV1ReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Revision

	if len(errors) > 0 {
		return RollbackReleaseV1ReqMultiError(errors)
	}

	return nil
}

// RollbackReleaseV1ReqMultiError is an error wrapping multiple validation
// errors returned by RollbackReleaseV1Req.ValidateAll() if the designated
// constraints aren't met.
type RollbackReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackReleaseV1ReqMultiError) AllErrors() []error { return m }

// RollbackReleaseV1ReqValidationError is the validation error returned by
// RollbackReleaseV1Req.Validate if the designated constraints aren't met.
type RollbackReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackReleaseV1ReqValidationError) ErrorName() string {
	return "RollbackReleaseV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackReleaseV1ReqValidationError{}

// Validate checks the field values on RollbackReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackReleaseV1RespMultiError, or nil if none found.
func (m *RollbackReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if len(errors) > 0 {
		return RollbackReleaseV1RespMultiError(errors)
	}

	return nil
}

// RollbackReleaseV1RespMultiError is an error wrapping multiple validation
// errors returned by RollbackReleaseV1Resp.ValidateAll() if the designated
// constraints aren't met.
type RollbackReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackReleaseV1RespMultiError) AllErrors() []error { return m }

// RollbackReleaseV1RespValidationError is the validation error returned by
// RollbackReleaseV1Resp.Validate if the designated constraints aren't met.
type RollbackReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackReleaseV1RespValidationError) ErrorName() string {
	return "RollbackReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackReleaseV1RespValidationError{}

// Validate checks the field values on ReleasePreviewReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReleasePreviewReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleasePreviewReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleasePreviewReqMultiError, or nil if none found.
func (m *ReleasePreviewReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleasePreviewReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ReleasePreviewReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := ReleasePreviewReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := ReleasePreviewReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := ReleasePreviewReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Repository

	// no validation rules for Chart

	// no validation rules for Version

	// no validation rules for Revision

	if len(errors) > 0 {
		return ReleasePreviewReqMultiError(errors)
	}

	return nil
}

// ReleasePreviewReqMultiError is an error wrapping multiple validation errors
// returned by ReleasePreviewReq.ValidateAll() if the designated constraints
// aren't met.
type ReleasePreviewReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleasePreviewReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleasePreviewReqMultiError) AllErrors() []error { return m }

// ReleasePreviewReqValidationError is the validation error returned by
// ReleasePreviewReq.Validate if the designated constraints aren't met.
type ReleasePreviewReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleasePreviewReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleasePreviewReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleasePreviewReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleasePreviewReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleasePreviewReqValidationError) ErrorName() string {
	return "ReleasePreviewReqValidationError"
}

// Error satisfies the builtin error interface
func (e ReleasePreviewReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleasePreviewReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleasePreviewReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleasePreviewReqValidationError{}

// Validate checks the field values on ReleasePreviewResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReleasePreviewResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleasePreviewResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleasePreviewRespMultiError, or nil if none found.
func (m *ReleasePreviewResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleasePreviewResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleasePreviewRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleasePreviewRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleasePreviewRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ReleasePreviewRespMultiError(errors)
	}

	return nil
}

// ReleasePreviewRespMultiError is an error wrapping multiple validation errors
// returned by ReleasePreviewResp.ValidateAll() if the designated constraints
// aren't met.
type ReleasePreviewRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleasePreviewRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleasePreviewRespMultiError) AllErrors() []error { return m }

// ReleasePreviewRespValidationError is the validation error returned by
// ReleasePreviewResp.Validate if the designated constraints aren't met.
type ReleasePreviewRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleasePreviewRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleasePreviewRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleasePreviewRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleasePreviewRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleasePreviewRespValidationError) ErrorName() string {
	return "ReleasePreviewRespValidationError"
}

// Error satisfies the builtin error interface
func (e ReleasePreviewRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleasePreviewResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleasePreviewRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleasePreviewRespValidationError{}

// Validate checks the field values on ReleasePreview with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleasePreview) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleasePreview with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleasePreviewMultiError,
// or nil if none found.
func (m *ReleasePreview) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleasePreview) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetNewContents()))
		i := 0
		for key := range m.GetNewContents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNewContents()[key]
			_ = val

			// no validation rules for NewContents[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ReleasePreviewValidationError{
							field:  fmt.Sprintf("NewContents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ReleasePreviewValidationError{
							field:  fmt.Sprintf("NewContents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ReleasePreviewValidationError{
						field:  fmt.Sprintf("NewContents[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetOldContents()))
		i := 0
		for key := range m.GetOldContents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOldContents()[key]
			_ = val

			// no validation rules for OldContents[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ReleasePreviewValidationError{
							field:  fmt.Sprintf("OldContents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ReleasePreviewValidationError{
							field:  fmt.Sprintf("OldContents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ReleasePreviewValidationError{
						field:  fmt.Sprintf("OldContents[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for NewContent

	// no validation rules for OldContent

	if len(errors) > 0 {
		return ReleasePreviewMultiError(errors)
	}

	return nil
}

// ReleasePreviewMultiError is an error wrapping multiple validation errors
// returned by ReleasePreview.ValidateAll() if the designated constraints
// aren't met.
type ReleasePreviewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleasePreviewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleasePreviewMultiError) AllErrors() []error { return m }

// ReleasePreviewValidationError is the validation error returned by
// ReleasePreview.Validate if the designated constraints aren't met.
type ReleasePreviewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleasePreviewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleasePreviewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleasePreviewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleasePreviewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleasePreviewValidationError) ErrorName() string { return "ReleasePreviewValidationError" }

// Error satisfies the builtin error interface
func (e ReleasePreviewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleasePreview.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleasePreviewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleasePreviewValidationError{}

// Validate checks the field values on GetReleaseHistoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseHistoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseHistoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseHistoryReqMultiError, or nil if none found.
func (m *GetReleaseHistoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseHistoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetReleaseHistoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseHistoryReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseHistoryReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetReleaseHistoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Filter

	if len(errors) > 0 {
		return GetReleaseHistoryReqMultiError(errors)
	}

	return nil
}

// GetReleaseHistoryReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseHistoryReq.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseHistoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseHistoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseHistoryReqMultiError) AllErrors() []error { return m }

// GetReleaseHistoryReqValidationError is the validation error returned by
// GetReleaseHistoryReq.Validate if the designated constraints aren't met.
type GetReleaseHistoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseHistoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseHistoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseHistoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseHistoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseHistoryReqValidationError) ErrorName() string {
	return "GetReleaseHistoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseHistoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseHistoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseHistoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseHistoryReqValidationError{}

// Validate checks the field values on GetReleaseHistoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseHistoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseHistoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseHistoryRespMultiError, or nil if none found.
func (m *GetReleaseHistoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseHistoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReleaseHistoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReleaseHistoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReleaseHistoryRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetReleaseHistoryRespMultiError(errors)
	}

	return nil
}

// GetReleaseHistoryRespMultiError is an error wrapping multiple validation
// errors returned by GetReleaseHistoryResp.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseHistoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseHistoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseHistoryRespMultiError) AllErrors() []error { return m }

// GetReleaseHistoryRespValidationError is the validation error returned by
// GetReleaseHistoryResp.Validate if the designated constraints aren't met.
type GetReleaseHistoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseHistoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseHistoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseHistoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseHistoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseHistoryRespValidationError) ErrorName() string {
	return "GetReleaseHistoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseHistoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseHistoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseHistoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseHistoryRespValidationError{}

// Validate checks the field values on ReleaseHistory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseHistoryMultiError,
// or nil if none found.
func (m *ReleaseHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Revision

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for UpdateTime

	// no validation rules for Description

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for ChartVersion

	// no validation rules for AppVersion

	// no validation rules for Values

	if len(errors) > 0 {
		return ReleaseHistoryMultiError(errors)
	}

	return nil
}

// ReleaseHistoryMultiError is an error wrapping multiple validation errors
// returned by ReleaseHistory.ValidateAll() if the designated constraints
// aren't met.
type ReleaseHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseHistoryMultiError) AllErrors() []error { return m }

// ReleaseHistoryValidationError is the validation error returned by
// ReleaseHistory.Validate if the designated constraints aren't met.
type ReleaseHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseHistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseHistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseHistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseHistoryValidationError) ErrorName() string { return "ReleaseHistoryValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseHistoryValidationError{}

// Validate checks the field values on GetReleaseStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseStatusReqMultiError, or nil if none found.
func (m *GetReleaseStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetReleaseStatusReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseStatusReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseStatusReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetReleaseStatusReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetReleaseStatusReqMultiError(errors)
	}

	return nil
}

// GetReleaseStatusReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseStatusReq.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseStatusReqMultiError) AllErrors() []error { return m }

// GetReleaseStatusReqValidationError is the validation error returned by
// GetReleaseStatusReq.Validate if the designated constraints aren't met.
type GetReleaseStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseStatusReqValidationError) ErrorName() string {
	return "GetReleaseStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseStatusReqValidationError{}

// Validate checks the field values on CommonResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonRespMultiError, or
// nil if none found.
func (m *CommonResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return CommonRespMultiError(errors)
	}

	return nil
}

// CommonRespMultiError is an error wrapping multiple validation errors
// returned by CommonResp.ValidateAll() if the designated constraints aren't met.
type CommonRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonRespMultiError) AllErrors() []error { return m }

// CommonRespValidationError is the validation error returned by
// CommonResp.Validate if the designated constraints aren't met.
type CommonRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonRespValidationError) ErrorName() string { return "CommonRespValidationError" }

// Error satisfies the builtin error interface
func (e CommonRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonRespValidationError{}

// Validate checks the field values on CommonListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonListRespMultiError,
// or nil if none found.
func (m *CommonListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return CommonListRespMultiError(errors)
	}

	return nil
}

// CommonListRespMultiError is an error wrapping multiple validation errors
// returned by CommonListResp.ValidateAll() if the designated constraints
// aren't met.
type CommonListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonListRespMultiError) AllErrors() []error { return m }

// CommonListRespValidationError is the validation error returned by
// CommonListResp.Validate if the designated constraints aren't met.
type CommonListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonListRespValidationError) ErrorName() string { return "CommonListRespValidationError" }

// Error satisfies the builtin error interface
func (e CommonListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonListRespValidationError{}

// Validate checks the field values on WebAnnotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebAnnotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAnnotations with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebAnnotationsMultiError,
// or nil if none found.
func (m *WebAnnotations) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAnnotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPerms()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebAnnotationsValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebAnnotationsValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerms()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebAnnotationsValidationError{
				field:  "Perms",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WebAnnotationsMultiError(errors)
	}

	return nil
}

// WebAnnotationsMultiError is an error wrapping multiple validation errors
// returned by WebAnnotations.ValidateAll() if the designated constraints
// aren't met.
type WebAnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAnnotationsMultiError) AllErrors() []error { return m }

// WebAnnotationsValidationError is the validation error returned by
// WebAnnotations.Validate if the designated constraints aren't met.
type WebAnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAnnotationsValidationError) ErrorName() string { return "WebAnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e WebAnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAnnotationsValidationError{}
