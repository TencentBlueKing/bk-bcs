// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: bcs-helm-manager.proto

package helmmanager

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AvailableReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AvailableReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvailableReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailableReqMultiError, or
// nil if none found.
func (m *AvailableReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AvailableReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AvailableReqMultiError(errors)
	}

	return nil
}

// AvailableReqMultiError is an error wrapping multiple validation errors
// returned by AvailableReq.ValidateAll() if the designated constraints aren't met.
type AvailableReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailableReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailableReqMultiError) AllErrors() []error { return m }

// AvailableReqValidationError is the validation error returned by
// AvailableReq.Validate if the designated constraints aren't met.
type AvailableReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailableReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailableReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailableReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailableReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailableReqValidationError) ErrorName() string { return "AvailableReqValidationError" }

// Error satisfies the builtin error interface
func (e AvailableReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailableReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailableReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailableReqValidationError{}

// Validate checks the field values on AvailableResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AvailableResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvailableResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailableRespMultiError, or
// nil if none found.
func (m *AvailableResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AvailableResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return AvailableRespMultiError(errors)
	}

	return nil
}

// AvailableRespMultiError is an error wrapping multiple validation errors
// returned by AvailableResp.ValidateAll() if the designated constraints
// aren't met.
type AvailableRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailableRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailableRespMultiError) AllErrors() []error { return m }

// AvailableRespValidationError is the validation error returned by
// AvailableResp.Validate if the designated constraints aren't met.
type AvailableRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailableRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailableRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailableRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailableRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailableRespValidationError) ErrorName() string { return "AvailableRespValidationError" }

// Error satisfies the builtin error interface
func (e AvailableRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailableResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailableRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailableRespValidationError{}

// Validate checks the field values on CreateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryReqMultiError, or nil if none found.
func (m *CreateRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := CreateRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := CreateRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	// no validation rules for Takeover

	// no validation rules for RepoURL

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for RemoteUsername

	// no validation rules for RemotePassword

	if len(errors) > 0 {
		return CreateRepositoryReqMultiError(errors)
	}

	return nil
}

// CreateRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by CreateRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type CreateRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryReqMultiError) AllErrors() []error { return m }

// CreateRepositoryReqValidationError is the validation error returned by
// CreateRepositoryReq.Validate if the designated constraints aren't met.
type CreateRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryReqValidationError) ErrorName() string {
	return "CreateRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryReqValidationError{}

// Validate checks the field values on CreateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryRespMultiError, or nil if none found.
func (m *CreateRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRepositoryRespMultiError(errors)
	}

	return nil
}

// CreateRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by CreateRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type CreateRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryRespMultiError) AllErrors() []error { return m }

// CreateRepositoryRespValidationError is the validation error returned by
// CreateRepositoryResp.Validate if the designated constraints aren't met.
type CreateRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryRespValidationError) ErrorName() string {
	return "CreateRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryRespValidationError{}

// Validate checks the field values on UpdateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRepositoryReqMultiError, or nil if none found.
func (m *UpdateRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UpdateRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := UpdateRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return UpdateRepositoryReqMultiError(errors)
	}

	return nil
}

// UpdateRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by UpdateRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryReqMultiError) AllErrors() []error { return m }

// UpdateRepositoryReqValidationError is the validation error returned by
// UpdateRepositoryReq.Validate if the designated constraints aren't met.
type UpdateRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryReqValidationError) ErrorName() string {
	return "UpdateRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryReqValidationError{}

// Validate checks the field values on UpdateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRepositoryRespMultiError, or nil if none found.
func (m *UpdateRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRepositoryRespMultiError(errors)
	}

	return nil
}

// UpdateRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by UpdateRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type UpdateRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryRespMultiError) AllErrors() []error { return m }

// UpdateRepositoryRespValidationError is the validation error returned by
// UpdateRepositoryResp.Validate if the designated constraints aren't met.
type UpdateRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryRespValidationError) ErrorName() string {
	return "UpdateRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryRespValidationError{}

// Validate checks the field values on GetRepositoryReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryReqMultiError, or nil if none found.
func (m *GetRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := GetRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRepositoryReqMultiError(errors)
	}

	return nil
}

// GetRepositoryReqMultiError is an error wrapping multiple validation errors
// returned by GetRepositoryReq.ValidateAll() if the designated constraints
// aren't met.
type GetRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryReqMultiError) AllErrors() []error { return m }

// GetRepositoryReqValidationError is the validation error returned by
// GetRepositoryReq.Validate if the designated constraints aren't met.
type GetRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryReqValidationError) ErrorName() string { return "GetRepositoryReqValidationError" }

// Error satisfies the builtin error interface
func (e GetRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryReqValidationError{}

// Validate checks the field values on GetRepositoryResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryRespMultiError, or nil if none found.
func (m *GetRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRepositoryRespMultiError(errors)
	}

	return nil
}

// GetRepositoryRespMultiError is an error wrapping multiple validation errors
// returned by GetRepositoryResp.ValidateAll() if the designated constraints
// aren't met.
type GetRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryRespMultiError) AllErrors() []error { return m }

// GetRepositoryRespValidationError is the validation error returned by
// GetRepositoryResp.Validate if the designated constraints aren't met.
type GetRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryRespValidationError) ErrorName() string {
	return "GetRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryRespValidationError{}

// Validate checks the field values on ListRepositoryReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryReqMultiError, or nil if none found.
func (m *ListRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRepositoryReqMultiError(errors)
	}

	return nil
}

// ListRepositoryReqMultiError is an error wrapping multiple validation errors
// returned by ListRepositoryReq.ValidateAll() if the designated constraints
// aren't met.
type ListRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryReqMultiError) AllErrors() []error { return m }

// ListRepositoryReqValidationError is the validation error returned by
// ListRepositoryReq.Validate if the designated constraints aren't met.
type ListRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryReqValidationError) ErrorName() string {
	return "ListRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryReqValidationError{}

// Validate checks the field values on ListRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryRespMultiError, or nil if none found.
func (m *ListRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRepositoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRepositoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRepositoryRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRepositoryRespMultiError(errors)
	}

	return nil
}

// ListRepositoryRespMultiError is an error wrapping multiple validation errors
// returned by ListRepositoryResp.ValidateAll() if the designated constraints
// aren't met.
type ListRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryRespMultiError) AllErrors() []error { return m }

// ListRepositoryRespValidationError is the validation error returned by
// ListRepositoryResp.Validate if the designated constraints aren't met.
type ListRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryRespValidationError) ErrorName() string {
	return "ListRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryRespValidationError{}

// Validate checks the field values on DeleteRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepositoryReqMultiError, or nil if none found.
func (m *DeleteRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DeleteRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := DeleteRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRepositoryReqMultiError(errors)
	}

	return nil
}

// DeleteRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by DeleteRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepositoryReqMultiError) AllErrors() []error { return m }

// DeleteRepositoryReqValidationError is the validation error returned by
// DeleteRepositoryReq.Validate if the designated constraints aren't met.
type DeleteRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepositoryReqValidationError) ErrorName() string {
	return "DeleteRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepositoryReqValidationError{}

// Validate checks the field values on DeleteRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepositoryRespMultiError, or nil if none found.
func (m *DeleteRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return DeleteRepositoryRespMultiError(errors)
	}

	return nil
}

// DeleteRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by DeleteRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepositoryRespMultiError) AllErrors() []error { return m }

// DeleteRepositoryRespValidationError is the validation error returned by
// DeleteRepositoryResp.Validate if the designated constraints aren't met.
type DeleteRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepositoryRespValidationError) ErrorName() string {
	return "DeleteRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepositoryRespValidationError{}

// Validate checks the field values on Repository with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Repository) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Repository with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepositoryMultiError, or
// nil if none found.
func (m *Repository) ValidateAll() error {
	return m.validate(true)
}

func (m *Repository) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for RepoURL

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for RemoteUsername

	// no validation rules for RemotePassword

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return RepositoryMultiError(errors)
	}

	return nil
}

// RepositoryMultiError is an error wrapping multiple validation errors
// returned by Repository.ValidateAll() if the designated constraints aren't met.
type RepositoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepositoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepositoryMultiError) AllErrors() []error { return m }

// RepositoryValidationError is the validation error returned by
// Repository.Validate if the designated constraints aren't met.
type RepositoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepositoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepositoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepositoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepositoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepositoryValidationError) ErrorName() string { return "RepositoryValidationError" }

// Error satisfies the builtin error interface
func (e RepositoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepository.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepositoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepositoryValidationError{}

// Validate checks the field values on ListChartReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListChartReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListChartReqMultiError, or
// nil if none found.
func (m *ListChartReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := ListChartReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := ListChartReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListChartReqMultiError(errors)
	}

	return nil
}

// ListChartReqMultiError is an error wrapping multiple validation errors
// returned by ListChartReq.ValidateAll() if the designated constraints aren't met.
type ListChartReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartReqMultiError) AllErrors() []error { return m }

// ListChartReqValidationError is the validation error returned by
// ListChartReq.Validate if the designated constraints aren't met.
type ListChartReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartReqValidationError) ErrorName() string { return "ListChartReqValidationError" }

// Error satisfies the builtin error interface
func (e ListChartReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartReqValidationError{}

// Validate checks the field values on ListChartResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListChartResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListChartRespMultiError, or
// nil if none found.
func (m *ListChartResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListChartRespMultiError(errors)
	}

	return nil
}

// ListChartRespMultiError is an error wrapping multiple validation errors
// returned by ListChartResp.ValidateAll() if the designated constraints
// aren't met.
type ListChartRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartRespMultiError) AllErrors() []error { return m }

// ListChartRespValidationError is the validation error returned by
// ListChartResp.Validate if the designated constraints aren't met.
type ListChartRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartRespValidationError) ErrorName() string { return "ListChartRespValidationError" }

// Error satisfies the builtin error interface
func (e ListChartRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartRespValidationError{}

// Validate checks the field values on ChartListData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartListData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartListDataMultiError, or
// nil if none found.
func (m *ChartListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChartListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChartListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChartListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChartListDataMultiError(errors)
	}

	return nil
}

// ChartListDataMultiError is an error wrapping multiple validation errors
// returned by ChartListData.ValidateAll() if the designated constraints
// aren't met.
type ChartListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartListDataMultiError) AllErrors() []error { return m }

// ChartListDataValidationError is the validation error returned by
// ChartListData.Validate if the designated constraints aren't met.
type ChartListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartListDataValidationError) ErrorName() string { return "ChartListDataValidationError" }

// Error satisfies the builtin error interface
func (e ChartListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartListDataValidationError{}

// Validate checks the field values on Chart with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Chart) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Chart with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChartMultiError, or nil if none found.
func (m *Chart) ValidateAll() error {
	return m.validate(true)
}

func (m *Chart) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for Repository

	// no validation rules for Type

	// no validation rules for Key

	// no validation rules for Name

	// no validation rules for LatestVersion

	// no validation rules for LatestAppVersion

	// no validation rules for LatestDescription

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return ChartMultiError(errors)
	}

	return nil
}

// ChartMultiError is an error wrapping multiple validation errors returned by
// Chart.ValidateAll() if the designated constraints aren't met.
type ChartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartMultiError) AllErrors() []error { return m }

// ChartValidationError is the validation error returned by Chart.Validate if
// the designated constraints aren't met.
type ChartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartValidationError) ErrorName() string { return "ChartValidationError" }

// Error satisfies the builtin error interface
func (e ChartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartValidationError{}

// Validate checks the field values on ListChartVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChartVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartVersionReqMultiError, or nil if none found.
func (m *ListChartVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := ListChartVersionReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := ListChartVersionReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := ListChartVersionReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return ListChartVersionReqMultiError(errors)
	}

	return nil
}

// ListChartVersionReqMultiError is an error wrapping multiple validation
// errors returned by ListChartVersionReq.ValidateAll() if the designated
// constraints aren't met.
type ListChartVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartVersionReqMultiError) AllErrors() []error { return m }

// ListChartVersionReqValidationError is the validation error returned by
// ListChartVersionReq.Validate if the designated constraints aren't met.
type ListChartVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartVersionReqValidationError) ErrorName() string {
	return "ListChartVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListChartVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartVersionReqValidationError{}

// Validate checks the field values on ListChartVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChartVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartVersionRespMultiError, or nil if none found.
func (m *ListChartVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartVersionRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartVersionRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartVersionRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListChartVersionRespMultiError(errors)
	}

	return nil
}

// ListChartVersionRespMultiError is an error wrapping multiple validation
// errors returned by ListChartVersionResp.ValidateAll() if the designated
// constraints aren't met.
type ListChartVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartVersionRespMultiError) AllErrors() []error { return m }

// ListChartVersionRespValidationError is the validation error returned by
// ListChartVersionResp.Validate if the designated constraints aren't met.
type ListChartVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartVersionRespValidationError) ErrorName() string {
	return "ListChartVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListChartVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartVersionRespValidationError{}

// Validate checks the field values on ChartVersionListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChartVersionListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartVersionListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChartVersionListDataMultiError, or nil if none found.
func (m *ChartVersionListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartVersionListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChartVersionListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChartVersionListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChartVersionListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChartVersionListDataMultiError(errors)
	}

	return nil
}

// ChartVersionListDataMultiError is an error wrapping multiple validation
// errors returned by ChartVersionListData.ValidateAll() if the designated
// constraints aren't met.
type ChartVersionListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartVersionListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartVersionListDataMultiError) AllErrors() []error { return m }

// ChartVersionListDataValidationError is the validation error returned by
// ChartVersionListData.Validate if the designated constraints aren't met.
type ChartVersionListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartVersionListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartVersionListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartVersionListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartVersionListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartVersionListDataValidationError) ErrorName() string {
	return "ChartVersionListDataValidationError"
}

// Error satisfies the builtin error interface
func (e ChartVersionListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartVersionListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartVersionListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartVersionListDataValidationError{}

// Validate checks the field values on ChartVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartVersion with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartVersionMultiError, or
// nil if none found.
func (m *ChartVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for AppVersion

	// no validation rules for Description

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return ChartVersionMultiError(errors)
	}

	return nil
}

// ChartVersionMultiError is an error wrapping multiple validation errors
// returned by ChartVersion.ValidateAll() if the designated constraints aren't met.
type ChartVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartVersionMultiError) AllErrors() []error { return m }

// ChartVersionValidationError is the validation error returned by
// ChartVersion.Validate if the designated constraints aren't met.
type ChartVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartVersionValidationError) ErrorName() string { return "ChartVersionValidationError" }

// Error satisfies the builtin error interface
func (e ChartVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartVersionValidationError{}

// Validate checks the field values on GetChartDetailReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetChartDetailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartDetailReqMultiError, or nil if none found.
func (m *GetChartDetailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartDetailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := GetChartDetailReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := GetChartDetailReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetChartDetailReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := GetChartDetailReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return GetChartDetailReqMultiError(errors)
	}

	return nil
}

// GetChartDetailReqMultiError is an error wrapping multiple validation errors
// returned by GetChartDetailReq.ValidateAll() if the designated constraints
// aren't met.
type GetChartDetailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartDetailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartDetailReqMultiError) AllErrors() []error { return m }

// GetChartDetailReqValidationError is the validation error returned by
// GetChartDetailReq.Validate if the designated constraints aren't met.
type GetChartDetailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartDetailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartDetailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartDetailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartDetailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartDetailReqValidationError) ErrorName() string {
	return "GetChartDetailReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartDetailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartDetailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartDetailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartDetailReqValidationError{}

// Validate checks the field values on GetChartDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartDetailResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartDetailRespMultiError, or nil if none found.
func (m *GetChartDetailResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartDetailResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetChartDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetChartDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetChartDetailRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetChartDetailRespMultiError(errors)
	}

	return nil
}

// GetChartDetailRespMultiError is an error wrapping multiple validation errors
// returned by GetChartDetailResp.ValidateAll() if the designated constraints
// aren't met.
type GetChartDetailRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartDetailRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartDetailRespMultiError) AllErrors() []error { return m }

// GetChartDetailRespValidationError is the validation error returned by
// GetChartDetailResp.Validate if the designated constraints aren't met.
type GetChartDetailRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartDetailRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartDetailRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartDetailRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartDetailRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartDetailRespValidationError) ErrorName() string {
	return "GetChartDetailRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartDetailRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartDetailResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartDetailRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartDetailRespValidationError{}

// Validate checks the field values on ChartDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartDetailMultiError, or
// nil if none found.
func (m *ChartDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Readme

	{
		sorted_keys := make([]string, len(m.GetContents()))
		i := 0
		for key := range m.GetContents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetContents()[key]
			_ = val

			// no validation rules for Contents[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ChartDetailValidationError{
							field:  fmt.Sprintf("Contents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ChartDetailValidationError{
							field:  fmt.Sprintf("Contents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ChartDetailValidationError{
						field:  fmt.Sprintf("Contents[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ChartDetailMultiError(errors)
	}

	return nil
}

// ChartDetailMultiError is an error wrapping multiple validation errors
// returned by ChartDetail.ValidateAll() if the designated constraints aren't met.
type ChartDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartDetailMultiError) AllErrors() []error { return m }

// ChartDetailValidationError is the validation error returned by
// ChartDetail.Validate if the designated constraints aren't met.
type ChartDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartDetailValidationError) ErrorName() string { return "ChartDetailValidationError" }

// Error satisfies the builtin error interface
func (e ChartDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartDetailValidationError{}

// Validate checks the field values on FileContent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileContent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileContent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileContentMultiError, or
// nil if none found.
func (m *FileContent) ValidateAll() error {
	return m.validate(true)
}

func (m *FileContent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Content

	if len(errors) > 0 {
		return FileContentMultiError(errors)
	}

	return nil
}

// FileContentMultiError is an error wrapping multiple validation errors
// returned by FileContent.ValidateAll() if the designated constraints aren't met.
type FileContentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileContentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileContentMultiError) AllErrors() []error { return m }

// FileContentValidationError is the validation error returned by
// FileContent.Validate if the designated constraints aren't met.
type FileContentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileContentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileContentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileContentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileContentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileContentValidationError) ErrorName() string { return "FileContentValidationError" }

// Error satisfies the builtin error interface
func (e FileContentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileContent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileContentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileContentValidationError{}

// Validate checks the field values on ListReleaseReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReleaseReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListReleaseReqMultiError,
// or nil if none found.
func (m *ListReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := ListReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for Name

	if len(errors) > 0 {
		return ListReleaseReqMultiError(errors)
	}

	return nil
}

// ListReleaseReqMultiError is an error wrapping multiple validation errors
// returned by ListReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type ListReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReleaseReqMultiError) AllErrors() []error { return m }

// ListReleaseReqValidationError is the validation error returned by
// ListReleaseReq.Validate if the designated constraints aren't met.
type ListReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReleaseReqValidationError) ErrorName() string { return "ListReleaseReqValidationError" }

// Error satisfies the builtin error interface
func (e ListReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReleaseReqValidationError{}

// Validate checks the field values on ListReleaseResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReleaseRespMultiError, or nil if none found.
func (m *ListReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReleaseRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListReleaseRespMultiError(errors)
	}

	return nil
}

// ListReleaseRespMultiError is an error wrapping multiple validation errors
// returned by ListReleaseResp.ValidateAll() if the designated constraints
// aren't met.
type ListReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReleaseRespMultiError) AllErrors() []error { return m }

// ListReleaseRespValidationError is the validation error returned by
// ListReleaseResp.Validate if the designated constraints aren't met.
type ListReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReleaseRespValidationError) ErrorName() string { return "ListReleaseRespValidationError" }

// Error satisfies the builtin error interface
func (e ListReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReleaseRespValidationError{}

// Validate checks the field values on GetReleaseDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseDetailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseDetailReqMultiError, or nil if none found.
func (m *GetReleaseDetailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseDetailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseDetailReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseDetailReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetReleaseDetailReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetReleaseDetailReqMultiError(errors)
	}

	return nil
}

// GetReleaseDetailReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseDetailReq.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseDetailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseDetailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseDetailReqMultiError) AllErrors() []error { return m }

// GetReleaseDetailReqValidationError is the validation error returned by
// GetReleaseDetailReq.Validate if the designated constraints aren't met.
type GetReleaseDetailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseDetailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseDetailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseDetailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseDetailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseDetailReqValidationError) ErrorName() string {
	return "GetReleaseDetailReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseDetailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseDetailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseDetailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseDetailReqValidationError{}

// Validate checks the field values on GetReleaseDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseDetailResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseDetailRespMultiError, or nil if none found.
func (m *GetReleaseDetailResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseDetailResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReleaseDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReleaseDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReleaseDetailRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReleaseDetailRespMultiError(errors)
	}

	return nil
}

// GetReleaseDetailRespMultiError is an error wrapping multiple validation
// errors returned by GetReleaseDetailResp.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseDetailRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseDetailRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseDetailRespMultiError) AllErrors() []error { return m }

// GetReleaseDetailRespValidationError is the validation error returned by
// GetReleaseDetailResp.Validate if the designated constraints aren't met.
type GetReleaseDetailRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseDetailRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseDetailRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseDetailRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseDetailRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseDetailRespValidationError) ErrorName() string {
	return "GetReleaseDetailRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseDetailRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseDetailResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseDetailRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseDetailRespValidationError{}

// Validate checks the field values on ReleaseListData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReleaseListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleaseListDataMultiError, or nil if none found.
func (m *ReleaseListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReleaseListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReleaseListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReleaseListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReleaseListDataMultiError(errors)
	}

	return nil
}

// ReleaseListDataMultiError is an error wrapping multiple validation errors
// returned by ReleaseListData.ValidateAll() if the designated constraints
// aren't met.
type ReleaseListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseListDataMultiError) AllErrors() []error { return m }

// ReleaseListDataValidationError is the validation error returned by
// ReleaseListData.Validate if the designated constraints aren't met.
type ReleaseListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseListDataValidationError) ErrorName() string { return "ReleaseListDataValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseListDataValidationError{}

// Validate checks the field values on Release with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Release) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Release with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReleaseMultiError, or nil if none found.
func (m *Release) ValidateAll() error {
	return m.validate(true)
}

func (m *Release) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Revision

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for AppVersion

	// no validation rules for UpdateTime

	// no validation rules for ChartVersion

	if len(errors) > 0 {
		return ReleaseMultiError(errors)
	}

	return nil
}

// ReleaseMultiError is an error wrapping multiple validation errors returned
// by Release.ValidateAll() if the designated constraints aren't met.
type ReleaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseMultiError) AllErrors() []error { return m }

// ReleaseValidationError is the validation error returned by Release.Validate
// if the designated constraints aren't met.
type ReleaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseValidationError) ErrorName() string { return "ReleaseValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelease.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseValidationError{}

// Validate checks the field values on ReleaseDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseDetailMultiError, or
// nil if none found.
func (m *ReleaseDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Revision

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for AppVersion

	// no validation rules for UpdateTime

	// no validation rules for ChartVersion

	if len(errors) > 0 {
		return ReleaseDetailMultiError(errors)
	}

	return nil
}

// ReleaseDetailMultiError is an error wrapping multiple validation errors
// returned by ReleaseDetail.ValidateAll() if the designated constraints
// aren't met.
type ReleaseDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseDetailMultiError) AllErrors() []error { return m }

// ReleaseDetailValidationError is the validation error returned by
// ReleaseDetail.Validate if the designated constraints aren't met.
type ReleaseDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseDetailValidationError) ErrorName() string { return "ReleaseDetailValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseDetailValidationError{}

// Validate checks the field values on InstallReleaseReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InstallReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallReleaseReqMultiError, or nil if none found.
func (m *InstallReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetChart()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Chart",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := InstallReleaseReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	// no validation rules for BcsSysVar

	if len(errors) > 0 {
		return InstallReleaseReqMultiError(errors)
	}

	return nil
}

// InstallReleaseReqMultiError is an error wrapping multiple validation errors
// returned by InstallReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type InstallReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallReleaseReqMultiError) AllErrors() []error { return m }

// InstallReleaseReqValidationError is the validation error returned by
// InstallReleaseReq.Validate if the designated constraints aren't met.
type InstallReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallReleaseReqValidationError) ErrorName() string {
	return "InstallReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e InstallReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallReleaseReqValidationError{}

// Validate checks the field values on InstallReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallReleaseRespMultiError, or nil if none found.
func (m *InstallReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstallReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstallReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstallReleaseRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstallReleaseRespMultiError(errors)
	}

	return nil
}

// InstallReleaseRespMultiError is an error wrapping multiple validation errors
// returned by InstallReleaseResp.ValidateAll() if the designated constraints
// aren't met.
type InstallReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallReleaseRespMultiError) AllErrors() []error { return m }

// InstallReleaseRespValidationError is the validation error returned by
// InstallReleaseResp.Validate if the designated constraints aren't met.
type InstallReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallReleaseRespValidationError) ErrorName() string {
	return "InstallReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e InstallReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallReleaseRespValidationError{}

// Validate checks the field values on UninstallReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallReleaseReqMultiError, or nil if none found.
func (m *UninstallReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := UninstallReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := UninstallReleaseReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UninstallReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return UninstallReleaseReqMultiError(errors)
	}

	return nil
}

// UninstallReleaseReqMultiError is an error wrapping multiple validation
// errors returned by UninstallReleaseReq.ValidateAll() if the designated
// constraints aren't met.
type UninstallReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallReleaseReqMultiError) AllErrors() []error { return m }

// UninstallReleaseReqValidationError is the validation error returned by
// UninstallReleaseReq.Validate if the designated constraints aren't met.
type UninstallReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallReleaseReqValidationError) ErrorName() string {
	return "UninstallReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallReleaseReqValidationError{}

// Validate checks the field values on UninstallReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallReleaseRespMultiError, or nil if none found.
func (m *UninstallReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return UninstallReleaseRespMultiError(errors)
	}

	return nil
}

// UninstallReleaseRespMultiError is an error wrapping multiple validation
// errors returned by UninstallReleaseResp.ValidateAll() if the designated
// constraints aren't met.
type UninstallReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallReleaseRespMultiError) AllErrors() []error { return m }

// UninstallReleaseRespValidationError is the validation error returned by
// UninstallReleaseResp.Validate if the designated constraints aren't met.
type UninstallReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallReleaseRespValidationError) ErrorName() string {
	return "UninstallReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallReleaseRespValidationError{}

// Validate checks the field values on UpgradeReleaseReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpgradeReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeReleaseReqMultiError, or nil if none found.
func (m *UpgradeReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectID()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "ProjectID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetChart()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Chart",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVersion()); l < 1 || l > 64 {
		err := UpgradeReleaseReqValidationError{
			field:  "Version",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Operator

	// no validation rules for BcsSysVar

	if len(errors) > 0 {
		return UpgradeReleaseReqMultiError(errors)
	}

	return nil
}

// UpgradeReleaseReqMultiError is an error wrapping multiple validation errors
// returned by UpgradeReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type UpgradeReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeReleaseReqMultiError) AllErrors() []error { return m }

// UpgradeReleaseReqValidationError is the validation error returned by
// UpgradeReleaseReq.Validate if the designated constraints aren't met.
type UpgradeReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeReleaseReqValidationError) ErrorName() string {
	return "UpgradeReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeReleaseReqValidationError{}

// Validate checks the field values on UpgradeReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradeReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeReleaseRespMultiError, or nil if none found.
func (m *UpgradeReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeReleaseRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeReleaseRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpgradeReleaseRespMultiError(errors)
	}

	return nil
}

// UpgradeReleaseRespMultiError is an error wrapping multiple validation errors
// returned by UpgradeReleaseResp.ValidateAll() if the designated constraints
// aren't met.
type UpgradeReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeReleaseRespMultiError) AllErrors() []error { return m }

// UpgradeReleaseRespValidationError is the validation error returned by
// UpgradeReleaseResp.Validate if the designated constraints aren't met.
type UpgradeReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeReleaseRespValidationError) ErrorName() string {
	return "UpgradeReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeReleaseRespValidationError{}

// Validate checks the field values on RollbackReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackReleaseReqMultiError, or nil if none found.
func (m *RollbackReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := RollbackReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := RollbackReleaseReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := RollbackReleaseReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Revision

	// no validation rules for Operator

	if len(errors) > 0 {
		return RollbackReleaseReqMultiError(errors)
	}

	return nil
}

// RollbackReleaseReqMultiError is an error wrapping multiple validation errors
// returned by RollbackReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type RollbackReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackReleaseReqMultiError) AllErrors() []error { return m }

// RollbackReleaseReqValidationError is the validation error returned by
// RollbackReleaseReq.Validate if the designated constraints aren't met.
type RollbackReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackReleaseReqValidationError) ErrorName() string {
	return "RollbackReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackReleaseReqValidationError{}

// Validate checks the field values on RollbackReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackReleaseRespMultiError, or nil if none found.
func (m *RollbackReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return RollbackReleaseRespMultiError(errors)
	}

	return nil
}

// RollbackReleaseRespMultiError is an error wrapping multiple validation
// errors returned by RollbackReleaseResp.ValidateAll() if the designated
// constraints aren't met.
type RollbackReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackReleaseRespMultiError) AllErrors() []error { return m }

// RollbackReleaseRespValidationError is the validation error returned by
// RollbackReleaseResp.Validate if the designated constraints aren't met.
type RollbackReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackReleaseRespValidationError) ErrorName() string {
	return "RollbackReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackReleaseRespValidationError{}

// Validate checks the field values on GetReleaseHistoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseHistoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseHistoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseHistoryReqMultiError, or nil if none found.
func (m *GetReleaseHistoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseHistoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := GetReleaseHistoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseHistoryReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseHistoryReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetReleaseHistoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetReleaseHistoryReqMultiError(errors)
	}

	return nil
}

// GetReleaseHistoryReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseHistoryReq.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseHistoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseHistoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseHistoryReqMultiError) AllErrors() []error { return m }

// GetReleaseHistoryReqValidationError is the validation error returned by
// GetReleaseHistoryReq.Validate if the designated constraints aren't met.
type GetReleaseHistoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseHistoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseHistoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseHistoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseHistoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseHistoryReqValidationError) ErrorName() string {
	return "GetReleaseHistoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseHistoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseHistoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseHistoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseHistoryReqValidationError{}

// Validate checks the field values on GetReleaseHistoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseHistoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseHistoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseHistoryRespMultiError, or nil if none found.
func (m *GetReleaseHistoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseHistoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReleaseHistoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReleaseHistoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReleaseHistoryRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetReleaseHistoryRespMultiError(errors)
	}

	return nil
}

// GetReleaseHistoryRespMultiError is an error wrapping multiple validation
// errors returned by GetReleaseHistoryResp.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseHistoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseHistoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseHistoryRespMultiError) AllErrors() []error { return m }

// GetReleaseHistoryRespValidationError is the validation error returned by
// GetReleaseHistoryResp.Validate if the designated constraints aren't met.
type GetReleaseHistoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseHistoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseHistoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseHistoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseHistoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseHistoryRespValidationError) ErrorName() string {
	return "GetReleaseHistoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseHistoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseHistoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseHistoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseHistoryRespValidationError{}

// Validate checks the field values on ReleaseHistory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseHistoryMultiError,
// or nil if none found.
func (m *ReleaseHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Revision

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for UpdateTime

	// no validation rules for Description

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for ChartVersion

	// no validation rules for AppVersion

	// no validation rules for Values

	if len(errors) > 0 {
		return ReleaseHistoryMultiError(errors)
	}

	return nil
}

// ReleaseHistoryMultiError is an error wrapping multiple validation errors
// returned by ReleaseHistory.ValidateAll() if the designated constraints
// aren't met.
type ReleaseHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseHistoryMultiError) AllErrors() []error { return m }

// ReleaseHistoryValidationError is the validation error returned by
// ReleaseHistory.Validate if the designated constraints aren't met.
type ReleaseHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseHistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseHistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseHistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseHistoryValidationError) ErrorName() string { return "ReleaseHistoryValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseHistoryValidationError{}
