// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: bcs-helm-manager.proto

package helmmanager

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CommonResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonRespMultiError, or
// nil if none found.
func (m *CommonResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommonRespMultiError(errors)
	}

	return nil
}

// CommonRespMultiError is an error wrapping multiple validation errors
// returned by CommonResp.ValidateAll() if the designated constraints aren't met.
type CommonRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonRespMultiError) AllErrors() []error { return m }

// CommonRespValidationError is the validation error returned by
// CommonResp.Validate if the designated constraints aren't met.
type CommonRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonRespValidationError) ErrorName() string { return "CommonRespValidationError" }

// Error satisfies the builtin error interface
func (e CommonRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonRespValidationError{}

// Validate checks the field values on CommonListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonListRespMultiError,
// or nil if none found.
func (m *CommonListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommonListRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommonListRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommonListRespMultiError(errors)
	}

	return nil
}

// CommonListRespMultiError is an error wrapping multiple validation errors
// returned by CommonListResp.ValidateAll() if the designated constraints
// aren't met.
type CommonListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonListRespMultiError) AllErrors() []error { return m }

// CommonListRespValidationError is the validation error returned by
// CommonListResp.Validate if the designated constraints aren't met.
type CommonListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonListRespValidationError) ErrorName() string { return "CommonListRespValidationError" }

// Error satisfies the builtin error interface
func (e CommonListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonListRespValidationError{}

// Validate checks the field values on WebAnnotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebAnnotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAnnotations with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebAnnotationsMultiError,
// or nil if none found.
func (m *WebAnnotations) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAnnotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPerms()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebAnnotationsValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebAnnotationsValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerms()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebAnnotationsValidationError{
				field:  "Perms",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WebAnnotationsMultiError(errors)
	}

	return nil
}

// WebAnnotationsMultiError is an error wrapping multiple validation errors
// returned by WebAnnotations.ValidateAll() if the designated constraints
// aren't met.
type WebAnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAnnotationsMultiError) AllErrors() []error { return m }

// WebAnnotationsValidationError is the validation error returned by
// WebAnnotations.Validate if the designated constraints aren't met.
type WebAnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAnnotationsValidationError) ErrorName() string { return "WebAnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e WebAnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAnnotationsValidationError{}

// Validate checks the field values on AvailableReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AvailableReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvailableReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailableReqMultiError, or
// nil if none found.
func (m *AvailableReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AvailableReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AvailableReqMultiError(errors)
	}

	return nil
}

// AvailableReqMultiError is an error wrapping multiple validation errors
// returned by AvailableReq.ValidateAll() if the designated constraints aren't met.
type AvailableReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailableReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailableReqMultiError) AllErrors() []error { return m }

// AvailableReqValidationError is the validation error returned by
// AvailableReq.Validate if the designated constraints aren't met.
type AvailableReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailableReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailableReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailableReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailableReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailableReqValidationError) ErrorName() string { return "AvailableReqValidationError" }

// Error satisfies the builtin error interface
func (e AvailableReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailableReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailableReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailableReqValidationError{}

// Validate checks the field values on AvailableResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AvailableResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvailableResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailableRespMultiError, or
// nil if none found.
func (m *AvailableResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AvailableResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if len(errors) > 0 {
		return AvailableRespMultiError(errors)
	}

	return nil
}

// AvailableRespMultiError is an error wrapping multiple validation errors
// returned by AvailableResp.ValidateAll() if the designated constraints
// aren't met.
type AvailableRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailableRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailableRespMultiError) AllErrors() []error { return m }

// AvailableRespValidationError is the validation error returned by
// AvailableResp.Validate if the designated constraints aren't met.
type AvailableRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailableRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailableRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailableRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailableRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailableRespValidationError) ErrorName() string { return "AvailableRespValidationError" }

// Error satisfies the builtin error interface
func (e AvailableRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailableResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailableRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailableRespValidationError{}

// Validate checks the field values on CreateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryReqMultiError, or nil if none found.
func (m *CreateRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := CreateRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := CreateRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	// no validation rules for Takeover

	// no validation rules for RepoURL

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for RemoteUsername

	// no validation rules for RemotePassword

	// no validation rules for DisplayName

	if len(errors) > 0 {
		return CreateRepositoryReqMultiError(errors)
	}

	return nil
}

// CreateRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by CreateRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type CreateRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryReqMultiError) AllErrors() []error { return m }

// CreateRepositoryReqValidationError is the validation error returned by
// CreateRepositoryReq.Validate if the designated constraints aren't met.
type CreateRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryReqValidationError) ErrorName() string {
	return "CreateRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryReqValidationError{}

// Validate checks the field values on CreateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryRespMultiError, or nil if none found.
func (m *CreateRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepositoryRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRepositoryRespMultiError(errors)
	}

	return nil
}

// CreateRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by CreateRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type CreateRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryRespMultiError) AllErrors() []error { return m }

// CreateRepositoryRespValidationError is the validation error returned by
// CreateRepositoryResp.Validate if the designated constraints aren't met.
type CreateRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryRespValidationError) ErrorName() string {
	return "CreateRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryRespValidationError{}

// Validate checks the field values on UpdateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRepositoryReqMultiError, or nil if none found.
func (m *UpdateRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UpdateRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := UpdateRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return UpdateRepositoryReqMultiError(errors)
	}

	return nil
}

// UpdateRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by UpdateRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryReqMultiError) AllErrors() []error { return m }

// UpdateRepositoryReqValidationError is the validation error returned by
// UpdateRepositoryReq.Validate if the designated constraints aren't met.
type UpdateRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryReqValidationError) ErrorName() string {
	return "UpdateRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryReqValidationError{}

// Validate checks the field values on UpdateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRepositoryRespMultiError, or nil if none found.
func (m *UpdateRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRepositoryRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRepositoryRespMultiError(errors)
	}

	return nil
}

// UpdateRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by UpdateRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type UpdateRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryRespMultiError) AllErrors() []error { return m }

// UpdateRepositoryRespValidationError is the validation error returned by
// UpdateRepositoryResp.Validate if the designated constraints aren't met.
type UpdateRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryRespValidationError) ErrorName() string {
	return "UpdateRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryRespValidationError{}

// Validate checks the field values on GetRepositoryReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryReqMultiError, or nil if none found.
func (m *GetRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := GetRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRepositoryReqMultiError(errors)
	}

	return nil
}

// GetRepositoryReqMultiError is an error wrapping multiple validation errors
// returned by GetRepositoryReq.ValidateAll() if the designated constraints
// aren't met.
type GetRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryReqMultiError) AllErrors() []error { return m }

// GetRepositoryReqValidationError is the validation error returned by
// GetRepositoryReq.Validate if the designated constraints aren't met.
type GetRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryReqValidationError) ErrorName() string { return "GetRepositoryReqValidationError" }

// Error satisfies the builtin error interface
func (e GetRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryReqValidationError{}

// Validate checks the field values on GetRepositoryResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryRespMultiError, or nil if none found.
func (m *GetRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRepositoryRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRepositoryRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRepositoryRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRepositoryRespMultiError(errors)
	}

	return nil
}

// GetRepositoryRespMultiError is an error wrapping multiple validation errors
// returned by GetRepositoryResp.ValidateAll() if the designated constraints
// aren't met.
type GetRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryRespMultiError) AllErrors() []error { return m }

// GetRepositoryRespValidationError is the validation error returned by
// GetRepositoryResp.Validate if the designated constraints aren't met.
type GetRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryRespValidationError) ErrorName() string {
	return "GetRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryRespValidationError{}

// Validate checks the field values on ListRepositoryReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryReqMultiError, or nil if none found.
func (m *ListRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRepositoryReqMultiError(errors)
	}

	return nil
}

// ListRepositoryReqMultiError is an error wrapping multiple validation errors
// returned by ListRepositoryReq.ValidateAll() if the designated constraints
// aren't met.
type ListRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryReqMultiError) AllErrors() []error { return m }

// ListRepositoryReqValidationError is the validation error returned by
// ListRepositoryReq.Validate if the designated constraints aren't met.
type ListRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryReqValidationError) ErrorName() string {
	return "ListRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryReqValidationError{}

// Validate checks the field values on ListRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryRespMultiError, or nil if none found.
func (m *ListRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRepositoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRepositoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRepositoryRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRepositoryRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListRepositoryRespMultiError(errors)
	}

	return nil
}

// ListRepositoryRespMultiError is an error wrapping multiple validation errors
// returned by ListRepositoryResp.ValidateAll() if the designated constraints
// aren't met.
type ListRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryRespMultiError) AllErrors() []error { return m }

// ListRepositoryRespValidationError is the validation error returned by
// ListRepositoryResp.Validate if the designated constraints aren't met.
type ListRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryRespValidationError) ErrorName() string {
	return "ListRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryRespValidationError{}

// Validate checks the field values on DeleteRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepositoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepositoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepositoryReqMultiError, or nil if none found.
func (m *DeleteRepositoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepositoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DeleteRepositoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := DeleteRepositoryReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRepositoryReqMultiError(errors)
	}

	return nil
}

// DeleteRepositoryReqMultiError is an error wrapping multiple validation
// errors returned by DeleteRepositoryReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteRepositoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepositoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepositoryReqMultiError) AllErrors() []error { return m }

// DeleteRepositoryReqValidationError is the validation error returned by
// DeleteRepositoryReq.Validate if the designated constraints aren't met.
type DeleteRepositoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepositoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepositoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepositoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepositoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepositoryReqValidationError) ErrorName() string {
	return "DeleteRepositoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepositoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepositoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepositoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepositoryReqValidationError{}

// Validate checks the field values on DeleteRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepositoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepositoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepositoryRespMultiError, or nil if none found.
func (m *DeleteRepositoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepositoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRepositoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRepositoryRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteRepositoryRespMultiError(errors)
	}

	return nil
}

// DeleteRepositoryRespMultiError is an error wrapping multiple validation
// errors returned by DeleteRepositoryResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteRepositoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepositoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepositoryRespMultiError) AllErrors() []error { return m }

// DeleteRepositoryRespValidationError is the validation error returned by
// DeleteRepositoryResp.Validate if the designated constraints aren't met.
type DeleteRepositoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepositoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepositoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepositoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepositoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepositoryRespValidationError) ErrorName() string {
	return "DeleteRepositoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepositoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepositoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepositoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepositoryRespValidationError{}

// Validate checks the field values on Repository with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Repository) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Repository with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepositoryMultiError, or
// nil if none found.
func (m *Repository) ValidateAll() error {
	return m.validate(true)
}

func (m *Repository) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for RepoURL

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for Remote

	// no validation rules for RemoteURL

	// no validation rules for RemoteUsername

	// no validation rules for RemotePassword

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for DisplayName

	// no validation rules for Public

	if len(errors) > 0 {
		return RepositoryMultiError(errors)
	}

	return nil
}

// RepositoryMultiError is an error wrapping multiple validation errors
// returned by Repository.ValidateAll() if the designated constraints aren't met.
type RepositoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepositoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepositoryMultiError) AllErrors() []error { return m }

// RepositoryValidationError is the validation error returned by
// Repository.Validate if the designated constraints aren't met.
type RepositoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepositoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepositoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepositoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepositoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepositoryValidationError) ErrorName() string { return "RepositoryValidationError" }

// Error satisfies the builtin error interface
func (e RepositoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepository.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepositoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepositoryValidationError{}

// Validate checks the field values on ChartListData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartListData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartListDataMultiError, or
// nil if none found.
func (m *ChartListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChartListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChartListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChartListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChartListDataMultiError(errors)
	}

	return nil
}

// ChartListDataMultiError is an error wrapping multiple validation errors
// returned by ChartListData.ValidateAll() if the designated constraints
// aren't met.
type ChartListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartListDataMultiError) AllErrors() []error { return m }

// ChartListDataValidationError is the validation error returned by
// ChartListData.Validate if the designated constraints aren't met.
type ChartListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartListDataValidationError) ErrorName() string { return "ChartListDataValidationError" }

// Error satisfies the builtin error interface
func (e ChartListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartListDataValidationError{}

// Validate checks the field values on Chart with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Chart) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Chart with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChartMultiError, or nil if none found.
func (m *Chart) ValidateAll() error {
	return m.validate(true)
}

func (m *Chart) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for Repository

	// no validation rules for Type

	// no validation rules for Key

	// no validation rules for Name

	// no validation rules for LatestVersion

	// no validation rules for LatestAppVersion

	// no validation rules for LatestDescription

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for ProjectCode

	// no validation rules for Icon

	if len(errors) > 0 {
		return ChartMultiError(errors)
	}

	return nil
}

// ChartMultiError is an error wrapping multiple validation errors returned by
// Chart.ValidateAll() if the designated constraints aren't met.
type ChartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartMultiError) AllErrors() []error { return m }

// ChartValidationError is the validation error returned by Chart.Validate if
// the designated constraints aren't met.
type ChartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartValidationError) ErrorName() string { return "ChartValidationError" }

// Error satisfies the builtin error interface
func (e ChartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartValidationError{}

// Validate checks the field values on ChartVersionListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChartVersionListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartVersionListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChartVersionListDataMultiError, or nil if none found.
func (m *ChartVersionListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartVersionListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChartVersionListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChartVersionListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChartVersionListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChartVersionListDataMultiError(errors)
	}

	return nil
}

// ChartVersionListDataMultiError is an error wrapping multiple validation
// errors returned by ChartVersionListData.ValidateAll() if the designated
// constraints aren't met.
type ChartVersionListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartVersionListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartVersionListDataMultiError) AllErrors() []error { return m }

// ChartVersionListDataValidationError is the validation error returned by
// ChartVersionListData.Validate if the designated constraints aren't met.
type ChartVersionListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartVersionListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartVersionListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartVersionListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartVersionListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartVersionListDataValidationError) ErrorName() string {
	return "ChartVersionListDataValidationError"
}

// Error satisfies the builtin error interface
func (e ChartVersionListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartVersionListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartVersionListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartVersionListDataValidationError{}

// Validate checks the field values on ChartVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartVersion with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartVersionMultiError, or
// nil if none found.
func (m *ChartVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for AppVersion

	// no validation rules for Description

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for Url

	if len(errors) > 0 {
		return ChartVersionMultiError(errors)
	}

	return nil
}

// ChartVersionMultiError is an error wrapping multiple validation errors
// returned by ChartVersion.ValidateAll() if the designated constraints aren't met.
type ChartVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartVersionMultiError) AllErrors() []error { return m }

// ChartVersionValidationError is the validation error returned by
// ChartVersion.Validate if the designated constraints aren't met.
type ChartVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartVersionValidationError) ErrorName() string { return "ChartVersionValidationError" }

// Error satisfies the builtin error interface
func (e ChartVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartVersionValidationError{}

// Validate checks the field values on ChartDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChartDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChartDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChartDetailMultiError, or
// nil if none found.
func (m *ChartDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ChartDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Readme

	{
		sorted_keys := make([]string, len(m.GetContents()))
		i := 0
		for key := range m.GetContents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetContents()[key]
			_ = val

			// no validation rules for Contents[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ChartDetailValidationError{
							field:  fmt.Sprintf("Contents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ChartDetailValidationError{
							field:  fmt.Sprintf("Contents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ChartDetailValidationError{
						field:  fmt.Sprintf("Contents[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Url

	if len(errors) > 0 {
		return ChartDetailMultiError(errors)
	}

	return nil
}

// ChartDetailMultiError is an error wrapping multiple validation errors
// returned by ChartDetail.ValidateAll() if the designated constraints aren't met.
type ChartDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChartDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChartDetailMultiError) AllErrors() []error { return m }

// ChartDetailValidationError is the validation error returned by
// ChartDetail.Validate if the designated constraints aren't met.
type ChartDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChartDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChartDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChartDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChartDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChartDetailValidationError) ErrorName() string { return "ChartDetailValidationError" }

// Error satisfies the builtin error interface
func (e ChartDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChartDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChartDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChartDetailValidationError{}

// Validate checks the field values on FileContent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileContent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileContent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileContentMultiError, or
// nil if none found.
func (m *FileContent) ValidateAll() error {
	return m.validate(true)
}

func (m *FileContent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Content

	if len(errors) > 0 {
		return FileContentMultiError(errors)
	}

	return nil
}

// FileContentMultiError is an error wrapping multiple validation errors
// returned by FileContent.ValidateAll() if the designated constraints aren't met.
type FileContentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileContentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileContentMultiError) AllErrors() []error { return m }

// FileContentValidationError is the validation error returned by
// FileContent.Validate if the designated constraints aren't met.
type FileContentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileContentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileContentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileContentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileContentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileContentValidationError) ErrorName() string { return "FileContentValidationError" }

// Error satisfies the builtin error interface
func (e FileContentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileContent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileContentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileContentValidationError{}

// Validate checks the field values on ListChartV1Req with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListChartV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartV1Req with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListChartV1ReqMultiError,
// or nil if none found.
func (m *ListChartV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListChartV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := ListChartV1ReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return ListChartV1ReqMultiError(errors)
	}

	return nil
}

// ListChartV1ReqMultiError is an error wrapping multiple validation errors
// returned by ListChartV1Req.ValidateAll() if the designated constraints
// aren't met.
type ListChartV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartV1ReqMultiError) AllErrors() []error { return m }

// ListChartV1ReqValidationError is the validation error returned by
// ListChartV1Req.Validate if the designated constraints aren't met.
type ListChartV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartV1ReqValidationError) ErrorName() string { return "ListChartV1ReqValidationError" }

// Error satisfies the builtin error interface
func (e ListChartV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartV1ReqValidationError{}

// Validate checks the field values on ListChartV1Resp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListChartV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartV1RespMultiError, or nil if none found.
func (m *ListChartV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListChartV1RespMultiError(errors)
	}

	return nil
}

// ListChartV1RespMultiError is an error wrapping multiple validation errors
// returned by ListChartV1Resp.ValidateAll() if the designated constraints
// aren't met.
type ListChartV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartV1RespMultiError) AllErrors() []error { return m }

// ListChartV1RespValidationError is the validation error returned by
// ListChartV1Resp.Validate if the designated constraints aren't met.
type ListChartV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartV1RespValidationError) ErrorName() string { return "ListChartV1RespValidationError" }

// Error satisfies the builtin error interface
func (e ListChartV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartV1RespValidationError{}

// Validate checks the field values on GetChartDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartDetailV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartDetailV1ReqMultiError, or nil if none found.
func (m *GetChartDetailV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartDetailV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetChartDetailV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := GetChartDetailV1ReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetChartDetailV1ReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetChartDetailV1ReqMultiError(errors)
	}

	return nil
}

// GetChartDetailV1ReqMultiError is an error wrapping multiple validation
// errors returned by GetChartDetailV1Req.ValidateAll() if the designated
// constraints aren't met.
type GetChartDetailV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartDetailV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartDetailV1ReqMultiError) AllErrors() []error { return m }

// GetChartDetailV1ReqValidationError is the validation error returned by
// GetChartDetailV1Req.Validate if the designated constraints aren't met.
type GetChartDetailV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartDetailV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartDetailV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartDetailV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartDetailV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartDetailV1ReqValidationError) ErrorName() string {
	return "GetChartDetailV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartDetailV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartDetailV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartDetailV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartDetailV1ReqValidationError{}

// Validate checks the field values on GetChartDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartDetailV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartDetailV1RespMultiError, or nil if none found.
func (m *GetChartDetailV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartDetailV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetChartDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetChartDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetChartDetailV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetChartDetailV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetChartDetailV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetChartDetailV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetChartDetailV1RespMultiError(errors)
	}

	return nil
}

// GetChartDetailV1RespMultiError is an error wrapping multiple validation
// errors returned by GetChartDetailV1Resp.ValidateAll() if the designated
// constraints aren't met.
type GetChartDetailV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartDetailV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartDetailV1RespMultiError) AllErrors() []error { return m }

// GetChartDetailV1RespValidationError is the validation error returned by
// GetChartDetailV1Resp.Validate if the designated constraints aren't met.
type GetChartDetailV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartDetailV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartDetailV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartDetailV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartDetailV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartDetailV1RespValidationError) ErrorName() string {
	return "GetChartDetailV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartDetailV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartDetailV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartDetailV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartDetailV1RespValidationError{}

// Validate checks the field values on ListChartVersionV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChartVersionV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartVersionV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartVersionV1ReqMultiError, or nil if none found.
func (m *ListChartVersionV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartVersionV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListChartVersionV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := ListChartVersionV1ReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ListChartVersionV1ReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListChartVersionV1ReqMultiError(errors)
	}

	return nil
}

// ListChartVersionV1ReqMultiError is an error wrapping multiple validation
// errors returned by ListChartVersionV1Req.ValidateAll() if the designated
// constraints aren't met.
type ListChartVersionV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartVersionV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartVersionV1ReqMultiError) AllErrors() []error { return m }

// ListChartVersionV1ReqValidationError is the validation error returned by
// ListChartVersionV1Req.Validate if the designated constraints aren't met.
type ListChartVersionV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartVersionV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartVersionV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartVersionV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartVersionV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartVersionV1ReqValidationError) ErrorName() string {
	return "ListChartVersionV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListChartVersionV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartVersionV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartVersionV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartVersionV1ReqValidationError{}

// Validate checks the field values on ListChartVersionV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChartVersionV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChartVersionV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChartVersionV1RespMultiError, or nil if none found.
func (m *ListChartVersionV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChartVersionV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartVersionV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartVersionV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartVersionV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChartVersionV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChartVersionV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChartVersionV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListChartVersionV1RespMultiError(errors)
	}

	return nil
}

// ListChartVersionV1RespMultiError is an error wrapping multiple validation
// errors returned by ListChartVersionV1Resp.ValidateAll() if the designated
// constraints aren't met.
type ListChartVersionV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChartVersionV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChartVersionV1RespMultiError) AllErrors() []error { return m }

// ListChartVersionV1RespValidationError is the validation error returned by
// ListChartVersionV1Resp.Validate if the designated constraints aren't met.
type ListChartVersionV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChartVersionV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChartVersionV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChartVersionV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChartVersionV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChartVersionV1RespValidationError) ErrorName() string {
	return "ListChartVersionV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e ListChartVersionV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChartVersionV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChartVersionV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChartVersionV1RespValidationError{}

// Validate checks the field values on GetVersionDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVersionDetailV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVersionDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVersionDetailV1ReqMultiError, or nil if none found.
func (m *GetVersionDetailV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVersionDetailV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetVersionDetailV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := GetVersionDetailV1ReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetVersionDetailV1ReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVersion()) < 1 {
		err := GetVersionDetailV1ReqValidationError{
			field:  "Version",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetVersionDetailV1ReqMultiError(errors)
	}

	return nil
}

// GetVersionDetailV1ReqMultiError is an error wrapping multiple validation
// errors returned by GetVersionDetailV1Req.ValidateAll() if the designated
// constraints aren't met.
type GetVersionDetailV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVersionDetailV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVersionDetailV1ReqMultiError) AllErrors() []error { return m }

// GetVersionDetailV1ReqValidationError is the validation error returned by
// GetVersionDetailV1Req.Validate if the designated constraints aren't met.
type GetVersionDetailV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVersionDetailV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVersionDetailV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVersionDetailV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVersionDetailV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVersionDetailV1ReqValidationError) ErrorName() string {
	return "GetVersionDetailV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetVersionDetailV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVersionDetailV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVersionDetailV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVersionDetailV1ReqValidationError{}

// Validate checks the field values on GetVersionDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVersionDetailV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVersionDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVersionDetailV1RespMultiError, or nil if none found.
func (m *GetVersionDetailV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVersionDetailV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetVersionDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetVersionDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetVersionDetailV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetVersionDetailV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetVersionDetailV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetVersionDetailV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetVersionDetailV1RespMultiError(errors)
	}

	return nil
}

// GetVersionDetailV1RespMultiError is an error wrapping multiple validation
// errors returned by GetVersionDetailV1Resp.ValidateAll() if the designated
// constraints aren't met.
type GetVersionDetailV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVersionDetailV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVersionDetailV1RespMultiError) AllErrors() []error { return m }

// GetVersionDetailV1RespValidationError is the validation error returned by
// GetVersionDetailV1Resp.Validate if the designated constraints aren't met.
type GetVersionDetailV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVersionDetailV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVersionDetailV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVersionDetailV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVersionDetailV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVersionDetailV1RespValidationError) ErrorName() string {
	return "GetVersionDetailV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e GetVersionDetailV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVersionDetailV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVersionDetailV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVersionDetailV1RespValidationError{}

// Validate checks the field values on DeleteChartReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteChartReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteChartReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteChartReqMultiError,
// or nil if none found.
func (m *DeleteChartReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteChartReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DeleteChartReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := DeleteChartReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DeleteChartReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteChartReqMultiError(errors)
	}

	return nil
}

// DeleteChartReqMultiError is an error wrapping multiple validation errors
// returned by DeleteChartReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteChartReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteChartReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteChartReqMultiError) AllErrors() []error { return m }

// DeleteChartReqValidationError is the validation error returned by
// DeleteChartReq.Validate if the designated constraints aren't met.
type DeleteChartReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteChartReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteChartReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteChartReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteChartReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteChartReqValidationError) ErrorName() string { return "DeleteChartReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteChartReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteChartReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteChartReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteChartReqValidationError{}

// Validate checks the field values on DeleteChartResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteChartResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteChartResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteChartRespMultiError, or nil if none found.
func (m *DeleteChartResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteChartResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteChartRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteChartRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteChartRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteChartRespMultiError(errors)
	}

	return nil
}

// DeleteChartRespMultiError is an error wrapping multiple validation errors
// returned by DeleteChartResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteChartRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteChartRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteChartRespMultiError) AllErrors() []error { return m }

// DeleteChartRespValidationError is the validation error returned by
// DeleteChartResp.Validate if the designated constraints aren't met.
type DeleteChartRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteChartRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteChartRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteChartRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteChartRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteChartRespValidationError) ErrorName() string { return "DeleteChartRespValidationError" }

// Error satisfies the builtin error interface
func (e DeleteChartRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteChartResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteChartRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteChartRespValidationError{}

// Validate checks the field values on DeleteChartVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteChartVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteChartVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteChartVersionReqMultiError, or nil if none found.
func (m *DeleteChartVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteChartVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DeleteChartVersionReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := DeleteChartVersionReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DeleteChartVersionReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVersion()) < 1 {
		err := DeleteChartVersionReqValidationError{
			field:  "Version",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteChartVersionReqMultiError(errors)
	}

	return nil
}

// DeleteChartVersionReqMultiError is an error wrapping multiple validation
// errors returned by DeleteChartVersionReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteChartVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteChartVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteChartVersionReqMultiError) AllErrors() []error { return m }

// DeleteChartVersionReqValidationError is the validation error returned by
// DeleteChartVersionReq.Validate if the designated constraints aren't met.
type DeleteChartVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteChartVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteChartVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteChartVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteChartVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteChartVersionReqValidationError) ErrorName() string {
	return "DeleteChartVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteChartVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteChartVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteChartVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteChartVersionReqValidationError{}

// Validate checks the field values on DeleteChartVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteChartVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteChartVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteChartVersionRespMultiError, or nil if none found.
func (m *DeleteChartVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteChartVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteChartVersionRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteChartVersionRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteChartVersionRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteChartVersionRespMultiError(errors)
	}

	return nil
}

// DeleteChartVersionRespMultiError is an error wrapping multiple validation
// errors returned by DeleteChartVersionResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteChartVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteChartVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteChartVersionRespMultiError) AllErrors() []error { return m }

// DeleteChartVersionRespValidationError is the validation error returned by
// DeleteChartVersionResp.Validate if the designated constraints aren't met.
type DeleteChartVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteChartVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteChartVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteChartVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteChartVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteChartVersionRespValidationError) ErrorName() string {
	return "DeleteChartVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteChartVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteChartVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteChartVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteChartVersionRespValidationError{}

// Validate checks the field values on DownloadChartReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DownloadChartReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadChartReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadChartReqMultiError, or nil if none found.
func (m *DownloadChartReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadChartReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := DownloadChartReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := DownloadChartReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DownloadChartReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVersion()) < 1 {
		err := DownloadChartReqValidationError{
			field:  "Version",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DownloadChartReqMultiError(errors)
	}

	return nil
}

// DownloadChartReqMultiError is an error wrapping multiple validation errors
// returned by DownloadChartReq.ValidateAll() if the designated constraints
// aren't met.
type DownloadChartReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadChartReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadChartReqMultiError) AllErrors() []error { return m }

// DownloadChartReqValidationError is the validation error returned by
// DownloadChartReq.Validate if the designated constraints aren't met.
type DownloadChartReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadChartReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadChartReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadChartReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadChartReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadChartReqValidationError) ErrorName() string { return "DownloadChartReqValidationError" }

// Error satisfies the builtin error interface
func (e DownloadChartReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadChartReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadChartReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadChartReqValidationError{}

// Validate checks the field values on GetChartReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartReleaseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartReleaseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartReleaseReqMultiError, or nil if none found.
func (m *GetChartReleaseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartReleaseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetChartReleaseReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepoName()); l < 1 || l > 64 {
		err := GetChartReleaseReqValidationError{
			field:  "RepoName",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetChartReleaseReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetChartReleaseReqMultiError(errors)
	}

	return nil
}

// GetChartReleaseReqMultiError is an error wrapping multiple validation errors
// returned by GetChartReleaseReq.ValidateAll() if the designated constraints
// aren't met.
type GetChartReleaseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartReleaseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartReleaseReqMultiError) AllErrors() []error { return m }

// GetChartReleaseReqValidationError is the validation error returned by
// GetChartReleaseReq.Validate if the designated constraints aren't met.
type GetChartReleaseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartReleaseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartReleaseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartReleaseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartReleaseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartReleaseReqValidationError) ErrorName() string {
	return "GetChartReleaseReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartReleaseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartReleaseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartReleaseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartReleaseReqValidationError{}

// Validate checks the field values on GetChartReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetChartReleaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetChartReleaseResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetChartReleaseRespMultiError, or nil if none found.
func (m *GetChartReleaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetChartReleaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetChartReleaseRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetChartReleaseRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetChartReleaseRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetChartReleaseRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetChartReleaseRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetChartReleaseRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetChartReleaseRespMultiError(errors)
	}

	return nil
}

// GetChartReleaseRespMultiError is an error wrapping multiple validation
// errors returned by GetChartReleaseResp.ValidateAll() if the designated
// constraints aren't met.
type GetChartReleaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetChartReleaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetChartReleaseRespMultiError) AllErrors() []error { return m }

// GetChartReleaseRespValidationError is the validation error returned by
// GetChartReleaseResp.Validate if the designated constraints aren't met.
type GetChartReleaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetChartReleaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetChartReleaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetChartReleaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetChartReleaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetChartReleaseRespValidationError) ErrorName() string {
	return "GetChartReleaseRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetChartReleaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetChartReleaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetChartReleaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetChartReleaseRespValidationError{}

// Validate checks the field values on ReleaseListData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReleaseListData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseListData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleaseListDataMultiError, or nil if none found.
func (m *ReleaseListData) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseListData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReleaseListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReleaseListDataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReleaseListDataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReleaseListDataMultiError(errors)
	}

	return nil
}

// ReleaseListDataMultiError is an error wrapping multiple validation errors
// returned by ReleaseListData.ValidateAll() if the designated constraints
// aren't met.
type ReleaseListDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseListDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseListDataMultiError) AllErrors() []error { return m }

// ReleaseListDataValidationError is the validation error returned by
// ReleaseListData.Validate if the designated constraints aren't met.
type ReleaseListDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseListDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseListDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseListDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseListDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseListDataValidationError) ErrorName() string { return "ReleaseListDataValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseListDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseListData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseListDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseListDataValidationError{}

// Validate checks the field values on Release with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Release) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Release with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReleaseMultiError, or nil if none found.
func (m *Release) ValidateAll() error {
	return m.validate(true)
}

func (m *Release) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Revision

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for AppVersion

	// no validation rules for UpdateTime

	// no validation rules for ChartVersion

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for Message

	// no validation rules for Repo

	// no validation rules for IamNamespaceID

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ReleaseMultiError(errors)
	}

	return nil
}

// ReleaseMultiError is an error wrapping multiple validation errors returned
// by Release.ValidateAll() if the designated constraints aren't met.
type ReleaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseMultiError) AllErrors() []error { return m }

// ReleaseValidationError is the validation error returned by Release.Validate
// if the designated constraints aren't met.
type ReleaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseValidationError) ErrorName() string { return "ReleaseValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelease.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseValidationError{}

// Validate checks the field values on ReleaseDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseDetailMultiError, or
// nil if none found.
func (m *ReleaseDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Revision

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for AppVersion

	// no validation rules for UpdateTime

	// no validation rules for ChartVersion

	// no validation rules for Description

	// no validation rules for Notes

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for Message

	// no validation rules for Repo

	// no validation rules for ValueFile

	if len(errors) > 0 {
		return ReleaseDetailMultiError(errors)
	}

	return nil
}

// ReleaseDetailMultiError is an error wrapping multiple validation errors
// returned by ReleaseDetail.ValidateAll() if the designated constraints
// aren't met.
type ReleaseDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseDetailMultiError) AllErrors() []error { return m }

// ReleaseDetailValidationError is the validation error returned by
// ReleaseDetail.Validate if the designated constraints aren't met.
type ReleaseDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseDetailValidationError) ErrorName() string { return "ReleaseDetailValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseDetailValidationError{}

// Validate checks the field values on ListReleaseV1Req with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReleaseV1ReqMultiError, or nil if none found.
func (m *ListReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := ListReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Page

	// no validation rules for Size

	if len(errors) > 0 {
		return ListReleaseV1ReqMultiError(errors)
	}

	return nil
}

// ListReleaseV1ReqMultiError is an error wrapping multiple validation errors
// returned by ListReleaseV1Req.ValidateAll() if the designated constraints
// aren't met.
type ListReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReleaseV1ReqMultiError) AllErrors() []error { return m }

// ListReleaseV1ReqValidationError is the validation error returned by
// ListReleaseV1Req.Validate if the designated constraints aren't met.
type ListReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReleaseV1ReqValidationError) ErrorName() string { return "ListReleaseV1ReqValidationError" }

// Error satisfies the builtin error interface
func (e ListReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReleaseV1ReqValidationError{}

// Validate checks the field values on ListReleaseV1Resp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReleaseV1RespMultiError, or nil if none found.
func (m *ListReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReleaseV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReleaseV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReleaseV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReleaseV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListReleaseV1RespMultiError(errors)
	}

	return nil
}

// ListReleaseV1RespMultiError is an error wrapping multiple validation errors
// returned by ListReleaseV1Resp.ValidateAll() if the designated constraints
// aren't met.
type ListReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReleaseV1RespMultiError) AllErrors() []error { return m }

// ListReleaseV1RespValidationError is the validation error returned by
// ListReleaseV1Resp.Validate if the designated constraints aren't met.
type ListReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReleaseV1RespValidationError) ErrorName() string {
	return "ListReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e ListReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReleaseV1RespValidationError{}

// Validate checks the field values on GetReleaseDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseDetailV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseDetailV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseDetailV1ReqMultiError, or nil if none found.
func (m *GetReleaseDetailV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseDetailV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetReleaseDetailV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseDetailV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseDetailV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetReleaseDetailV1ReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetReleaseDetailV1ReqMultiError(errors)
	}

	return nil
}

// GetReleaseDetailV1ReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseDetailV1Req.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseDetailV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseDetailV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseDetailV1ReqMultiError) AllErrors() []error { return m }

// GetReleaseDetailV1ReqValidationError is the validation error returned by
// GetReleaseDetailV1Req.Validate if the designated constraints aren't met.
type GetReleaseDetailV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseDetailV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseDetailV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseDetailV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseDetailV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseDetailV1ReqValidationError) ErrorName() string {
	return "GetReleaseDetailV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseDetailV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseDetailV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseDetailV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseDetailV1ReqValidationError{}

// Validate checks the field values on GetReleaseDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseDetailV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseDetailV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseDetailV1RespMultiError, or nil if none found.
func (m *GetReleaseDetailV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseDetailV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReleaseDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReleaseDetailV1RespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReleaseDetailV1RespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReleaseDetailV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReleaseDetailV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReleaseDetailV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReleaseDetailV1RespMultiError(errors)
	}

	return nil
}

// GetReleaseDetailV1RespMultiError is an error wrapping multiple validation
// errors returned by GetReleaseDetailV1Resp.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseDetailV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseDetailV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseDetailV1RespMultiError) AllErrors() []error { return m }

// GetReleaseDetailV1RespValidationError is the validation error returned by
// GetReleaseDetailV1Resp.Validate if the designated constraints aren't met.
type GetReleaseDetailV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseDetailV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseDetailV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseDetailV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseDetailV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseDetailV1RespValidationError) ErrorName() string {
	return "GetReleaseDetailV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseDetailV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseDetailV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseDetailV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseDetailV1RespValidationError{}

// Validate checks the field values on InstallReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallReleaseV1ReqMultiError, or nil if none found.
func (m *InstallReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := InstallReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRepository()); l < 1 || l > 64 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Repository",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetChart()) < 1 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Chart",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVersion()) < 1 {
		err := InstallReleaseV1ReqValidationError{
			field:  "Version",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ValueFile

	// no validation rules for Operator

	if len(errors) > 0 {
		return InstallReleaseV1ReqMultiError(errors)
	}

	return nil
}

// InstallReleaseV1ReqMultiError is an error wrapping multiple validation
// errors returned by InstallReleaseV1Req.ValidateAll() if the designated
// constraints aren't met.
type InstallReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallReleaseV1ReqMultiError) AllErrors() []error { return m }

// InstallReleaseV1ReqValidationError is the validation error returned by
// InstallReleaseV1Req.Validate if the designated constraints aren't met.
type InstallReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallReleaseV1ReqValidationError) ErrorName() string {
	return "InstallReleaseV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e InstallReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallReleaseV1ReqValidationError{}

// Validate checks the field values on InstallReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallReleaseV1RespMultiError, or nil if none found.
func (m *InstallReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstallReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstallReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstallReleaseV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstallReleaseV1RespMultiError(errors)
	}

	return nil
}

// InstallReleaseV1RespMultiError is an error wrapping multiple validation
// errors returned by InstallReleaseV1Resp.ValidateAll() if the designated
// constraints aren't met.
type InstallReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallReleaseV1RespMultiError) AllErrors() []error { return m }

// InstallReleaseV1RespValidationError is the validation error returned by
// InstallReleaseV1Resp.Validate if the designated constraints aren't met.
type InstallReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallReleaseV1RespValidationError) ErrorName() string {
	return "InstallReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e InstallReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallReleaseV1RespValidationError{}

// Validate checks the field values on UninstallReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallReleaseV1ReqMultiError, or nil if none found.
func (m *UninstallReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UninstallReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UninstallReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := UninstallReleaseV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := UninstallReleaseV1ReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UninstallReleaseV1ReqMultiError(errors)
	}

	return nil
}

// UninstallReleaseV1ReqMultiError is an error wrapping multiple validation
// errors returned by UninstallReleaseV1Req.ValidateAll() if the designated
// constraints aren't met.
type UninstallReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallReleaseV1ReqMultiError) AllErrors() []error { return m }

// UninstallReleaseV1ReqValidationError is the validation error returned by
// UninstallReleaseV1Req.Validate if the designated constraints aren't met.
type UninstallReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallReleaseV1ReqValidationError) ErrorName() string {
	return "UninstallReleaseV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallReleaseV1ReqValidationError{}

// Validate checks the field values on UninstallReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallReleaseV1RespMultiError, or nil if none found.
func (m *UninstallReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UninstallReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UninstallReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UninstallReleaseV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UninstallReleaseV1RespMultiError(errors)
	}

	return nil
}

// UninstallReleaseV1RespMultiError is an error wrapping multiple validation
// errors returned by UninstallReleaseV1Resp.ValidateAll() if the designated
// constraints aren't met.
type UninstallReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallReleaseV1RespMultiError) AllErrors() []error { return m }

// UninstallReleaseV1RespValidationError is the validation error returned by
// UninstallReleaseV1Resp.Validate if the designated constraints aren't met.
type UninstallReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallReleaseV1RespValidationError) ErrorName() string {
	return "UninstallReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallReleaseV1RespValidationError{}

// Validate checks the field values on UpgradeReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradeReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeReleaseV1ReqMultiError, or nil if none found.
func (m *UpgradeReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := UpgradeReleaseV1ReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Repository

	// no validation rules for Chart

	// no validation rules for Version

	// no validation rules for ValueFile

	// no validation rules for Operator

	if len(errors) > 0 {
		return UpgradeReleaseV1ReqMultiError(errors)
	}

	return nil
}

// UpgradeReleaseV1ReqMultiError is an error wrapping multiple validation
// errors returned by UpgradeReleaseV1Req.ValidateAll() if the designated
// constraints aren't met.
type UpgradeReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeReleaseV1ReqMultiError) AllErrors() []error { return m }

// UpgradeReleaseV1ReqValidationError is the validation error returned by
// UpgradeReleaseV1Req.Validate if the designated constraints aren't met.
type UpgradeReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeReleaseV1ReqValidationError) ErrorName() string {
	return "UpgradeReleaseV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeReleaseV1ReqValidationError{}

// Validate checks the field values on UpgradeReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradeReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeReleaseV1RespMultiError, or nil if none found.
func (m *UpgradeReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeReleaseV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpgradeReleaseV1RespMultiError(errors)
	}

	return nil
}

// UpgradeReleaseV1RespMultiError is an error wrapping multiple validation
// errors returned by UpgradeReleaseV1Resp.ValidateAll() if the designated
// constraints aren't met.
type UpgradeReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeReleaseV1RespMultiError) AllErrors() []error { return m }

// UpgradeReleaseV1RespValidationError is the validation error returned by
// UpgradeReleaseV1Resp.Validate if the designated constraints aren't met.
type UpgradeReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeReleaseV1RespValidationError) ErrorName() string {
	return "UpgradeReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeReleaseV1RespValidationError{}

// Validate checks the field values on RollbackReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackReleaseV1Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackReleaseV1Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackReleaseV1ReqMultiError, or nil if none found.
func (m *RollbackReleaseV1Req) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackReleaseV1Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := RollbackReleaseV1ReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := RollbackReleaseV1ReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := RollbackReleaseV1ReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := RollbackReleaseV1ReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Revision

	if len(errors) > 0 {
		return RollbackReleaseV1ReqMultiError(errors)
	}

	return nil
}

// RollbackReleaseV1ReqMultiError is an error wrapping multiple validation
// errors returned by RollbackReleaseV1Req.ValidateAll() if the designated
// constraints aren't met.
type RollbackReleaseV1ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackReleaseV1ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackReleaseV1ReqMultiError) AllErrors() []error { return m }

// RollbackReleaseV1ReqValidationError is the validation error returned by
// RollbackReleaseV1Req.Validate if the designated constraints aren't met.
type RollbackReleaseV1ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackReleaseV1ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackReleaseV1ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackReleaseV1ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackReleaseV1ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackReleaseV1ReqValidationError) ErrorName() string {
	return "RollbackReleaseV1ReqValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackReleaseV1ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackReleaseV1Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackReleaseV1ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackReleaseV1ReqValidationError{}

// Validate checks the field values on RollbackReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackReleaseV1Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackReleaseV1Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackReleaseV1RespMultiError, or nil if none found.
func (m *RollbackReleaseV1Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackReleaseV1Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RollbackReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RollbackReleaseV1RespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RollbackReleaseV1RespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RollbackReleaseV1RespMultiError(errors)
	}

	return nil
}

// RollbackReleaseV1RespMultiError is an error wrapping multiple validation
// errors returned by RollbackReleaseV1Resp.ValidateAll() if the designated
// constraints aren't met.
type RollbackReleaseV1RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackReleaseV1RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackReleaseV1RespMultiError) AllErrors() []error { return m }

// RollbackReleaseV1RespValidationError is the validation error returned by
// RollbackReleaseV1Resp.Validate if the designated constraints aren't met.
type RollbackReleaseV1RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackReleaseV1RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackReleaseV1RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackReleaseV1RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackReleaseV1RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackReleaseV1RespValidationError) ErrorName() string {
	return "RollbackReleaseV1RespValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackReleaseV1RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackReleaseV1Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackReleaseV1RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackReleaseV1RespValidationError{}

// Validate checks the field values on ReleasePreviewReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReleasePreviewReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleasePreviewReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleasePreviewReqMultiError, or nil if none found.
func (m *ReleasePreviewReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleasePreviewReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ReleasePreviewReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := ReleasePreviewReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := ReleasePreviewReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ReleasePreviewReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Repository

	// no validation rules for Chart

	// no validation rules for Version

	// no validation rules for Revision

	if len(errors) > 0 {
		return ReleasePreviewReqMultiError(errors)
	}

	return nil
}

// ReleasePreviewReqMultiError is an error wrapping multiple validation errors
// returned by ReleasePreviewReq.ValidateAll() if the designated constraints
// aren't met.
type ReleasePreviewReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleasePreviewReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleasePreviewReqMultiError) AllErrors() []error { return m }

// ReleasePreviewReqValidationError is the validation error returned by
// ReleasePreviewReq.Validate if the designated constraints aren't met.
type ReleasePreviewReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleasePreviewReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleasePreviewReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleasePreviewReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleasePreviewReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleasePreviewReqValidationError) ErrorName() string {
	return "ReleasePreviewReqValidationError"
}

// Error satisfies the builtin error interface
func (e ReleasePreviewReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleasePreviewReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleasePreviewReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleasePreviewReqValidationError{}

// Validate checks the field values on ReleasePreviewResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReleasePreviewResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleasePreviewResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleasePreviewRespMultiError, or nil if none found.
func (m *ReleasePreviewResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleasePreviewResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleasePreviewRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleasePreviewRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleasePreviewRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleasePreviewRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleasePreviewRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleasePreviewRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReleasePreviewRespMultiError(errors)
	}

	return nil
}

// ReleasePreviewRespMultiError is an error wrapping multiple validation errors
// returned by ReleasePreviewResp.ValidateAll() if the designated constraints
// aren't met.
type ReleasePreviewRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleasePreviewRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleasePreviewRespMultiError) AllErrors() []error { return m }

// ReleasePreviewRespValidationError is the validation error returned by
// ReleasePreviewResp.Validate if the designated constraints aren't met.
type ReleasePreviewRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleasePreviewRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleasePreviewRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleasePreviewRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleasePreviewRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleasePreviewRespValidationError) ErrorName() string {
	return "ReleasePreviewRespValidationError"
}

// Error satisfies the builtin error interface
func (e ReleasePreviewRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleasePreviewResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleasePreviewRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleasePreviewRespValidationError{}

// Validate checks the field values on ReleasePreview with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleasePreview) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleasePreview with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleasePreviewMultiError,
// or nil if none found.
func (m *ReleasePreview) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleasePreview) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetNewContents()))
		i := 0
		for key := range m.GetNewContents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNewContents()[key]
			_ = val

			// no validation rules for NewContents[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ReleasePreviewValidationError{
							field:  fmt.Sprintf("NewContents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ReleasePreviewValidationError{
							field:  fmt.Sprintf("NewContents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ReleasePreviewValidationError{
						field:  fmt.Sprintf("NewContents[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetOldContents()))
		i := 0
		for key := range m.GetOldContents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOldContents()[key]
			_ = val

			// no validation rules for OldContents[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ReleasePreviewValidationError{
							field:  fmt.Sprintf("OldContents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ReleasePreviewValidationError{
							field:  fmt.Sprintf("OldContents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ReleasePreviewValidationError{
						field:  fmt.Sprintf("OldContents[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for NewContent

	// no validation rules for OldContent

	if len(errors) > 0 {
		return ReleasePreviewMultiError(errors)
	}

	return nil
}

// ReleasePreviewMultiError is an error wrapping multiple validation errors
// returned by ReleasePreview.ValidateAll() if the designated constraints
// aren't met.
type ReleasePreviewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleasePreviewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleasePreviewMultiError) AllErrors() []error { return m }

// ReleasePreviewValidationError is the validation error returned by
// ReleasePreview.Validate if the designated constraints aren't met.
type ReleasePreviewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleasePreviewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleasePreviewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleasePreviewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleasePreviewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleasePreviewValidationError) ErrorName() string { return "ReleasePreviewValidationError" }

// Error satisfies the builtin error interface
func (e ReleasePreviewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleasePreview.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleasePreviewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleasePreviewValidationError{}

// Validate checks the field values on GetReleaseHistoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseHistoryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseHistoryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseHistoryReqMultiError, or nil if none found.
func (m *GetReleaseHistoryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseHistoryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetReleaseHistoryReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseHistoryReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseHistoryReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetReleaseHistoryReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Filter

	if len(errors) > 0 {
		return GetReleaseHistoryReqMultiError(errors)
	}

	return nil
}

// GetReleaseHistoryReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseHistoryReq.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseHistoryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseHistoryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseHistoryReqMultiError) AllErrors() []error { return m }

// GetReleaseHistoryReqValidationError is the validation error returned by
// GetReleaseHistoryReq.Validate if the designated constraints aren't met.
type GetReleaseHistoryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseHistoryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseHistoryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseHistoryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseHistoryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseHistoryReqValidationError) ErrorName() string {
	return "GetReleaseHistoryReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseHistoryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseHistoryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseHistoryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseHistoryReqValidationError{}

// Validate checks the field values on GetReleaseHistoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseHistoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseHistoryResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseHistoryRespMultiError, or nil if none found.
func (m *GetReleaseHistoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseHistoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReleaseHistoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReleaseHistoryRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReleaseHistoryRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReleaseHistoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReleaseHistoryRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReleaseHistoryRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReleaseHistoryRespMultiError(errors)
	}

	return nil
}

// GetReleaseHistoryRespMultiError is an error wrapping multiple validation
// errors returned by GetReleaseHistoryResp.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseHistoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseHistoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseHistoryRespMultiError) AllErrors() []error { return m }

// GetReleaseHistoryRespValidationError is the validation error returned by
// GetReleaseHistoryResp.Validate if the designated constraints aren't met.
type GetReleaseHistoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseHistoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseHistoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseHistoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseHistoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseHistoryRespValidationError) ErrorName() string {
	return "GetReleaseHistoryRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseHistoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseHistoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseHistoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseHistoryRespValidationError{}

// Validate checks the field values on ReleaseHistory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseHistoryMultiError,
// or nil if none found.
func (m *ReleaseHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Revision

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for UpdateTime

	// no validation rules for Description

	// no validation rules for Status

	// no validation rules for Chart

	// no validation rules for ChartVersion

	// no validation rules for AppVersion

	// no validation rules for Values

	if len(errors) > 0 {
		return ReleaseHistoryMultiError(errors)
	}

	return nil
}

// ReleaseHistoryMultiError is an error wrapping multiple validation errors
// returned by ReleaseHistory.ValidateAll() if the designated constraints
// aren't met.
type ReleaseHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseHistoryMultiError) AllErrors() []error { return m }

// ReleaseHistoryValidationError is the validation error returned by
// ReleaseHistory.Validate if the designated constraints aren't met.
type ReleaseHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseHistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseHistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseHistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseHistoryValidationError) ErrorName() string { return "ReleaseHistoryValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseHistoryValidationError{}

// Validate checks the field values on GetReleaseStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseStatusReqMultiError, or nil if none found.
func (m *GetReleaseStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetReleaseStatusReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleaseStatusReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleaseStatusReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetReleaseStatusReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetReleaseStatusReqMultiError(errors)
	}

	return nil
}

// GetReleaseStatusReqMultiError is an error wrapping multiple validation
// errors returned by GetReleaseStatusReq.ValidateAll() if the designated
// constraints aren't met.
type GetReleaseStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseStatusReqMultiError) AllErrors() []error { return m }

// GetReleaseStatusReqValidationError is the validation error returned by
// GetReleaseStatusReq.Validate if the designated constraints aren't met.
type GetReleaseStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseStatusReqValidationError) ErrorName() string {
	return "GetReleaseStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseStatusReqValidationError{}

// Validate checks the field values on GetReleasePodsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetReleasePodsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleasePodsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleasePodsReqMultiError, or nil if none found.
func (m *GetReleasePodsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleasePodsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GetReleasePodsReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNamespace()); l < 1 || l > 64 {
		err := GetReleasePodsReqValidationError{
			field:  "Namespace",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetReleasePodsReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetReleasePodsReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for After

	if len(errors) > 0 {
		return GetReleasePodsReqMultiError(errors)
	}

	return nil
}

// GetReleasePodsReqMultiError is an error wrapping multiple validation errors
// returned by GetReleasePodsReq.ValidateAll() if the designated constraints
// aren't met.
type GetReleasePodsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleasePodsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleasePodsReqMultiError) AllErrors() []error { return m }

// GetReleasePodsReqValidationError is the validation error returned by
// GetReleasePodsReq.Validate if the designated constraints aren't met.
type GetReleasePodsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleasePodsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleasePodsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleasePodsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleasePodsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleasePodsReqValidationError) ErrorName() string {
	return "GetReleasePodsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleasePodsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleasePodsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleasePodsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleasePodsReqValidationError{}

// Validate checks the field values on ListAddonsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListAddonsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAddonsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListAddonsReqMultiError, or
// nil if none found.
func (m *ListAddonsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAddonsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := ListAddonsReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := ListAddonsReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAddonsReqMultiError(errors)
	}

	return nil
}

// ListAddonsReqMultiError is an error wrapping multiple validation errors
// returned by ListAddonsReq.ValidateAll() if the designated constraints
// aren't met.
type ListAddonsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAddonsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAddonsReqMultiError) AllErrors() []error { return m }

// ListAddonsReqValidationError is the validation error returned by
// ListAddonsReq.Validate if the designated constraints aren't met.
type ListAddonsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAddonsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAddonsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAddonsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAddonsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAddonsReqValidationError) ErrorName() string { return "ListAddonsReqValidationError" }

// Error satisfies the builtin error interface
func (e ListAddonsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAddonsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAddonsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAddonsReqValidationError{}

// Validate checks the field values on ListAddonsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListAddonsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAddonsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListAddonsRespMultiError,
// or nil if none found.
func (m *ListAddonsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAddonsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAddonsRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAddonsRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAddonsRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAddonsRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListAddonsRespMultiError(errors)
	}

	return nil
}

// ListAddonsRespMultiError is an error wrapping multiple validation errors
// returned by ListAddonsResp.ValidateAll() if the designated constraints
// aren't met.
type ListAddonsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAddonsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAddonsRespMultiError) AllErrors() []error { return m }

// ListAddonsRespValidationError is the validation error returned by
// ListAddonsResp.Validate if the designated constraints aren't met.
type ListAddonsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAddonsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAddonsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAddonsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAddonsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAddonsRespValidationError) ErrorName() string { return "ListAddonsRespValidationError" }

// Error satisfies the builtin error interface
func (e ListAddonsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAddonsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAddonsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAddonsRespValidationError{}

// Validate checks the field values on Addons with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Addons) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Addons with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AddonsMultiError, or nil if none found.
func (m *Addons) ValidateAll() error {
	return m.validate(true)
}

func (m *Addons) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ChartName

	// no validation rules for Description

	// no validation rules for Logo

	// no validation rules for DocsLink

	// no validation rules for Version

	// no validation rules for CurrentVersion

	// no validation rules for Namespace

	// no validation rules for DefaultValues

	// no validation rules for CurrentValues

	// no validation rules for Status

	// no validation rules for Message

	if len(errors) > 0 {
		return AddonsMultiError(errors)
	}

	return nil
}

// AddonsMultiError is an error wrapping multiple validation errors returned by
// Addons.ValidateAll() if the designated constraints aren't met.
type AddonsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddonsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddonsMultiError) AllErrors() []error { return m }

// AddonsValidationError is the validation error returned by Addons.Validate if
// the designated constraints aren't met.
type AddonsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddonsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddonsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddonsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddonsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddonsValidationError) ErrorName() string { return "AddonsValidationError" }

// Error satisfies the builtin error interface
func (e AddonsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddons.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddonsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddonsValidationError{}

// Validate checks the field values on GetAddonsDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAddonsDetailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAddonsDetailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAddonsDetailReqMultiError, or nil if none found.
func (m *GetAddonsDetailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAddonsDetailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := GetAddonsDetailReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := GetAddonsDetailReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := GetAddonsDetailReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAddonsDetailReqMultiError(errors)
	}

	return nil
}

// GetAddonsDetailReqMultiError is an error wrapping multiple validation errors
// returned by GetAddonsDetailReq.ValidateAll() if the designated constraints
// aren't met.
type GetAddonsDetailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddonsDetailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddonsDetailReqMultiError) AllErrors() []error { return m }

// GetAddonsDetailReqValidationError is the validation error returned by
// GetAddonsDetailReq.Validate if the designated constraints aren't met.
type GetAddonsDetailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddonsDetailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddonsDetailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddonsDetailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddonsDetailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddonsDetailReqValidationError) ErrorName() string {
	return "GetAddonsDetailReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetAddonsDetailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddonsDetailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddonsDetailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddonsDetailReqValidationError{}

// Validate checks the field values on GetAddonsDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAddonsDetailResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAddonsDetailResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAddonsDetailRespMultiError, or nil if none found.
func (m *GetAddonsDetailResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAddonsDetailResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAddonsDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAddonsDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAddonsDetailRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAddonsDetailRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAddonsDetailRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAddonsDetailRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAddonsDetailRespMultiError(errors)
	}

	return nil
}

// GetAddonsDetailRespMultiError is an error wrapping multiple validation
// errors returned by GetAddonsDetailResp.ValidateAll() if the designated
// constraints aren't met.
type GetAddonsDetailRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddonsDetailRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddonsDetailRespMultiError) AllErrors() []error { return m }

// GetAddonsDetailRespValidationError is the validation error returned by
// GetAddonsDetailResp.Validate if the designated constraints aren't met.
type GetAddonsDetailRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddonsDetailRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddonsDetailRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddonsDetailRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddonsDetailRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddonsDetailRespValidationError) ErrorName() string {
	return "GetAddonsDetailRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetAddonsDetailRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddonsDetailResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddonsDetailRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddonsDetailRespValidationError{}

// Validate checks the field values on InstallAddonsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InstallAddonsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallAddonsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallAddonsReqMultiError, or nil if none found.
func (m *InstallAddonsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallAddonsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := InstallAddonsReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := InstallAddonsReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := InstallAddonsReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVersion()) < 1 {
		err := InstallAddonsReqValidationError{
			field:  "Version",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Values

	if len(errors) > 0 {
		return InstallAddonsReqMultiError(errors)
	}

	return nil
}

// InstallAddonsReqMultiError is an error wrapping multiple validation errors
// returned by InstallAddonsReq.ValidateAll() if the designated constraints
// aren't met.
type InstallAddonsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallAddonsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallAddonsReqMultiError) AllErrors() []error { return m }

// InstallAddonsReqValidationError is the validation error returned by
// InstallAddonsReq.Validate if the designated constraints aren't met.
type InstallAddonsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallAddonsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallAddonsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallAddonsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallAddonsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallAddonsReqValidationError) ErrorName() string { return "InstallAddonsReqValidationError" }

// Error satisfies the builtin error interface
func (e InstallAddonsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallAddonsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallAddonsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallAddonsReqValidationError{}

// Validate checks the field values on InstallAddonsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InstallAddonsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallAddonsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallAddonsRespMultiError, or nil if none found.
func (m *InstallAddonsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallAddonsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstallAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstallAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstallAddonsRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstallAddonsRespMultiError(errors)
	}

	return nil
}

// InstallAddonsRespMultiError is an error wrapping multiple validation errors
// returned by InstallAddonsResp.ValidateAll() if the designated constraints
// aren't met.
type InstallAddonsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallAddonsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallAddonsRespMultiError) AllErrors() []error { return m }

// InstallAddonsRespValidationError is the validation error returned by
// InstallAddonsResp.Validate if the designated constraints aren't met.
type InstallAddonsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallAddonsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallAddonsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallAddonsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallAddonsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallAddonsRespValidationError) ErrorName() string {
	return "InstallAddonsRespValidationError"
}

// Error satisfies the builtin error interface
func (e InstallAddonsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallAddonsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallAddonsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallAddonsRespValidationError{}

// Validate checks the field values on UpgradeAddonsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpgradeAddonsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeAddonsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeAddonsReqMultiError, or nil if none found.
func (m *UpgradeAddonsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeAddonsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UpgradeAddonsReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UpgradeAddonsReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := UpgradeAddonsReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Version

	// no validation rules for Values

	if len(errors) > 0 {
		return UpgradeAddonsReqMultiError(errors)
	}

	return nil
}

// UpgradeAddonsReqMultiError is an error wrapping multiple validation errors
// returned by UpgradeAddonsReq.ValidateAll() if the designated constraints
// aren't met.
type UpgradeAddonsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeAddonsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeAddonsReqMultiError) AllErrors() []error { return m }

// UpgradeAddonsReqValidationError is the validation error returned by
// UpgradeAddonsReq.Validate if the designated constraints aren't met.
type UpgradeAddonsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeAddonsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeAddonsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeAddonsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeAddonsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeAddonsReqValidationError) ErrorName() string { return "UpgradeAddonsReqValidationError" }

// Error satisfies the builtin error interface
func (e UpgradeAddonsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeAddonsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeAddonsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeAddonsReqValidationError{}

// Validate checks the field values on UpgradeAddonsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpgradeAddonsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeAddonsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeAddonsRespMultiError, or nil if none found.
func (m *UpgradeAddonsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeAddonsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeAddonsRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpgradeAddonsRespMultiError(errors)
	}

	return nil
}

// UpgradeAddonsRespMultiError is an error wrapping multiple validation errors
// returned by UpgradeAddonsResp.ValidateAll() if the designated constraints
// aren't met.
type UpgradeAddonsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeAddonsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeAddonsRespMultiError) AllErrors() []error { return m }

// UpgradeAddonsRespValidationError is the validation error returned by
// UpgradeAddonsResp.Validate if the designated constraints aren't met.
type UpgradeAddonsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeAddonsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeAddonsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeAddonsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeAddonsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeAddonsRespValidationError) ErrorName() string {
	return "UpgradeAddonsRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeAddonsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeAddonsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeAddonsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeAddonsRespValidationError{}

// Validate checks the field values on StopAddonsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StopAddonsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopAddonsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StopAddonsReqMultiError, or
// nil if none found.
func (m *StopAddonsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *StopAddonsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := StopAddonsReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := StopAddonsReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := StopAddonsReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StopAddonsReqMultiError(errors)
	}

	return nil
}

// StopAddonsReqMultiError is an error wrapping multiple validation errors
// returned by StopAddonsReq.ValidateAll() if the designated constraints
// aren't met.
type StopAddonsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopAddonsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopAddonsReqMultiError) AllErrors() []error { return m }

// StopAddonsReqValidationError is the validation error returned by
// StopAddonsReq.Validate if the designated constraints aren't met.
type StopAddonsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopAddonsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopAddonsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopAddonsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopAddonsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopAddonsReqValidationError) ErrorName() string { return "StopAddonsReqValidationError" }

// Error satisfies the builtin error interface
func (e StopAddonsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopAddonsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopAddonsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopAddonsReqValidationError{}

// Validate checks the field values on StopAddonsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StopAddonsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopAddonsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StopAddonsRespMultiError,
// or nil if none found.
func (m *StopAddonsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *StopAddonsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StopAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StopAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StopAddonsRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StopAddonsRespMultiError(errors)
	}

	return nil
}

// StopAddonsRespMultiError is an error wrapping multiple validation errors
// returned by StopAddonsResp.ValidateAll() if the designated constraints
// aren't met.
type StopAddonsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopAddonsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopAddonsRespMultiError) AllErrors() []error { return m }

// StopAddonsRespValidationError is the validation error returned by
// StopAddonsResp.Validate if the designated constraints aren't met.
type StopAddonsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopAddonsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopAddonsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopAddonsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopAddonsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopAddonsRespValidationError) ErrorName() string { return "StopAddonsRespValidationError" }

// Error satisfies the builtin error interface
func (e StopAddonsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopAddonsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopAddonsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopAddonsRespValidationError{}

// Validate checks the field values on UninstallAddonsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallAddonsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallAddonsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallAddonsReqMultiError, or nil if none found.
func (m *UninstallAddonsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallAddonsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 1 || l > 32 {
		err := UninstallAddonsReqValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClusterID()); l < 1 || l > 64 {
		err := UninstallAddonsReqValidationError{
			field:  "ClusterID",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := UninstallAddonsReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UninstallAddonsReqMultiError(errors)
	}

	return nil
}

// UninstallAddonsReqMultiError is an error wrapping multiple validation errors
// returned by UninstallAddonsReq.ValidateAll() if the designated constraints
// aren't met.
type UninstallAddonsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallAddonsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallAddonsReqMultiError) AllErrors() []error { return m }

// UninstallAddonsReqValidationError is the validation error returned by
// UninstallAddonsReq.Validate if the designated constraints aren't met.
type UninstallAddonsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallAddonsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallAddonsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallAddonsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallAddonsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallAddonsReqValidationError) ErrorName() string {
	return "UninstallAddonsReqValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallAddonsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallAddonsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallAddonsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallAddonsReqValidationError{}

// Validate checks the field values on UninstallAddonsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninstallAddonsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninstallAddonsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninstallAddonsRespMultiError, or nil if none found.
func (m *UninstallAddonsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UninstallAddonsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Result

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UninstallAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UninstallAddonsRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UninstallAddonsRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UninstallAddonsRespMultiError(errors)
	}

	return nil
}

// UninstallAddonsRespMultiError is an error wrapping multiple validation
// errors returned by UninstallAddonsResp.ValidateAll() if the designated
// constraints aren't met.
type UninstallAddonsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninstallAddonsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninstallAddonsRespMultiError) AllErrors() []error { return m }

// UninstallAddonsRespValidationError is the validation error returned by
// UninstallAddonsResp.Validate if the designated constraints aren't met.
type UninstallAddonsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninstallAddonsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninstallAddonsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninstallAddonsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninstallAddonsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninstallAddonsRespValidationError) ErrorName() string {
	return "UninstallAddonsRespValidationError"
}

// Error satisfies the builtin error interface
func (e UninstallAddonsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninstallAddonsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninstallAddonsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninstallAddonsRespValidationError{}
