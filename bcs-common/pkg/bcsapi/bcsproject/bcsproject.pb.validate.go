// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: bcsproject.proto

package bcsproject

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Project) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProjectMultiError, or nil if none found.
func (m *Project) ValidateAll() error {
	return m.validate(true)
}

func (m *Project) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for Managers

	// no validation rules for ProjectID

	// no validation rules for Name

	// no validation rules for ProjectCode

	// no validation rules for UseBKRes

	// no validation rules for Description

	// no validation rules for IsOffline

	// no validation rules for Kind

	// no validation rules for BusinessID

	// no validation rules for BusinessName

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return ProjectMultiError(errors)
	}

	return nil
}

// ProjectMultiError is an error wrapping multiple validation errors returned
// by Project.ValidateAll() if the designated constraints aren't met.
type ProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectMultiError) AllErrors() []error { return m }

// ProjectValidationError is the validation error returned by Project.Validate
// if the designated constraints aren't met.
type ProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectValidationError) ErrorName() string { return "ProjectValidationError" }

// Error satisfies the builtin error interface
func (e ProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectValidationError{}

// Validate checks the field values on CreateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProjectRequestMultiError, or nil if none found.
func (m *CreateProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreateTime

	// no validation rules for Creator

	// no validation rules for ProjectID

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 64 {
		err := CreateProjectRequestValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 2 || l > 64 {
		err := CreateProjectRequestValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for UseBKRes

	// no validation rules for Description

	// no validation rules for IsOffline

	if _, ok := _CreateProjectRequest_Kind_InLookup[m.GetKind()]; !ok {
		err := CreateProjectRequestValidationError{
			field:  "Kind",
			reason: "value must be in list [ k8s mesos]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for BusinessID

	// no validation rules for IsSecret

	// no validation rules for ProjectType

	if _, ok := _CreateProjectRequest_DeployType_InLookup[m.GetDeployType()]; !ok {
		err := CreateProjectRequestValidationError{
			field:  "DeployType",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for BGID

	// no validation rules for BGName

	// no validation rules for DeptID

	// no validation rules for DeptName

	// no validation rules for CenterID

	// no validation rules for CenterName

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return CreateProjectRequestMultiError(errors)
	}

	return nil
}

// CreateProjectRequestMultiError is an error wrapping multiple validation
// errors returned by CreateProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProjectRequestMultiError) AllErrors() []error { return m }

// CreateProjectRequestValidationError is the validation error returned by
// CreateProjectRequest.Validate if the designated constraints aren't met.
type CreateProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProjectRequestValidationError) ErrorName() string {
	return "CreateProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProjectRequestValidationError{}

var _CreateProjectRequest_Kind_InLookup = map[string]struct{}{
	"":      {},
	"k8s":   {},
	"mesos": {},
}

var _CreateProjectRequest_DeployType_InLookup = map[uint32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on GetProjectRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectRequestMultiError, or nil if none found.
func (m *GetProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectIDOrCode

	if len(errors) > 0 {
		return GetProjectRequestMultiError(errors)
	}

	return nil
}

// GetProjectRequestMultiError is an error wrapping multiple validation errors
// returned by GetProjectRequest.ValidateAll() if the designated constraints
// aren't met.
type GetProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectRequestMultiError) AllErrors() []error { return m }

// GetProjectRequestValidationError is the validation error returned by
// GetProjectRequest.Validate if the designated constraints aren't met.
type GetProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectRequestValidationError) ErrorName() string {
	return "GetProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectRequestValidationError{}

// Validate checks the field values on UpdateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProjectRequestMultiError, or nil if none found.
func (m *UpdateProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) != 32 {
		err := UpdateProjectRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if !_UpdateProjectRequest_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := UpdateProjectRequestValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) > 64 {
		err := UpdateProjectRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Updater

	if all {
		switch v := interface{}(m.GetUseBKRes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "UseBKRes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "UseBKRes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseBKRes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProjectRequestValidationError{
				field:  "UseBKRes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetIsOffline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "IsOffline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProjectRequestValidationError{
					field:  "IsOffline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsOffline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProjectRequestValidationError{
				field:  "IsOffline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Kind

	// no validation rules for BusinessID

	// no validation rules for Managers

	// no validation rules for Creator

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return UpdateProjectRequestMultiError(errors)
	}

	return nil
}

// UpdateProjectRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProjectRequestMultiError) AllErrors() []error { return m }

// UpdateProjectRequestValidationError is the validation error returned by
// UpdateProjectRequest.Validate if the designated constraints aren't met.
type UpdateProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProjectRequestValidationError) ErrorName() string {
	return "UpdateProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProjectRequestValidationError{}

var _UpdateProjectRequest_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteProjectRequestMultiError, or nil if none found.
func (m *DeleteProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) != 32 {
		err := DeleteProjectRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if !_DeleteProjectRequest_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := DeleteProjectRequestValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteProjectRequestMultiError(errors)
	}

	return nil
}

// DeleteProjectRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteProjectRequestMultiError) AllErrors() []error { return m }

// DeleteProjectRequestValidationError is the validation error returned by
// DeleteProjectRequest.Validate if the designated constraints aren't met.
type DeleteProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteProjectRequestValidationError) ErrorName() string {
	return "DeleteProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteProjectRequestValidationError{}

var _DeleteProjectRequest_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ProjectResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectResponseMultiError, or nil if none found.
func (m *ProjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProjectResponseMultiError(errors)
	}

	return nil
}

// ProjectResponseMultiError is an error wrapping multiple validation errors
// returned by ProjectResponse.ValidateAll() if the designated constraints
// aren't met.
type ProjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectResponseMultiError) AllErrors() []error { return m }

// ProjectResponseValidationError is the validation error returned by
// ProjectResponse.Validate if the designated constraints aren't met.
type ProjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectResponseValidationError) ErrorName() string { return "ProjectResponseValidationError" }

// Error satisfies the builtin error interface
func (e ProjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectResponseValidationError{}

// Validate checks the field values on ListProjectsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectsRequestMultiError, or nil if none found.
func (m *ListProjectsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectIDs

	// no validation rules for Names

	// no validation rules for ProjectCode

	// no validation rules for SearchName

	// no validation rules for Kind

	// no validation rules for Offset

	// no validation rules for Limit

	// no validation rules for All

	// no validation rules for BusinessID

	if len(errors) > 0 {
		return ListProjectsRequestMultiError(errors)
	}

	return nil
}

// ListProjectsRequestMultiError is an error wrapping multiple validation
// errors returned by ListProjectsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListProjectsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectsRequestMultiError) AllErrors() []error { return m }

// ListProjectsRequestValidationError is the validation error returned by
// ListProjectsRequest.Validate if the designated constraints aren't met.
type ListProjectsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectsRequestValidationError) ErrorName() string {
	return "ListProjectsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectsRequestValidationError{}

// Validate checks the field values on ListProjectData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListProjectData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectDataMultiError, or nil if none found.
func (m *ListProjectData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectDataValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListProjectDataMultiError(errors)
	}

	return nil
}

// ListProjectDataMultiError is an error wrapping multiple validation errors
// returned by ListProjectData.ValidateAll() if the designated constraints
// aren't met.
type ListProjectDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectDataMultiError) AllErrors() []error { return m }

// ListProjectDataValidationError is the validation error returned by
// ListProjectData.Validate if the designated constraints aren't met.
type ListProjectDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectDataValidationError) ErrorName() string { return "ListProjectDataValidationError" }

// Error satisfies the builtin error interface
func (e ListProjectDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectDataValidationError{}

// Validate checks the field values on ListProjectsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectsResponseMultiError, or nil if none found.
func (m *ListProjectsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProjectsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProjectsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProjectsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProjectsResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProjectsResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProjectsResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListProjectsResponseMultiError(errors)
	}

	return nil
}

// ListProjectsResponseMultiError is an error wrapping multiple validation
// errors returned by ListProjectsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListProjectsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectsResponseMultiError) AllErrors() []error { return m }

// ListProjectsResponseValidationError is the validation error returned by
// ListProjectsResponse.Validate if the designated constraints aren't met.
type ListProjectsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectsResponseValidationError) ErrorName() string {
	return "ListProjectsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectsResponseValidationError{}

// Validate checks the field values on Perms with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Perms) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Perms with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PermsMultiError, or nil if none found.
func (m *Perms) ValidateAll() error {
	return m.validate(true)
}

func (m *Perms) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPerms()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PermsValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PermsValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerms()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PermsValidationError{
				field:  "Perms",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PermsMultiError(errors)
	}

	return nil
}

// PermsMultiError is an error wrapping multiple validation errors returned by
// Perms.ValidateAll() if the designated constraints aren't met.
type PermsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermsMultiError) AllErrors() []error { return m }

// PermsValidationError is the validation error returned by Perms.Validate if
// the designated constraints aren't met.
type PermsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermsValidationError) ErrorName() string { return "PermsValidationError" }

// Error satisfies the builtin error interface
func (e PermsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPerms.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermsValidationError{}

// Validate checks the field values on ListAuthorizedProjReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAuthorizedProjReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAuthorizedProjReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAuthorizedProjReqMultiError, or nil if none found.
func (m *ListAuthorizedProjReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAuthorizedProjReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for All

	// no validation rules for Kind

	// no validation rules for SearchKey

	// no validation rules for Offset

	// no validation rules for Limit

	if len(errors) > 0 {
		return ListAuthorizedProjReqMultiError(errors)
	}

	return nil
}

// ListAuthorizedProjReqMultiError is an error wrapping multiple validation
// errors returned by ListAuthorizedProjReq.ValidateAll() if the designated
// constraints aren't met.
type ListAuthorizedProjReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAuthorizedProjReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAuthorizedProjReqMultiError) AllErrors() []error { return m }

// ListAuthorizedProjReqValidationError is the validation error returned by
// ListAuthorizedProjReq.Validate if the designated constraints aren't met.
type ListAuthorizedProjReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAuthorizedProjReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAuthorizedProjReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAuthorizedProjReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAuthorizedProjReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAuthorizedProjReqValidationError) ErrorName() string {
	return "ListAuthorizedProjReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListAuthorizedProjReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAuthorizedProjReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAuthorizedProjReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAuthorizedProjReqValidationError{}

// Validate checks the field values on ListAuthorizedProjResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAuthorizedProjResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAuthorizedProjResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAuthorizedProjRespMultiError, or nil if none found.
func (m *ListAuthorizedProjResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAuthorizedProjResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAuthorizedProjRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAuthorizedProjRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAuthorizedProjRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAuthorizedProjRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAuthorizedProjRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAuthorizedProjRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListAuthorizedProjRespMultiError(errors)
	}

	return nil
}

// ListAuthorizedProjRespMultiError is an error wrapping multiple validation
// errors returned by ListAuthorizedProjResp.ValidateAll() if the designated
// constraints aren't met.
type ListAuthorizedProjRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAuthorizedProjRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAuthorizedProjRespMultiError) AllErrors() []error { return m }

// ListAuthorizedProjRespValidationError is the validation error returned by
// ListAuthorizedProjResp.Validate if the designated constraints aren't met.
type ListAuthorizedProjRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAuthorizedProjRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAuthorizedProjRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAuthorizedProjRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAuthorizedProjRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAuthorizedProjRespValidationError) ErrorName() string {
	return "ListAuthorizedProjRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListAuthorizedProjRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAuthorizedProjResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAuthorizedProjRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAuthorizedProjRespValidationError{}

// Validate checks the field values on ListProjectsForIAMReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectsForIAMReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectsForIAMReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectsForIAMReqMultiError, or nil if none found.
func (m *ListProjectsForIAMReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectsForIAMReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListProjectsForIAMReqMultiError(errors)
	}

	return nil
}

// ListProjectsForIAMReqMultiError is an error wrapping multiple validation
// errors returned by ListProjectsForIAMReq.ValidateAll() if the designated
// constraints aren't met.
type ListProjectsForIAMReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectsForIAMReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectsForIAMReqMultiError) AllErrors() []error { return m }

// ListProjectsForIAMReqValidationError is the validation error returned by
// ListProjectsForIAMReq.Validate if the designated constraints aren't met.
type ListProjectsForIAMReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectsForIAMReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectsForIAMReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectsForIAMReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectsForIAMReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectsForIAMReqValidationError) ErrorName() string {
	return "ListProjectsForIAMReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectsForIAMReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectsForIAMReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectsForIAMReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectsForIAMReqValidationError{}

// Validate checks the field values on ListProjectsForIAMResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectsForIAMResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectsForIAMResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectsForIAMRespMultiError, or nil if none found.
func (m *ListProjectsForIAMResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectsForIAMResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectsForIAMRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectsForIAMRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectsForIAMRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListProjectsForIAMRespMultiError(errors)
	}

	return nil
}

// ListProjectsForIAMRespMultiError is an error wrapping multiple validation
// errors returned by ListProjectsForIAMResp.ValidateAll() if the designated
// constraints aren't met.
type ListProjectsForIAMRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectsForIAMRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectsForIAMRespMultiError) AllErrors() []error { return m }

// ListProjectsForIAMRespValidationError is the validation error returned by
// ListProjectsForIAMResp.Validate if the designated constraints aren't met.
type ListProjectsForIAMRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectsForIAMRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectsForIAMRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectsForIAMRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectsForIAMRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectsForIAMRespValidationError) ErrorName() string {
	return "ListProjectsForIAMRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectsForIAMRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectsForIAMResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectsForIAMRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectsForIAMRespValidationError{}

// Validate checks the field values on GetProjectActiveRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectActiveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectActiveRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectActiveRequestMultiError, or nil if none found.
func (m *GetProjectActiveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectActiveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectIDOrCode

	if len(errors) > 0 {
		return GetProjectActiveRequestMultiError(errors)
	}

	return nil
}

// GetProjectActiveRequestMultiError is an error wrapping multiple validation
// errors returned by GetProjectActiveRequest.ValidateAll() if the designated
// constraints aren't met.
type GetProjectActiveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectActiveRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectActiveRequestMultiError) AllErrors() []error { return m }

// GetProjectActiveRequestValidationError is the validation error returned by
// GetProjectActiveRequest.Validate if the designated constraints aren't met.
type GetProjectActiveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectActiveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectActiveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectActiveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectActiveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectActiveRequestValidationError) ErrorName() string {
	return "GetProjectActiveRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectActiveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectActiveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectActiveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectActiveRequestValidationError{}

// Validate checks the field values on GetProjectActiveResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectActiveResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectActiveResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectActiveResponseMultiError, or nil if none found.
func (m *GetProjectActiveResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectActiveResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProjectActiveResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProjectActiveResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProjectActiveResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return GetProjectActiveResponseMultiError(errors)
	}

	return nil
}

// GetProjectActiveResponseMultiError is an error wrapping multiple validation
// errors returned by GetProjectActiveResponse.ValidateAll() if the designated
// constraints aren't met.
type GetProjectActiveResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectActiveResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectActiveResponseMultiError) AllErrors() []error { return m }

// GetProjectActiveResponseValidationError is the validation error returned by
// GetProjectActiveResponse.Validate if the designated constraints aren't met.
type GetProjectActiveResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectActiveResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectActiveResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectActiveResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectActiveResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectActiveResponseValidationError) ErrorName() string {
	return "GetProjectActiveResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectActiveResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectActiveResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectActiveResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectActiveResponseValidationError{}

// Validate checks the field values on ProjectActiveData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProjectActiveData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectActiveData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectActiveDataMultiError, or nil if none found.
func (m *ProjectActiveData) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectActiveData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsActive

	if len(errors) > 0 {
		return ProjectActiveDataMultiError(errors)
	}

	return nil
}

// ProjectActiveDataMultiError is an error wrapping multiple validation errors
// returned by ProjectActiveData.ValidateAll() if the designated constraints
// aren't met.
type ProjectActiveDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectActiveDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectActiveDataMultiError) AllErrors() []error { return m }

// ProjectActiveDataValidationError is the validation error returned by
// ProjectActiveData.Validate if the designated constraints aren't met.
type ProjectActiveDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectActiveDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectActiveDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectActiveDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectActiveDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectActiveDataValidationError) ErrorName() string {
	return "ProjectActiveDataValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectActiveDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectActiveData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectActiveDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectActiveDataValidationError{}

// Validate checks the field values on GetBusinessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBusinessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBusinessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBusinessRequestMultiError, or nil if none found.
func (m *GetBusinessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBusinessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	if len(errors) > 0 {
		return GetBusinessRequestMultiError(errors)
	}

	return nil
}

// GetBusinessRequestMultiError is an error wrapping multiple validation errors
// returned by GetBusinessRequest.ValidateAll() if the designated constraints
// aren't met.
type GetBusinessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBusinessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBusinessRequestMultiError) AllErrors() []error { return m }

// GetBusinessRequestValidationError is the validation error returned by
// GetBusinessRequest.Validate if the designated constraints aren't met.
type GetBusinessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBusinessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBusinessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBusinessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBusinessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBusinessRequestValidationError) ErrorName() string {
	return "GetBusinessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBusinessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBusinessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBusinessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBusinessRequestValidationError{}

// Validate checks the field values on GetBusinessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBusinessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBusinessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBusinessResponseMultiError, or nil if none found.
func (m *GetBusinessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBusinessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBusinessResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBusinessResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBusinessResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBusinessResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBusinessResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBusinessResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBusinessResponseMultiError(errors)
	}

	return nil
}

// GetBusinessResponseMultiError is an error wrapping multiple validation
// errors returned by GetBusinessResponse.ValidateAll() if the designated
// constraints aren't met.
type GetBusinessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBusinessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBusinessResponseMultiError) AllErrors() []error { return m }

// GetBusinessResponseValidationError is the validation error returned by
// GetBusinessResponse.Validate if the designated constraints aren't met.
type GetBusinessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBusinessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBusinessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBusinessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBusinessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBusinessResponseValidationError) ErrorName() string {
	return "GetBusinessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBusinessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBusinessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBusinessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBusinessResponseValidationError{}

// Validate checks the field values on ListBusinessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBusinessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBusinessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBusinessRequestMultiError, or nil if none found.
func (m *ListBusinessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBusinessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UseBCS

	if len(errors) > 0 {
		return ListBusinessRequestMultiError(errors)
	}

	return nil
}

// ListBusinessRequestMultiError is an error wrapping multiple validation
// errors returned by ListBusinessRequest.ValidateAll() if the designated
// constraints aren't met.
type ListBusinessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBusinessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBusinessRequestMultiError) AllErrors() []error { return m }

// ListBusinessRequestValidationError is the validation error returned by
// ListBusinessRequest.Validate if the designated constraints aren't met.
type ListBusinessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBusinessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBusinessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBusinessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBusinessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBusinessRequestValidationError) ErrorName() string {
	return "ListBusinessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBusinessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBusinessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBusinessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBusinessRequestValidationError{}

// Validate checks the field values on ListBusinessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBusinessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBusinessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBusinessResponseMultiError, or nil if none found.
func (m *ListBusinessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBusinessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBusinessResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBusinessResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBusinessResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListBusinessResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListBusinessResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListBusinessResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListBusinessResponseMultiError(errors)
	}

	return nil
}

// ListBusinessResponseMultiError is an error wrapping multiple validation
// errors returned by ListBusinessResponse.ValidateAll() if the designated
// constraints aren't met.
type ListBusinessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBusinessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBusinessResponseMultiError) AllErrors() []error { return m }

// ListBusinessResponseValidationError is the validation error returned by
// ListBusinessResponse.Validate if the designated constraints aren't met.
type ListBusinessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBusinessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBusinessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBusinessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBusinessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBusinessResponseValidationError) ErrorName() string {
	return "ListBusinessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBusinessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBusinessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBusinessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBusinessResponseValidationError{}

// Validate checks the field values on GetBusinessTopologyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBusinessTopologyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBusinessTopologyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBusinessTopologyRequestMultiError, or nil if none found.
func (m *GetBusinessTopologyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBusinessTopologyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	if len(errors) > 0 {
		return GetBusinessTopologyRequestMultiError(errors)
	}

	return nil
}

// GetBusinessTopologyRequestMultiError is an error wrapping multiple
// validation errors returned by GetBusinessTopologyRequest.ValidateAll() if
// the designated constraints aren't met.
type GetBusinessTopologyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBusinessTopologyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBusinessTopologyRequestMultiError) AllErrors() []error { return m }

// GetBusinessTopologyRequestValidationError is the validation error returned
// by GetBusinessTopologyRequest.Validate if the designated constraints aren't met.
type GetBusinessTopologyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBusinessTopologyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBusinessTopologyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBusinessTopologyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBusinessTopologyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBusinessTopologyRequestValidationError) ErrorName() string {
	return "GetBusinessTopologyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBusinessTopologyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBusinessTopologyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBusinessTopologyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBusinessTopologyRequestValidationError{}

// Validate checks the field values on GetBusinessTopologyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBusinessTopologyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBusinessTopologyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBusinessTopologyResponseMultiError, or nil if none found.
func (m *GetBusinessTopologyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBusinessTopologyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBusinessTopologyResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBusinessTopologyResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBusinessTopologyResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBusinessTopologyResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBusinessTopologyResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBusinessTopologyResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBusinessTopologyResponseMultiError(errors)
	}

	return nil
}

// GetBusinessTopologyResponseMultiError is an error wrapping multiple
// validation errors returned by GetBusinessTopologyResponse.ValidateAll() if
// the designated constraints aren't met.
type GetBusinessTopologyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBusinessTopologyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBusinessTopologyResponseMultiError) AllErrors() []error { return m }

// GetBusinessTopologyResponseValidationError is the validation error returned
// by GetBusinessTopologyResponse.Validate if the designated constraints
// aren't met.
type GetBusinessTopologyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBusinessTopologyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBusinessTopologyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBusinessTopologyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBusinessTopologyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBusinessTopologyResponseValidationError) ErrorName() string {
	return "GetBusinessTopologyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBusinessTopologyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBusinessTopologyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBusinessTopologyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBusinessTopologyResponseValidationError{}

// Validate checks the field values on BusinessData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BusinessData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BusinessDataMultiError, or
// nil if none found.
func (m *BusinessData) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BusinessID

	// no validation rules for Name

	if len(errors) > 0 {
		return BusinessDataMultiError(errors)
	}

	return nil
}

// BusinessDataMultiError is an error wrapping multiple validation errors
// returned by BusinessData.ValidateAll() if the designated constraints aren't met.
type BusinessDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessDataMultiError) AllErrors() []error { return m }

// BusinessDataValidationError is the validation error returned by
// BusinessData.Validate if the designated constraints aren't met.
type BusinessDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessDataValidationError) ErrorName() string { return "BusinessDataValidationError" }

// Error satisfies the builtin error interface
func (e BusinessDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessDataValidationError{}

// Validate checks the field values on TopologyData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TopologyData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TopologyData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TopologyDataMultiError, or
// nil if none found.
func (m *TopologyData) ValidateAll() error {
	return m.validate(true)
}

func (m *TopologyData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BkInstId

	// no validation rules for BkInstName

	// no validation rules for BkObjId

	// no validation rules for BkObjName

	// no validation rules for Default

	for idx, item := range m.GetChild() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TopologyDataValidationError{
						field:  fmt.Sprintf("Child[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TopologyDataValidationError{
						field:  fmt.Sprintf("Child[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TopologyDataValidationError{
					field:  fmt.Sprintf("Child[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TopologyDataMultiError(errors)
	}

	return nil
}

// TopologyDataMultiError is an error wrapping multiple validation errors
// returned by TopologyData.ValidateAll() if the designated constraints aren't met.
type TopologyDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TopologyDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TopologyDataMultiError) AllErrors() []error { return m }

// TopologyDataValidationError is the validation error returned by
// TopologyData.Validate if the designated constraints aren't met.
type TopologyDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TopologyDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TopologyDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TopologyDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TopologyDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TopologyDataValidationError) ErrorName() string { return "TopologyDataValidationError" }

// Error satisfies the builtin error interface
func (e TopologyDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTopologyData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TopologyDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TopologyDataValidationError{}

// Validate checks the field values on SyncNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncNamespaceRequestMultiError, or nil if none found.
func (m *SyncNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return SyncNamespaceRequestMultiError(errors)
	}

	return nil
}

// SyncNamespaceRequestMultiError is an error wrapping multiple validation
// errors returned by SyncNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type SyncNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncNamespaceRequestMultiError) AllErrors() []error { return m }

// SyncNamespaceRequestValidationError is the validation error returned by
// SyncNamespaceRequest.Validate if the designated constraints aren't met.
type SyncNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncNamespaceRequestValidationError) ErrorName() string {
	return "SyncNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SyncNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncNamespaceRequestValidationError{}

// Validate checks the field values on SyncNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncNamespaceResponseMultiError, or nil if none found.
func (m *SyncNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Data

	// no validation rules for RequestID

	if len(errors) > 0 {
		return SyncNamespaceResponseMultiError(errors)
	}

	return nil
}

// SyncNamespaceResponseMultiError is an error wrapping multiple validation
// errors returned by SyncNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type SyncNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncNamespaceResponseMultiError) AllErrors() []error { return m }

// SyncNamespaceResponseValidationError is the validation error returned by
// SyncNamespaceResponse.Validate if the designated constraints aren't met.
type SyncNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncNamespaceResponseValidationError) ErrorName() string {
	return "SyncNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SyncNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncNamespaceResponseValidationError{}

// Validate checks the field values on WithdrawNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WithdrawNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WithdrawNamespaceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WithdrawNamespaceRequestMultiError, or nil if none found.
func (m *WithdrawNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WithdrawNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	// no validation rules for Namespace

	if len(errors) > 0 {
		return WithdrawNamespaceRequestMultiError(errors)
	}

	return nil
}

// WithdrawNamespaceRequestMultiError is an error wrapping multiple validation
// errors returned by WithdrawNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type WithdrawNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WithdrawNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WithdrawNamespaceRequestMultiError) AllErrors() []error { return m }

// WithdrawNamespaceRequestValidationError is the validation error returned by
// WithdrawNamespaceRequest.Validate if the designated constraints aren't met.
type WithdrawNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WithdrawNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WithdrawNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WithdrawNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WithdrawNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WithdrawNamespaceRequestValidationError) ErrorName() string {
	return "WithdrawNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WithdrawNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWithdrawNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WithdrawNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WithdrawNamespaceRequestValidationError{}

// Validate checks the field values on WithdrawNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WithdrawNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WithdrawNamespaceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WithdrawNamespaceResponseMultiError, or nil if none found.
func (m *WithdrawNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WithdrawNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Data

	// no validation rules for RequestID

	if len(errors) > 0 {
		return WithdrawNamespaceResponseMultiError(errors)
	}

	return nil
}

// WithdrawNamespaceResponseMultiError is an error wrapping multiple validation
// errors returned by WithdrawNamespaceResponse.ValidateAll() if the
// designated constraints aren't met.
type WithdrawNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WithdrawNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WithdrawNamespaceResponseMultiError) AllErrors() []error { return m }

// WithdrawNamespaceResponseValidationError is the validation error returned by
// WithdrawNamespaceResponse.Validate if the designated constraints aren't met.
type WithdrawNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WithdrawNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WithdrawNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WithdrawNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WithdrawNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WithdrawNamespaceResponseValidationError) ErrorName() string {
	return "WithdrawNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WithdrawNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWithdrawNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WithdrawNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WithdrawNamespaceResponseValidationError{}

// Validate checks the field values on CreateNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceRequestMultiError, or nil if none found.
func (m *CreateNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	if utf8.RuneCountInString(m.GetName()) > 63 {
		err := CreateNamespaceRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 63 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateNamespaceRequest_Name_Pattern.MatchString(m.GetName()) {
		err := CreateNamespaceRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNamespaceRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNamespaceRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNamespaceRequestValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNamespaceRequestValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNamespaceRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVariables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNamespaceRequestValidationError{
					field:  fmt.Sprintf("Variables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateNamespaceRequestMultiError(errors)
	}

	return nil
}

// CreateNamespaceRequestMultiError is an error wrapping multiple validation
// errors returned by CreateNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceRequestMultiError) AllErrors() []error { return m }

// CreateNamespaceRequestValidationError is the validation error returned by
// CreateNamespaceRequest.Validate if the designated constraints aren't met.
type CreateNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceRequestValidationError) ErrorName() string {
	return "CreateNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceRequestValidationError{}

var _CreateNamespaceRequest_Name_Pattern = regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?$")

// Validate checks the field values on CreateNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNamespaceResponseMultiError, or nil if none found.
func (m *CreateNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNamespaceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNamespaceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNamespaceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNamespaceResponseMultiError(errors)
	}

	return nil
}

// CreateNamespaceResponseMultiError is an error wrapping multiple validation
// errors returned by CreateNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceResponseMultiError) AllErrors() []error { return m }

// CreateNamespaceResponseValidationError is the validation error returned by
// CreateNamespaceResponse.Validate if the designated constraints aren't met.
type CreateNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceResponseValidationError) ErrorName() string {
	return "CreateNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceResponseValidationError{}

// Validate checks the field values on NamespaceCallbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamespaceCallbackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceCallbackRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamespaceCallbackRequestMultiError, or nil if none found.
func (m *NamespaceCallbackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceCallbackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	if utf8.RuneCountInString(m.GetNamespace()) > 63 {
		err := NamespaceCallbackRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at most 63 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_NamespaceCallbackRequest_Namespace_Pattern.MatchString(m.GetNamespace()) {
		err := NamespaceCallbackRequestValidationError{
			field:  "Namespace",
			reason: "value does not match regex pattern \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Title

	// no validation rules for CurrentStatus

	// no validation rules for Sn

	// no validation rules for TicketUrl

	// no validation rules for ApproveResult

	// no validation rules for ApplyInCluster

	if len(errors) > 0 {
		return NamespaceCallbackRequestMultiError(errors)
	}

	return nil
}

// NamespaceCallbackRequestMultiError is an error wrapping multiple validation
// errors returned by NamespaceCallbackRequest.ValidateAll() if the designated
// constraints aren't met.
type NamespaceCallbackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceCallbackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceCallbackRequestMultiError) AllErrors() []error { return m }

// NamespaceCallbackRequestValidationError is the validation error returned by
// NamespaceCallbackRequest.Validate if the designated constraints aren't met.
type NamespaceCallbackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceCallbackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceCallbackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceCallbackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceCallbackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceCallbackRequestValidationError) ErrorName() string {
	return "NamespaceCallbackRequestValidationError"
}

// Error satisfies the builtin error interface
func (e NamespaceCallbackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceCallbackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceCallbackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceCallbackRequestValidationError{}

var _NamespaceCallbackRequest_Namespace_Pattern = regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?$")

// Validate checks the field values on NamespaceCallbackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamespaceCallbackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceCallbackResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamespaceCallbackResponseMultiError, or nil if none found.
func (m *NamespaceCallbackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceCallbackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Data

	// no validation rules for RequestID

	// no validation rules for Result

	if len(errors) > 0 {
		return NamespaceCallbackResponseMultiError(errors)
	}

	return nil
}

// NamespaceCallbackResponseMultiError is an error wrapping multiple validation
// errors returned by NamespaceCallbackResponse.ValidateAll() if the
// designated constraints aren't met.
type NamespaceCallbackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceCallbackResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceCallbackResponseMultiError) AllErrors() []error { return m }

// NamespaceCallbackResponseValidationError is the validation error returned by
// NamespaceCallbackResponse.Validate if the designated constraints aren't met.
type NamespaceCallbackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceCallbackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceCallbackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceCallbackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceCallbackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceCallbackResponseValidationError) ErrorName() string {
	return "NamespaceCallbackResponseValidationError"
}

// Error satisfies the builtin error interface
func (e NamespaceCallbackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceCallbackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceCallbackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceCallbackResponseValidationError{}

// Validate checks the field values on UpdateNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNamespaceRequestMultiError, or nil if none found.
func (m *UpdateNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	if utf8.RuneCountInString(m.GetNamespace()) > 63 {
		err := UpdateNamespaceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at most 63 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateNamespaceRequest_Namespace_Pattern.MatchString(m.GetNamespace()) {
		err := UpdateNamespaceRequestValidationError{
			field:  "Namespace",
			reason: "value does not match regex pattern \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNamespaceRequestValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNamespaceRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNamespaceRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNamespaceRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNamespaceRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNamespaceRequestValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNamespaceRequestMultiError(errors)
	}

	return nil
}

// UpdateNamespaceRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceRequestMultiError) AllErrors() []error { return m }

// UpdateNamespaceRequestValidationError is the validation error returned by
// UpdateNamespaceRequest.Validate if the designated constraints aren't met.
type UpdateNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceRequestValidationError) ErrorName() string {
	return "UpdateNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceRequestValidationError{}

var _UpdateNamespaceRequest_Namespace_Pattern = regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?$")

// Validate checks the field values on UpdateNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNamespaceResponseMultiError, or nil if none found.
func (m *UpdateNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNamespaceResponseMultiError(errors)
	}

	return nil
}

// UpdateNamespaceResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceResponseMultiError) AllErrors() []error { return m }

// UpdateNamespaceResponseValidationError is the validation error returned by
// UpdateNamespaceResponse.Validate if the designated constraints aren't met.
type UpdateNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceResponseValidationError) ErrorName() string {
	return "UpdateNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceResponseValidationError{}

// Validate checks the field values on GetNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNamespaceRequestMultiError, or nil if none found.
func (m *GetNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	// no validation rules for Namespace

	if len(errors) > 0 {
		return GetNamespaceRequestMultiError(errors)
	}

	return nil
}

// GetNamespaceRequestMultiError is an error wrapping multiple validation
// errors returned by GetNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceRequestMultiError) AllErrors() []error { return m }

// GetNamespaceRequestValidationError is the validation error returned by
// GetNamespaceRequest.Validate if the designated constraints aren't met.
type GetNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceRequestValidationError) ErrorName() string {
	return "GetNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceRequestValidationError{}

// Validate checks the field values on GetNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNamespaceResponseMultiError, or nil if none found.
func (m *GetNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNamespaceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNamespaceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNamespaceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNamespaceResponseMultiError(errors)
	}

	return nil
}

// GetNamespaceResponseMultiError is an error wrapping multiple validation
// errors returned by GetNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceResponseMultiError) AllErrors() []error { return m }

// GetNamespaceResponseValidationError is the validation error returned by
// GetNamespaceResponse.Validate if the designated constraints aren't met.
type GetNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceResponseValidationError) ErrorName() string {
	return "GetNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceResponseValidationError{}

// Validate checks the field values on ListNamespacesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespacesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespacesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNamespacesRequestMultiError, or nil if none found.
func (m *ListNamespacesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespacesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ListNamespacesRequestMultiError(errors)
	}

	return nil
}

// ListNamespacesRequestMultiError is an error wrapping multiple validation
// errors returned by ListNamespacesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListNamespacesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespacesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespacesRequestMultiError) AllErrors() []error { return m }

// ListNamespacesRequestValidationError is the validation error returned by
// ListNamespacesRequest.Validate if the designated constraints aren't met.
type ListNamespacesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespacesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespacesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespacesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespacesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespacesRequestValidationError) ErrorName() string {
	return "ListNamespacesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespacesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespacesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespacesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespacesRequestValidationError{}

// Validate checks the field values on ListNamespacesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespacesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespacesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNamespacesResponseMultiError, or nil if none found.
func (m *ListNamespacesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespacesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNamespacesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNamespacesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNamespacesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNamespacesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNamespacesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNamespacesResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListNamespacesResponseMultiError(errors)
	}

	return nil
}

// ListNamespacesResponseMultiError is an error wrapping multiple validation
// errors returned by ListNamespacesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListNamespacesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespacesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespacesResponseMultiError) AllErrors() []error { return m }

// ListNamespacesResponseValidationError is the validation error returned by
// ListNamespacesResponse.Validate if the designated constraints aren't met.
type ListNamespacesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespacesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespacesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespacesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespacesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespacesResponseValidationError) ErrorName() string {
	return "ListNamespacesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespacesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespacesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespacesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespacesResponseValidationError{}

// Validate checks the field values on ListNativeNamespacesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNativeNamespacesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNativeNamespacesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNativeNamespacesRequestMultiError, or nil if none found.
func (m *ListNativeNamespacesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNativeNamespacesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectIDOrCode

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ListNativeNamespacesRequestMultiError(errors)
	}

	return nil
}

// ListNativeNamespacesRequestMultiError is an error wrapping multiple
// validation errors returned by ListNativeNamespacesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListNativeNamespacesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNativeNamespacesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNativeNamespacesRequestMultiError) AllErrors() []error { return m }

// ListNativeNamespacesRequestValidationError is the validation error returned
// by ListNativeNamespacesRequest.Validate if the designated constraints
// aren't met.
type ListNativeNamespacesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNativeNamespacesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNativeNamespacesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNativeNamespacesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNativeNamespacesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNativeNamespacesRequestValidationError) ErrorName() string {
	return "ListNativeNamespacesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNativeNamespacesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNativeNamespacesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNativeNamespacesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNativeNamespacesRequestValidationError{}

// Validate checks the field values on ListNativeNamespacesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNativeNamespacesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNativeNamespacesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNativeNamespacesResponseMultiError, or nil if none found.
func (m *ListNativeNamespacesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNativeNamespacesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNativeNamespacesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNativeNamespacesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNativeNamespacesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNativeNamespacesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNativeNamespacesResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNativeNamespacesResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListNativeNamespacesResponseMultiError(errors)
	}

	return nil
}

// ListNativeNamespacesResponseMultiError is an error wrapping multiple
// validation errors returned by ListNativeNamespacesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListNativeNamespacesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNativeNamespacesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNativeNamespacesResponseMultiError) AllErrors() []error { return m }

// ListNativeNamespacesResponseValidationError is the validation error returned
// by ListNativeNamespacesResponse.Validate if the designated constraints
// aren't met.
type ListNativeNamespacesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNativeNamespacesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNativeNamespacesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNativeNamespacesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNativeNamespacesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNativeNamespacesResponseValidationError) ErrorName() string {
	return "ListNativeNamespacesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNativeNamespacesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNativeNamespacesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNativeNamespacesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNativeNamespacesResponseValidationError{}

// Validate checks the field values on ListNativeNamespacesContentRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListNativeNamespacesContentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNativeNamespacesContentRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListNativeNamespacesContentRequestMultiError, or nil if none found.
func (m *ListNativeNamespacesContentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNativeNamespacesContentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectIDOrCode

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ListNativeNamespacesContentRequestMultiError(errors)
	}

	return nil
}

// ListNativeNamespacesContentRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListNativeNamespacesContentRequest.ValidateAll() if the designated
// constraints aren't met.
type ListNativeNamespacesContentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNativeNamespacesContentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNativeNamespacesContentRequestMultiError) AllErrors() []error { return m }

// ListNativeNamespacesContentRequestValidationError is the validation error
// returned by ListNativeNamespacesContentRequest.Validate if the designated
// constraints aren't met.
type ListNativeNamespacesContentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNativeNamespacesContentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNativeNamespacesContentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNativeNamespacesContentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNativeNamespacesContentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNativeNamespacesContentRequestValidationError) ErrorName() string {
	return "ListNativeNamespacesContentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNativeNamespacesContentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNativeNamespacesContentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNativeNamespacesContentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNativeNamespacesContentRequestValidationError{}

// Validate checks the field values on DeleteNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNamespaceRequestMultiError, or nil if none found.
func (m *DeleteNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	if utf8.RuneCountInString(m.GetNamespace()) > 63 {
		err := DeleteNamespaceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at most 63 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteNamespaceRequest_Namespace_Pattern.MatchString(m.GetNamespace()) {
		err := DeleteNamespaceRequestValidationError{
			field:  "Namespace",
			reason: "value does not match regex pattern \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteNamespaceRequestMultiError(errors)
	}

	return nil
}

// DeleteNamespaceRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceRequestMultiError) AllErrors() []error { return m }

// DeleteNamespaceRequestValidationError is the validation error returned by
// DeleteNamespaceRequest.Validate if the designated constraints aren't met.
type DeleteNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceRequestValidationError) ErrorName() string {
	return "DeleteNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceRequestValidationError{}

var _DeleteNamespaceRequest_Namespace_Pattern = regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?$")

// Validate checks the field values on DeleteNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNamespaceResponseMultiError, or nil if none found.
func (m *DeleteNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Data

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetPerms()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteNamespaceResponseValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteNamespaceResponseValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerms()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteNamespaceResponseValidationError{
				field:  "Perms",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteNamespaceResponseMultiError(errors)
	}

	return nil
}

// DeleteNamespaceResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceResponseMultiError) AllErrors() []error { return m }

// DeleteNamespaceResponseValidationError is the validation error returned by
// DeleteNamespaceResponse.Validate if the designated constraints aren't met.
type DeleteNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceResponseValidationError) ErrorName() string {
	return "DeleteNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceResponseValidationError{}

// Validate checks the field values on NamespaceData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamespaceData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamespaceDataMultiError, or
// nil if none found.
func (m *NamespaceData) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for CreateTime

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamespaceDataValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamespaceDataValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamespaceDataValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamespaceDataValidationError{
					field:  "Used",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamespaceDataValidationError{
					field:  "Used",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamespaceDataValidationError{
				field:  "Used",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CpuUseRate

	// no validation rules for MemoryUseRate

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NamespaceDataValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NamespaceDataValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NamespaceDataValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NamespaceDataValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NamespaceDataValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NamespaceDataValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVariables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NamespaceDataValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NamespaceDataValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NamespaceDataValidationError{
					field:  fmt.Sprintf("Variables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ItsmTicketSN

	// no validation rules for ItsmTicketStatus

	// no validation rules for ItsmTicketURL

	// no validation rules for ItsmTicketType

	// no validation rules for IsSystem

	if len(errors) > 0 {
		return NamespaceDataMultiError(errors)
	}

	return nil
}

// NamespaceDataMultiError is an error wrapping multiple validation errors
// returned by NamespaceData.ValidateAll() if the designated constraints
// aren't met.
type NamespaceDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceDataMultiError) AllErrors() []error { return m }

// NamespaceDataValidationError is the validation error returned by
// NamespaceData.Validate if the designated constraints aren't met.
type NamespaceDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceDataValidationError) ErrorName() string { return "NamespaceDataValidationError" }

// Error satisfies the builtin error interface
func (e NamespaceDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceDataValidationError{}

// Validate checks the field values on NativeNamespaceData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NativeNamespaceData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NativeNamespaceData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NativeNamespaceDataMultiError, or nil if none found.
func (m *NativeNamespaceData) ValidateAll() error {
	return m.validate(true)
}

func (m *NativeNamespaceData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for CreateTime

	// no validation rules for ProjectID

	// no validation rules for ProjectCode

	if len(errors) > 0 {
		return NativeNamespaceDataMultiError(errors)
	}

	return nil
}

// NativeNamespaceDataMultiError is an error wrapping multiple validation
// errors returned by NativeNamespaceData.ValidateAll() if the designated
// constraints aren't met.
type NativeNamespaceDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NativeNamespaceDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NativeNamespaceDataMultiError) AllErrors() []error { return m }

// NativeNamespaceDataValidationError is the validation error returned by
// NativeNamespaceData.Validate if the designated constraints aren't met.
type NativeNamespaceDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NativeNamespaceDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NativeNamespaceDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NativeNamespaceDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NativeNamespaceDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NativeNamespaceDataValidationError) ErrorName() string {
	return "NativeNamespaceDataValidationError"
}

// Error satisfies the builtin error interface
func (e NativeNamespaceDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNativeNamespaceData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NativeNamespaceDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NativeNamespaceDataValidationError{}

// Validate checks the field values on Label with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Label) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Label with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LabelMultiError, or nil if none found.
func (m *Label) ValidateAll() error {
	return m.validate(true)
}

func (m *Label) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return LabelMultiError(errors)
	}

	return nil
}

// LabelMultiError is an error wrapping multiple validation errors returned by
// Label.ValidateAll() if the designated constraints aren't met.
type LabelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelMultiError) AllErrors() []error { return m }

// LabelValidationError is the validation error returned by Label.Validate if
// the designated constraints aren't met.
type LabelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelValidationError) ErrorName() string { return "LabelValidationError" }

// Error satisfies the builtin error interface
func (e LabelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelValidationError{}

// Validate checks the field values on Annotation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Annotation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Annotation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnnotationMultiError, or
// nil if none found.
func (m *Annotation) ValidateAll() error {
	return m.validate(true)
}

func (m *Annotation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return AnnotationMultiError(errors)
	}

	return nil
}

// AnnotationMultiError is an error wrapping multiple validation errors
// returned by Annotation.ValidateAll() if the designated constraints aren't met.
type AnnotationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationMultiError) AllErrors() []error { return m }

// AnnotationValidationError is the validation error returned by
// Annotation.Validate if the designated constraints aren't met.
type AnnotationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationValidationError) ErrorName() string { return "AnnotationValidationError" }

// Error satisfies the builtin error interface
func (e AnnotationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationValidationError{}

// Validate checks the field values on ResourceQuota with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceQuota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceQuota with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceQuotaMultiError, or
// nil if none found.
func (m *ResourceQuota) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceQuota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CpuRequests

	// no validation rules for MemoryRequests

	// no validation rules for CpuLimits

	// no validation rules for MemoryLimits

	if len(errors) > 0 {
		return ResourceQuotaMultiError(errors)
	}

	return nil
}

// ResourceQuotaMultiError is an error wrapping multiple validation errors
// returned by ResourceQuota.ValidateAll() if the designated constraints
// aren't met.
type ResourceQuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceQuotaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceQuotaMultiError) AllErrors() []error { return m }

// ResourceQuotaValidationError is the validation error returned by
// ResourceQuota.Validate if the designated constraints aren't met.
type ResourceQuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceQuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceQuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceQuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceQuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceQuotaValidationError) ErrorName() string { return "ResourceQuotaValidationError" }

// Error satisfies the builtin error interface
func (e ResourceQuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceQuota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceQuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceQuotaValidationError{}

// Validate checks the field values on CreateVariableRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateVariableRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateVariableRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateVariableRequestMultiError, or nil if none found.
func (m *CreateVariableRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateVariableRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	if utf8.RuneCountInString(m.GetName()) > 32 {
		err := CreateVariableRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetKey()) > 64 {
		err := CreateVariableRequestValidationError{
			field:  "Key",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateVariableRequest_Key_Pattern.MatchString(m.GetKey()) {
		err := CreateVariableRequestValidationError{
			field:  "Key",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateVariableRequest_Scope_InLookup[m.GetScope()]; !ok {
		err := CreateVariableRequestValidationError{
			field:  "Scope",
			reason: "value must be in list [global cluster namespace]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Default

	// no validation rules for Desc

	if len(errors) > 0 {
		return CreateVariableRequestMultiError(errors)
	}

	return nil
}

// CreateVariableRequestMultiError is an error wrapping multiple validation
// errors returned by CreateVariableRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateVariableRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateVariableRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateVariableRequestMultiError) AllErrors() []error { return m }

// CreateVariableRequestValidationError is the validation error returned by
// CreateVariableRequest.Validate if the designated constraints aren't met.
type CreateVariableRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateVariableRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateVariableRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateVariableRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateVariableRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateVariableRequestValidationError) ErrorName() string {
	return "CreateVariableRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateVariableRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateVariableRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateVariableRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateVariableRequestValidationError{}

var _CreateVariableRequest_Key_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]*$")

var _CreateVariableRequest_Scope_InLookup = map[string]struct{}{
	"global":    {},
	"cluster":   {},
	"namespace": {},
}

// Validate checks the field values on CreateVariableResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateVariableResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateVariableResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateVariableResponseMultiError, or nil if none found.
func (m *CreateVariableResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateVariableResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateVariableResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateVariableResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateVariableResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return CreateVariableResponseMultiError(errors)
	}

	return nil
}

// CreateVariableResponseMultiError is an error wrapping multiple validation
// errors returned by CreateVariableResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateVariableResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateVariableResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateVariableResponseMultiError) AllErrors() []error { return m }

// CreateVariableResponseValidationError is the validation error returned by
// CreateVariableResponse.Validate if the designated constraints aren't met.
type CreateVariableResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateVariableResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateVariableResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateVariableResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateVariableResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateVariableResponseValidationError) ErrorName() string {
	return "CreateVariableResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateVariableResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateVariableResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateVariableResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateVariableResponseValidationError{}

// Validate checks the field values on UpdateVariableRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateVariableRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateVariableRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateVariableRequestMultiError, or nil if none found.
func (m *UpdateVariableRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateVariableRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for VariableID

	if utf8.RuneCountInString(m.GetName()) > 32 {
		err := UpdateVariableRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetKey()) > 64 {
		err := UpdateVariableRequestValidationError{
			field:  "Key",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateVariableRequest_Key_Pattern.MatchString(m.GetKey()) {
		err := UpdateVariableRequestValidationError{
			field:  "Key",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateVariableRequest_Scope_InLookup[m.GetScope()]; !ok {
		err := UpdateVariableRequestValidationError{
			field:  "Scope",
			reason: "value must be in list [global cluster namespace]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Default

	// no validation rules for Desc

	if len(errors) > 0 {
		return UpdateVariableRequestMultiError(errors)
	}

	return nil
}

// UpdateVariableRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateVariableRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateVariableRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateVariableRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateVariableRequestMultiError) AllErrors() []error { return m }

// UpdateVariableRequestValidationError is the validation error returned by
// UpdateVariableRequest.Validate if the designated constraints aren't met.
type UpdateVariableRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateVariableRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateVariableRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateVariableRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateVariableRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateVariableRequestValidationError) ErrorName() string {
	return "UpdateVariableRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateVariableRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateVariableRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateVariableRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateVariableRequestValidationError{}

var _UpdateVariableRequest_Key_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]*$")

var _UpdateVariableRequest_Scope_InLookup = map[string]struct{}{
	"global":    {},
	"cluster":   {},
	"namespace": {},
}

// Validate checks the field values on UpdateVariableResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateVariableResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateVariableResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateVariableResponseMultiError, or nil if none found.
func (m *UpdateVariableResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateVariableResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateVariableResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateVariableResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateVariableResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UpdateVariableResponseMultiError(errors)
	}

	return nil
}

// UpdateVariableResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateVariableResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateVariableResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateVariableResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateVariableResponseMultiError) AllErrors() []error { return m }

// UpdateVariableResponseValidationError is the validation error returned by
// UpdateVariableResponse.Validate if the designated constraints aren't met.
type UpdateVariableResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateVariableResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateVariableResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateVariableResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateVariableResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateVariableResponseValidationError) ErrorName() string {
	return "UpdateVariableResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateVariableResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateVariableResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateVariableResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateVariableResponseValidationError{}

// Validate checks the field values on ListVariableDefinitionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListVariableDefinitionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListVariableDefinitionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListVariableDefinitionsRequestMultiError, or nil if none found.
func (m *ListVariableDefinitionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListVariableDefinitionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for Scope

	// no validation rules for SearchKey

	// no validation rules for Offset

	// no validation rules for Limit

	// no validation rules for All

	if len(errors) > 0 {
		return ListVariableDefinitionsRequestMultiError(errors)
	}

	return nil
}

// ListVariableDefinitionsRequestMultiError is an error wrapping multiple
// validation errors returned by ListVariableDefinitionsRequest.ValidateAll()
// if the designated constraints aren't met.
type ListVariableDefinitionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListVariableDefinitionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListVariableDefinitionsRequestMultiError) AllErrors() []error { return m }

// ListVariableDefinitionsRequestValidationError is the validation error
// returned by ListVariableDefinitionsRequest.Validate if the designated
// constraints aren't met.
type ListVariableDefinitionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListVariableDefinitionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListVariableDefinitionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListVariableDefinitionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListVariableDefinitionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListVariableDefinitionsRequestValidationError) ErrorName() string {
	return "ListVariableDefinitionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListVariableDefinitionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListVariableDefinitionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListVariableDefinitionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListVariableDefinitionsRequestValidationError{}

// Validate checks the field values on ListVariableDefinitionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListVariableDefinitionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListVariableDefinitionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListVariableDefinitionsResponseMultiError, or nil if none found.
func (m *ListVariableDefinitionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListVariableDefinitionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListVariableDefinitionsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListVariableDefinitionsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListVariableDefinitionsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListVariableDefinitionsResponseMultiError(errors)
	}

	return nil
}

// ListVariableDefinitionsResponseMultiError is an error wrapping multiple
// validation errors returned by ListVariableDefinitionsResponse.ValidateAll()
// if the designated constraints aren't met.
type ListVariableDefinitionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListVariableDefinitionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListVariableDefinitionsResponseMultiError) AllErrors() []error { return m }

// ListVariableDefinitionsResponseValidationError is the validation error
// returned by ListVariableDefinitionsResponse.Validate if the designated
// constraints aren't met.
type ListVariableDefinitionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListVariableDefinitionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListVariableDefinitionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListVariableDefinitionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListVariableDefinitionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListVariableDefinitionsResponseValidationError) ErrorName() string {
	return "ListVariableDefinitionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListVariableDefinitionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListVariableDefinitionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListVariableDefinitionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListVariableDefinitionsResponseValidationError{}

// Validate checks the field values on DeleteVariableDefinitionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteVariableDefinitionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteVariableDefinitionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteVariableDefinitionsRequestMultiError, or nil if none found.
func (m *DeleteVariableDefinitionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteVariableDefinitionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for IdList

	if len(errors) > 0 {
		return DeleteVariableDefinitionsRequestMultiError(errors)
	}

	return nil
}

// DeleteVariableDefinitionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteVariableDefinitionsRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteVariableDefinitionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteVariableDefinitionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteVariableDefinitionsRequestMultiError) AllErrors() []error { return m }

// DeleteVariableDefinitionsRequestValidationError is the validation error
// returned by DeleteVariableDefinitionsRequest.Validate if the designated
// constraints aren't met.
type DeleteVariableDefinitionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteVariableDefinitionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteVariableDefinitionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteVariableDefinitionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteVariableDefinitionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteVariableDefinitionsRequestValidationError) ErrorName() string {
	return "DeleteVariableDefinitionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteVariableDefinitionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteVariableDefinitionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteVariableDefinitionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteVariableDefinitionsRequestValidationError{}

// Validate checks the field values on DeleteVariableDefinitionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteVariableDefinitionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteVariableDefinitionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteVariableDefinitionsResponseMultiError, or nil if none found.
func (m *DeleteVariableDefinitionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteVariableDefinitionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteVariableDefinitionsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteVariableDefinitionsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteVariableDefinitionsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return DeleteVariableDefinitionsResponseMultiError(errors)
	}

	return nil
}

// DeleteVariableDefinitionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteVariableDefinitionsResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteVariableDefinitionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteVariableDefinitionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteVariableDefinitionsResponseMultiError) AllErrors() []error { return m }

// DeleteVariableDefinitionsResponseValidationError is the validation error
// returned by DeleteVariableDefinitionsResponse.Validate if the designated
// constraints aren't met.
type DeleteVariableDefinitionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteVariableDefinitionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteVariableDefinitionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteVariableDefinitionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteVariableDefinitionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteVariableDefinitionsResponseValidationError) ErrorName() string {
	return "DeleteVariableDefinitionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteVariableDefinitionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteVariableDefinitionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteVariableDefinitionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteVariableDefinitionsResponseValidationError{}

// Validate checks the field values on ListClustersVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClustersVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClustersVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClustersVariablesRequestMultiError, or nil if none found.
func (m *ListClustersVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClustersVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 2 || l > 64 {
		err := ListClustersVariablesRequestValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVariableID()) > 32 {
		err := ListClustersVariablesRequestValidationError{
			field:  "VariableID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListClustersVariablesRequest_VariableID_Pattern.MatchString(m.GetVariableID()) {
		err := ListClustersVariablesRequestValidationError{
			field:  "VariableID",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9-]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListClustersVariablesRequestMultiError(errors)
	}

	return nil
}

// ListClustersVariablesRequestMultiError is an error wrapping multiple
// validation errors returned by ListClustersVariablesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListClustersVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClustersVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClustersVariablesRequestMultiError) AllErrors() []error { return m }

// ListClustersVariablesRequestValidationError is the validation error returned
// by ListClustersVariablesRequest.Validate if the designated constraints
// aren't met.
type ListClustersVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClustersVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClustersVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClustersVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClustersVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClustersVariablesRequestValidationError) ErrorName() string {
	return "ListClustersVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListClustersVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClustersVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClustersVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClustersVariablesRequestValidationError{}

var _ListClustersVariablesRequest_VariableID_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9-]*$")

// Validate checks the field values on ListClustersVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClustersVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClustersVariablesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListClustersVariablesResponseMultiError, or nil if none found.
func (m *ListClustersVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClustersVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListClustersVariablesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListClustersVariablesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListClustersVariablesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListClustersVariablesResponseMultiError(errors)
	}

	return nil
}

// ListClustersVariablesResponseMultiError is an error wrapping multiple
// validation errors returned by ListClustersVariablesResponse.ValidateAll()
// if the designated constraints aren't met.
type ListClustersVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClustersVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClustersVariablesResponseMultiError) AllErrors() []error { return m }

// ListClustersVariablesResponseValidationError is the validation error
// returned by ListClustersVariablesResponse.Validate if the designated
// constraints aren't met.
type ListClustersVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClustersVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClustersVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClustersVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClustersVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClustersVariablesResponseValidationError) ErrorName() string {
	return "ListClustersVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListClustersVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClustersVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClustersVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClustersVariablesResponseValidationError{}

// Validate checks the field values on ListNamespacesVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespacesVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespacesVariablesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNamespacesVariablesRequestMultiError, or nil if none found.
func (m *ListNamespacesVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespacesVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	if utf8.RuneCountInString(m.GetVariableID()) > 32 {
		err := ListNamespacesVariablesRequestValidationError{
			field:  "VariableID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListNamespacesVariablesRequest_VariableID_Pattern.MatchString(m.GetVariableID()) {
		err := ListNamespacesVariablesRequestValidationError{
			field:  "VariableID",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9-]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListNamespacesVariablesRequestMultiError(errors)
	}

	return nil
}

// ListNamespacesVariablesRequestMultiError is an error wrapping multiple
// validation errors returned by ListNamespacesVariablesRequest.ValidateAll()
// if the designated constraints aren't met.
type ListNamespacesVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespacesVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespacesVariablesRequestMultiError) AllErrors() []error { return m }

// ListNamespacesVariablesRequestValidationError is the validation error
// returned by ListNamespacesVariablesRequest.Validate if the designated
// constraints aren't met.
type ListNamespacesVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespacesVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespacesVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespacesVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespacesVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespacesVariablesRequestValidationError) ErrorName() string {
	return "ListNamespacesVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespacesVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespacesVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespacesVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespacesVariablesRequestValidationError{}

var _ListNamespacesVariablesRequest_VariableID_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9-]*$")

// Validate checks the field values on ListNamespacesVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespacesVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespacesVariablesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNamespacesVariablesResponseMultiError, or nil if none found.
func (m *ListNamespacesVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespacesVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNamespacesVariablesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNamespacesVariablesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNamespacesVariablesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListNamespacesVariablesResponseMultiError(errors)
	}

	return nil
}

// ListNamespacesVariablesResponseMultiError is an error wrapping multiple
// validation errors returned by ListNamespacesVariablesResponse.ValidateAll()
// if the designated constraints aren't met.
type ListNamespacesVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespacesVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespacesVariablesResponseMultiError) AllErrors() []error { return m }

// ListNamespacesVariablesResponseValidationError is the validation error
// returned by ListNamespacesVariablesResponse.Validate if the designated
// constraints aren't met.
type ListNamespacesVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespacesVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespacesVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespacesVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespacesVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespacesVariablesResponseValidationError) ErrorName() string {
	return "ListNamespacesVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespacesVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespacesVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespacesVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespacesVariablesResponseValidationError{}

// Validate checks the field values on UpdateClustersVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClustersVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClustersVariablesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateClustersVariablesRequestMultiError, or nil if none found.
func (m *UpdateClustersVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClustersVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	if utf8.RuneCountInString(m.GetVariableID()) > 32 {
		err := UpdateClustersVariablesRequestValidationError{
			field:  "VariableID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateClustersVariablesRequest_VariableID_Pattern.MatchString(m.GetVariableID()) {
		err := UpdateClustersVariablesRequestValidationError{
			field:  "VariableID",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9-]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateClustersVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateClustersVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateClustersVariablesRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateClustersVariablesRequestMultiError(errors)
	}

	return nil
}

// UpdateClustersVariablesRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateClustersVariablesRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateClustersVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClustersVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClustersVariablesRequestMultiError) AllErrors() []error { return m }

// UpdateClustersVariablesRequestValidationError is the validation error
// returned by UpdateClustersVariablesRequest.Validate if the designated
// constraints aren't met.
type UpdateClustersVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClustersVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClustersVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClustersVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClustersVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClustersVariablesRequestValidationError) ErrorName() string {
	return "UpdateClustersVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClustersVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClustersVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClustersVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClustersVariablesRequestValidationError{}

var _UpdateClustersVariablesRequest_VariableID_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9-]*$")

// Validate checks the field values on UpdateClustersVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClustersVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClustersVariablesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateClustersVariablesResponseMultiError, or nil if none found.
func (m *UpdateClustersVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClustersVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UpdateClustersVariablesResponseMultiError(errors)
	}

	return nil
}

// UpdateClustersVariablesResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateClustersVariablesResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateClustersVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClustersVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClustersVariablesResponseMultiError) AllErrors() []error { return m }

// UpdateClustersVariablesResponseValidationError is the validation error
// returned by UpdateClustersVariablesResponse.Validate if the designated
// constraints aren't met.
type UpdateClustersVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClustersVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClustersVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClustersVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClustersVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClustersVariablesResponseValidationError) ErrorName() string {
	return "UpdateClustersVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClustersVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClustersVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClustersVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClustersVariablesResponseValidationError{}

// Validate checks the field values on UpdateNamespacesVariablesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateNamespacesVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespacesVariablesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateNamespacesVariablesRequestMultiError, or nil if none found.
func (m *UpdateNamespacesVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespacesVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	if utf8.RuneCountInString(m.GetVariableID()) > 32 {
		err := UpdateNamespacesVariablesRequestValidationError{
			field:  "VariableID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateNamespacesVariablesRequest_VariableID_Pattern.MatchString(m.GetVariableID()) {
		err := UpdateNamespacesVariablesRequestValidationError{
			field:  "VariableID",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9-]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNamespacesVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNamespacesVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNamespacesVariablesRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateNamespacesVariablesRequestMultiError(errors)
	}

	return nil
}

// UpdateNamespacesVariablesRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateNamespacesVariablesRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespacesVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespacesVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespacesVariablesRequestMultiError) AllErrors() []error { return m }

// UpdateNamespacesVariablesRequestValidationError is the validation error
// returned by UpdateNamespacesVariablesRequest.Validate if the designated
// constraints aren't met.
type UpdateNamespacesVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespacesVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespacesVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespacesVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespacesVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespacesVariablesRequestValidationError) ErrorName() string {
	return "UpdateNamespacesVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespacesVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespacesVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespacesVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespacesVariablesRequestValidationError{}

var _UpdateNamespacesVariablesRequest_VariableID_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9-]*$")

// Validate checks the field values on UpdateNamespacesVariablesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateNamespacesVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespacesVariablesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateNamespacesVariablesResponseMultiError, or nil if none found.
func (m *UpdateNamespacesVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespacesVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UpdateNamespacesVariablesResponseMultiError(errors)
	}

	return nil
}

// UpdateNamespacesVariablesResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateNamespacesVariablesResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespacesVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespacesVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespacesVariablesResponseMultiError) AllErrors() []error { return m }

// UpdateNamespacesVariablesResponseValidationError is the validation error
// returned by UpdateNamespacesVariablesResponse.Validate if the designated
// constraints aren't met.
type UpdateNamespacesVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespacesVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespacesVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespacesVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespacesVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespacesVariablesResponseValidationError) ErrorName() string {
	return "UpdateNamespacesVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespacesVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespacesVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespacesVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespacesVariablesResponseValidationError{}

// Validate checks the field values on ListClusterVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterVariablesRequestMultiError, or nil if none found.
func (m *ListClusterVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProjectCode()); l < 2 || l > 64 {
		err := ListClusterVariablesRequestValidationError{
			field:  "ProjectCode",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterID

	if len(errors) > 0 {
		return ListClusterVariablesRequestMultiError(errors)
	}

	return nil
}

// ListClusterVariablesRequestMultiError is an error wrapping multiple
// validation errors returned by ListClusterVariablesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListClusterVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterVariablesRequestMultiError) AllErrors() []error { return m }

// ListClusterVariablesRequestValidationError is the validation error returned
// by ListClusterVariablesRequest.Validate if the designated constraints
// aren't met.
type ListClusterVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterVariablesRequestValidationError) ErrorName() string {
	return "ListClusterVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterVariablesRequestValidationError{}

// Validate checks the field values on ListClusterVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterVariablesResponseMultiError, or nil if none found.
func (m *ListClusterVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListClusterVariablesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListClusterVariablesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListClusterVariablesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListClusterVariablesResponseMultiError(errors)
	}

	return nil
}

// ListClusterVariablesResponseMultiError is an error wrapping multiple
// validation errors returned by ListClusterVariablesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListClusterVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterVariablesResponseMultiError) AllErrors() []error { return m }

// ListClusterVariablesResponseValidationError is the validation error returned
// by ListClusterVariablesResponse.Validate if the designated constraints
// aren't met.
type ListClusterVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterVariablesResponseValidationError) ErrorName() string {
	return "ListClusterVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterVariablesResponseValidationError{}

// Validate checks the field values on ListNamespaceVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceVariablesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNamespaceVariablesRequestMultiError, or nil if none found.
func (m *ListNamespaceVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	// no validation rules for Namespace

	if len(errors) > 0 {
		return ListNamespaceVariablesRequestMultiError(errors)
	}

	return nil
}

// ListNamespaceVariablesRequestMultiError is an error wrapping multiple
// validation errors returned by ListNamespaceVariablesRequest.ValidateAll()
// if the designated constraints aren't met.
type ListNamespaceVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceVariablesRequestMultiError) AllErrors() []error { return m }

// ListNamespaceVariablesRequestValidationError is the validation error
// returned by ListNamespaceVariablesRequest.Validate if the designated
// constraints aren't met.
type ListNamespaceVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceVariablesRequestValidationError) ErrorName() string {
	return "ListNamespaceVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceVariablesRequestValidationError{}

// Validate checks the field values on ListNamespaceVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceVariablesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNamespaceVariablesResponseMultiError, or nil if none found.
func (m *ListNamespaceVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNamespaceVariablesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNamespaceVariablesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNamespaceVariablesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ListNamespaceVariablesResponseMultiError(errors)
	}

	return nil
}

// ListNamespaceVariablesResponseMultiError is an error wrapping multiple
// validation errors returned by ListNamespaceVariablesResponse.ValidateAll()
// if the designated constraints aren't met.
type ListNamespaceVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceVariablesResponseMultiError) AllErrors() []error { return m }

// ListNamespaceVariablesResponseValidationError is the validation error
// returned by ListNamespaceVariablesResponse.Validate if the designated
// constraints aren't met.
type ListNamespaceVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceVariablesResponseValidationError) ErrorName() string {
	return "ListNamespaceVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceVariablesResponseValidationError{}

// Validate checks the field values on UpdateClusterVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterVariablesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateClusterVariablesRequestMultiError, or nil if none found.
func (m *UpdateClusterVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	if utf8.RuneCountInString(m.GetClusterID()) > 32 {
		err := UpdateClusterVariablesRequestValidationError{
			field:  "ClusterID",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateClusterVariablesRequest_ClusterID_Pattern.MatchString(m.GetClusterID()) {
		err := UpdateClusterVariablesRequestValidationError{
			field:  "ClusterID",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9-]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateClusterVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateClusterVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateClusterVariablesRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateClusterVariablesRequestMultiError(errors)
	}

	return nil
}

// UpdateClusterVariablesRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateClusterVariablesRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateClusterVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterVariablesRequestMultiError) AllErrors() []error { return m }

// UpdateClusterVariablesRequestValidationError is the validation error
// returned by UpdateClusterVariablesRequest.Validate if the designated
// constraints aren't met.
type UpdateClusterVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterVariablesRequestValidationError) ErrorName() string {
	return "UpdateClusterVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterVariablesRequestValidationError{}

var _UpdateClusterVariablesRequest_ClusterID_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9-]*$")

// Validate checks the field values on UpdateClusterVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterVariablesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateClusterVariablesResponseMultiError, or nil if none found.
func (m *UpdateClusterVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UpdateClusterVariablesResponseMultiError(errors)
	}

	return nil
}

// UpdateClusterVariablesResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateClusterVariablesResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateClusterVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterVariablesResponseMultiError) AllErrors() []error { return m }

// UpdateClusterVariablesResponseValidationError is the validation error
// returned by UpdateClusterVariablesResponse.Validate if the designated
// constraints aren't met.
type UpdateClusterVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterVariablesResponseValidationError) ErrorName() string {
	return "UpdateClusterVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterVariablesResponseValidationError{}

// Validate checks the field values on UpdateNamespaceVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNamespaceVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceVariablesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateNamespaceVariablesRequestMultiError, or nil if none found.
func (m *UpdateNamespaceVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	// no validation rules for Namespace

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNamespaceVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNamespaceVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNamespaceVariablesRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateNamespaceVariablesRequestMultiError(errors)
	}

	return nil
}

// UpdateNamespaceVariablesRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateNamespaceVariablesRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateNamespaceVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceVariablesRequestMultiError) AllErrors() []error { return m }

// UpdateNamespaceVariablesRequestValidationError is the validation error
// returned by UpdateNamespaceVariablesRequest.Validate if the designated
// constraints aren't met.
type UpdateNamespaceVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceVariablesRequestValidationError) ErrorName() string {
	return "UpdateNamespaceVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceVariablesRequestValidationError{}

// Validate checks the field values on UpdateNamespaceVariablesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateNamespaceVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceVariablesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateNamespaceVariablesResponseMultiError, or nil if none found.
func (m *UpdateNamespaceVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for RequestID

	if len(errors) > 0 {
		return UpdateNamespaceVariablesResponseMultiError(errors)
	}

	return nil
}

// UpdateNamespaceVariablesResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateNamespaceVariablesResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespaceVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceVariablesResponseMultiError) AllErrors() []error { return m }

// UpdateNamespaceVariablesResponseValidationError is the validation error
// returned by UpdateNamespaceVariablesResponse.Validate if the designated
// constraints aren't met.
type UpdateNamespaceVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceVariablesResponseValidationError) ErrorName() string {
	return "UpdateNamespaceVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceVariablesResponseValidationError{}

// Validate checks the field values on ImportVariablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportVariablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportVariablesRequestMultiError, or nil if none found.
func (m *ImportVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportVariablesRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportVariablesRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportVariablesRequestMultiError(errors)
	}

	return nil
}

// ImportVariablesRequestMultiError is an error wrapping multiple validation
// errors returned by ImportVariablesRequest.ValidateAll() if the designated
// constraints aren't met.
type ImportVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportVariablesRequestMultiError) AllErrors() []error { return m }

// ImportVariablesRequestValidationError is the validation error returned by
// ImportVariablesRequest.Validate if the designated constraints aren't met.
type ImportVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportVariablesRequestValidationError) ErrorName() string {
	return "ImportVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportVariablesRequestValidationError{}

// Validate checks the field values on ImportVariablesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportVariablesResponseMultiError, or nil if none found.
func (m *ImportVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for RequestID

	if len(errors) > 0 {
		return ImportVariablesResponseMultiError(errors)
	}

	return nil
}

// ImportVariablesResponseMultiError is an error wrapping multiple validation
// errors returned by ImportVariablesResponse.ValidateAll() if the designated
// constraints aren't met.
type ImportVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportVariablesResponseMultiError) AllErrors() []error { return m }

// ImportVariablesResponseValidationError is the validation error returned by
// ImportVariablesResponse.Validate if the designated constraints aren't met.
type ImportVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportVariablesResponseValidationError) ErrorName() string {
	return "ImportVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportVariablesResponseValidationError{}

// Validate checks the field values on RenderVariablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenderVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenderVariablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenderVariablesRequestMultiError, or nil if none found.
func (m *RenderVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RenderVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ClusterID

	// no validation rules for Namespace

	// no validation rules for KeyList

	if len(errors) > 0 {
		return RenderVariablesRequestMultiError(errors)
	}

	return nil
}

// RenderVariablesRequestMultiError is an error wrapping multiple validation
// errors returned by RenderVariablesRequest.ValidateAll() if the designated
// constraints aren't met.
type RenderVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenderVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenderVariablesRequestMultiError) AllErrors() []error { return m }

// RenderVariablesRequestValidationError is the validation error returned by
// RenderVariablesRequest.Validate if the designated constraints aren't met.
type RenderVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenderVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenderVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenderVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenderVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenderVariablesRequestValidationError) ErrorName() string {
	return "RenderVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RenderVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenderVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenderVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenderVariablesRequestValidationError{}

// Validate checks the field values on RenderVariablesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenderVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenderVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenderVariablesResponseMultiError, or nil if none found.
func (m *RenderVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RenderVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RenderVariablesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RenderVariablesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RenderVariablesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return RenderVariablesResponseMultiError(errors)
	}

	return nil
}

// RenderVariablesResponseMultiError is an error wrapping multiple validation
// errors returned by RenderVariablesResponse.ValidateAll() if the designated
// constraints aren't met.
type RenderVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenderVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenderVariablesResponseMultiError) AllErrors() []error { return m }

// RenderVariablesResponseValidationError is the validation error returned by
// RenderVariablesResponse.Validate if the designated constraints aren't met.
type RenderVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenderVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenderVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenderVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenderVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenderVariablesResponseValidationError) ErrorName() string {
	return "RenderVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RenderVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenderVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenderVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenderVariablesResponseValidationError{}

// Validate checks the field values on VariableDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VariableDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VariableDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VariableDefinitionMultiError, or nil if none found.
func (m *VariableDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *VariableDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Key

	// no validation rules for Name

	// no validation rules for Default

	// no validation rules for DefaultValue

	// no validation rules for Scope

	// no validation rules for ScopeName

	// no validation rules for Category

	// no validation rules for CategoryName

	// no validation rules for Desc

	// no validation rules for Created

	// no validation rules for Updated

	// no validation rules for Creator

	// no validation rules for Updater

	if len(errors) > 0 {
		return VariableDefinitionMultiError(errors)
	}

	return nil
}

// VariableDefinitionMultiError is an error wrapping multiple validation errors
// returned by VariableDefinition.ValidateAll() if the designated constraints
// aren't met.
type VariableDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VariableDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VariableDefinitionMultiError) AllErrors() []error { return m }

// VariableDefinitionValidationError is the validation error returned by
// VariableDefinition.Validate if the designated constraints aren't met.
type VariableDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VariableDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VariableDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VariableDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VariableDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VariableDefinitionValidationError) ErrorName() string {
	return "VariableDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e VariableDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVariableDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VariableDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VariableDefinitionValidationError{}

// Validate checks the field values on VariableValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VariableValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VariableValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VariableValueMultiError, or
// nil if none found.
func (m *VariableValue) ValidateAll() error {
	return m.validate(true)
}

func (m *VariableValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Key

	// no validation rules for Name

	// no validation rules for ClusterID

	// no validation rules for ClusterName

	// no validation rules for Namespace

	// no validation rules for Value

	// no validation rules for Scope

	if len(errors) > 0 {
		return VariableValueMultiError(errors)
	}

	return nil
}

// VariableValueMultiError is an error wrapping multiple validation errors
// returned by VariableValue.ValidateAll() if the designated constraints
// aren't met.
type VariableValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VariableValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VariableValueMultiError) AllErrors() []error { return m }

// VariableValueValidationError is the validation error returned by
// VariableValue.Validate if the designated constraints aren't met.
type VariableValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VariableValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VariableValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VariableValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VariableValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VariableValueValidationError) ErrorName() string { return "VariableValueValidationError" }

// Error satisfies the builtin error interface
func (e VariableValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVariableValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VariableValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VariableValueValidationError{}

// Validate checks the field values on CreateVariableData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateVariableData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateVariableData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateVariableDataMultiError, or nil if none found.
func (m *CreateVariableData) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateVariableData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ProjectCode

	// no validation rules for Name

	// no validation rules for Key

	// no validation rules for Scope

	// no validation rules for Default

	// no validation rules for Desc

	// no validation rules for Category

	if len(errors) > 0 {
		return CreateVariableDataMultiError(errors)
	}

	return nil
}

// CreateVariableDataMultiError is an error wrapping multiple validation errors
// returned by CreateVariableData.ValidateAll() if the designated constraints
// aren't met.
type CreateVariableDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateVariableDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateVariableDataMultiError) AllErrors() []error { return m }

// CreateVariableDataValidationError is the validation error returned by
// CreateVariableData.Validate if the designated constraints aren't met.
type CreateVariableDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateVariableDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateVariableDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateVariableDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateVariableDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateVariableDataValidationError) ErrorName() string {
	return "CreateVariableDataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateVariableDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateVariableData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateVariableDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateVariableDataValidationError{}

// Validate checks the field values on UpdateVariableData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateVariableData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateVariableData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateVariableDataMultiError, or nil if none found.
func (m *UpdateVariableData) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateVariableData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ProjectCode

	// no validation rules for Name

	// no validation rules for Key

	// no validation rules for Scope

	// no validation rules for Default

	// no validation rules for Desc

	// no validation rules for Category

	if len(errors) > 0 {
		return UpdateVariableDataMultiError(errors)
	}

	return nil
}

// UpdateVariableDataMultiError is an error wrapping multiple validation errors
// returned by UpdateVariableData.ValidateAll() if the designated constraints
// aren't met.
type UpdateVariableDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateVariableDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateVariableDataMultiError) AllErrors() []error { return m }

// UpdateVariableDataValidationError is the validation error returned by
// UpdateVariableData.Validate if the designated constraints aren't met.
type UpdateVariableDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateVariableDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateVariableDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateVariableDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateVariableDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateVariableDataValidationError) ErrorName() string {
	return "UpdateVariableDataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateVariableDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateVariableData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateVariableDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateVariableDataValidationError{}

// Validate checks the field values on ListVariableDefinitionData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListVariableDefinitionData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListVariableDefinitionData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListVariableDefinitionDataMultiError, or nil if none found.
func (m *ListVariableDefinitionData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListVariableDefinitionData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListVariableDefinitionDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListVariableDefinitionDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListVariableDefinitionDataValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListVariableDefinitionDataMultiError(errors)
	}

	return nil
}

// ListVariableDefinitionDataMultiError is an error wrapping multiple
// validation errors returned by ListVariableDefinitionData.ValidateAll() if
// the designated constraints aren't met.
type ListVariableDefinitionDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListVariableDefinitionDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListVariableDefinitionDataMultiError) AllErrors() []error { return m }

// ListVariableDefinitionDataValidationError is the validation error returned
// by ListVariableDefinitionData.Validate if the designated constraints aren't met.
type ListVariableDefinitionDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListVariableDefinitionDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListVariableDefinitionDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListVariableDefinitionDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListVariableDefinitionDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListVariableDefinitionDataValidationError) ErrorName() string {
	return "ListVariableDefinitionDataValidationError"
}

// Error satisfies the builtin error interface
func (e ListVariableDefinitionDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListVariableDefinitionData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListVariableDefinitionDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListVariableDefinitionDataValidationError{}

// Validate checks the field values on DeleteVariableDefinitionsData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteVariableDefinitionsData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteVariableDefinitionsData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteVariableDefinitionsDataMultiError, or nil if none found.
func (m *DeleteVariableDefinitionsData) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteVariableDefinitionsData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	if len(errors) > 0 {
		return DeleteVariableDefinitionsDataMultiError(errors)
	}

	return nil
}

// DeleteVariableDefinitionsDataMultiError is an error wrapping multiple
// validation errors returned by DeleteVariableDefinitionsData.ValidateAll()
// if the designated constraints aren't met.
type DeleteVariableDefinitionsDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteVariableDefinitionsDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteVariableDefinitionsDataMultiError) AllErrors() []error { return m }

// DeleteVariableDefinitionsDataValidationError is the validation error
// returned by DeleteVariableDefinitionsData.Validate if the designated
// constraints aren't met.
type DeleteVariableDefinitionsDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteVariableDefinitionsDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteVariableDefinitionsDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteVariableDefinitionsDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteVariableDefinitionsDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteVariableDefinitionsDataValidationError) ErrorName() string {
	return "DeleteVariableDefinitionsDataValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteVariableDefinitionsDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteVariableDefinitionsData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteVariableDefinitionsDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteVariableDefinitionsDataValidationError{}

// Validate checks the field values on ListVariableValuesData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListVariableValuesData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListVariableValuesData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListVariableValuesDataMultiError, or nil if none found.
func (m *ListVariableValuesData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListVariableValuesData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListVariableValuesDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListVariableValuesDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListVariableValuesDataValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListVariableValuesDataMultiError(errors)
	}

	return nil
}

// ListVariableValuesDataMultiError is an error wrapping multiple validation
// errors returned by ListVariableValuesData.ValidateAll() if the designated
// constraints aren't met.
type ListVariableValuesDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListVariableValuesDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListVariableValuesDataMultiError) AllErrors() []error { return m }

// ListVariableValuesDataValidationError is the validation error returned by
// ListVariableValuesData.Validate if the designated constraints aren't met.
type ListVariableValuesDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListVariableValuesDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListVariableValuesDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListVariableValuesDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListVariableValuesDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListVariableValuesDataValidationError) ErrorName() string {
	return "ListVariableValuesDataValidationError"
}

// Error satisfies the builtin error interface
func (e ListVariableValuesDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListVariableValuesData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListVariableValuesDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListVariableValuesDataValidationError{}

// Validate checks the field values on ImportVariableData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportVariableData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportVariableData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportVariableDataMultiError, or nil if none found.
func (m *ImportVariableData) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportVariableData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) > 32 {
		err := ImportVariableDataValidationError{
			field:  "Name",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetKey()) > 64 {
		err := ImportVariableDataValidationError{
			field:  "Key",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ImportVariableData_Key_Pattern.MatchString(m.GetKey()) {
		err := ImportVariableDataValidationError{
			field:  "Key",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Scope

	// no validation rules for Value

	// no validation rules for Desc

	for idx, item := range m.GetVars() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportVariableDataValidationError{
						field:  fmt.Sprintf("Vars[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportVariableDataValidationError{
						field:  fmt.Sprintf("Vars[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportVariableDataValidationError{
					field:  fmt.Sprintf("Vars[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportVariableDataMultiError(errors)
	}

	return nil
}

// ImportVariableDataMultiError is an error wrapping multiple validation errors
// returned by ImportVariableData.ValidateAll() if the designated constraints
// aren't met.
type ImportVariableDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportVariableDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportVariableDataMultiError) AllErrors() []error { return m }

// ImportVariableDataValidationError is the validation error returned by
// ImportVariableData.Validate if the designated constraints aren't met.
type ImportVariableDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportVariableDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportVariableDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportVariableDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportVariableDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportVariableDataValidationError) ErrorName() string {
	return "ImportVariableDataValidationError"
}

// Error satisfies the builtin error interface
func (e ImportVariableDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportVariableData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportVariableDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportVariableDataValidationError{}

var _ImportVariableData_Key_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]*$")

// Validate checks the field values on ImportVariableVarData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportVariableVarData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportVariableVarData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportVariableVarDataMultiError, or nil if none found.
func (m *ImportVariableVarData) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportVariableVarData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterID

	// no validation rules for Namespace

	// no validation rules for Value

	if len(errors) > 0 {
		return ImportVariableVarDataMultiError(errors)
	}

	return nil
}

// ImportVariableVarDataMultiError is an error wrapping multiple validation
// errors returned by ImportVariableVarData.ValidateAll() if the designated
// constraints aren't met.
type ImportVariableVarDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportVariableVarDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportVariableVarDataMultiError) AllErrors() []error { return m }

// ImportVariableVarDataValidationError is the validation error returned by
// ImportVariableVarData.Validate if the designated constraints aren't met.
type ImportVariableVarDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportVariableVarDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportVariableVarDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportVariableVarDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportVariableVarDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportVariableVarDataValidationError) ErrorName() string {
	return "ImportVariableVarDataValidationError"
}

// Error satisfies the builtin error interface
func (e ImportVariableVarDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportVariableVarData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportVariableVarDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportVariableVarDataValidationError{}

// Validate checks the field values on HealthzRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthzRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthzRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthzRequestMultiError,
// or nil if none found.
func (m *HealthzRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthzRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HealthzRequestMultiError(errors)
	}

	return nil
}

// HealthzRequestMultiError is an error wrapping multiple validation errors
// returned by HealthzRequest.ValidateAll() if the designated constraints
// aren't met.
type HealthzRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthzRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthzRequestMultiError) AllErrors() []error { return m }

// HealthzRequestValidationError is the validation error returned by
// HealthzRequest.Validate if the designated constraints aren't met.
type HealthzRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthzRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthzRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthzRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthzRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthzRequestValidationError) ErrorName() string { return "HealthzRequestValidationError" }

// Error satisfies the builtin error interface
func (e HealthzRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthzRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthzRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthzRequestValidationError{}

// Validate checks the field values on HealthzResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HealthzResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthzResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthzResponseMultiError, or nil if none found.
func (m *HealthzResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthzResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthzResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthzResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthzResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if len(errors) > 0 {
		return HealthzResponseMultiError(errors)
	}

	return nil
}

// HealthzResponseMultiError is an error wrapping multiple validation errors
// returned by HealthzResponse.ValidateAll() if the designated constraints
// aren't met.
type HealthzResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthzResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthzResponseMultiError) AllErrors() []error { return m }

// HealthzResponseValidationError is the validation error returned by
// HealthzResponse.Validate if the designated constraints aren't met.
type HealthzResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthzResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthzResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthzResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthzResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthzResponseValidationError) ErrorName() string { return "HealthzResponseValidationError" }

// Error satisfies the builtin error interface
func (e HealthzResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthzResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthzResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthzResponseValidationError{}

// Validate checks the field values on HealthzData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthzData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthzData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthzDataMultiError, or
// nil if none found.
func (m *HealthzData) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthzData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for MongoStatus

	if len(errors) > 0 {
		return HealthzDataMultiError(errors)
	}

	return nil
}

// HealthzDataMultiError is an error wrapping multiple validation errors
// returned by HealthzData.ValidateAll() if the designated constraints aren't met.
type HealthzDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthzDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthzDataMultiError) AllErrors() []error { return m }

// HealthzDataValidationError is the validation error returned by
// HealthzData.Validate if the designated constraints aren't met.
type HealthzDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthzDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthzDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthzDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthzDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthzDataValidationError) ErrorName() string { return "HealthzDataValidationError" }

// Error satisfies the builtin error interface
func (e HealthzDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthzData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthzDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthzDataValidationError{}

// Validate checks the field values on PingRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PingRequestMultiError, or
// nil if none found.
func (m *PingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PingRequestMultiError(errors)
	}

	return nil
}

// PingRequestMultiError is an error wrapping multiple validation errors
// returned by PingRequest.ValidateAll() if the designated constraints aren't met.
type PingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingRequestMultiError) AllErrors() []error { return m }

// PingRequestValidationError is the validation error returned by
// PingRequest.Validate if the designated constraints aren't met.
type PingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingRequestValidationError) ErrorName() string { return "PingRequestValidationError" }

// Error satisfies the builtin error interface
func (e PingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingRequestValidationError{}

// Validate checks the field values on PingResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PingResponseMultiError, or
// nil if none found.
func (m *PingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Data

	// no validation rules for RequestID

	if len(errors) > 0 {
		return PingResponseMultiError(errors)
	}

	return nil
}

// PingResponseMultiError is an error wrapping multiple validation errors
// returned by PingResponse.ValidateAll() if the designated constraints aren't met.
type PingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingResponseMultiError) AllErrors() []error { return m }

// PingResponseValidationError is the validation error returned by
// PingResponse.Validate if the designated constraints aren't met.
type PingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingResponseValidationError) ErrorName() string { return "PingResponseValidationError" }

// Error satisfies the builtin error interface
func (e PingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingResponseValidationError{}

// Validate checks the field values on ProjectQuota with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProjectQuota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectQuota with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProjectQuotaMultiError, or
// nil if none found.
func (m *ProjectQuota) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectQuota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuotaId

	// no validation rules for QuotaName

	// no validation rules for ProjectID

	// no validation rules for ProjectCode

	// no validation rules for ClusterId

	// no validation rules for ClusterName

	// no validation rules for NameSpace

	// no validation rules for BusinessID

	// no validation rules for BusinessName

	// no validation rules for Description

	// no validation rules for IsDeleted

	// no validation rules for QuotaType

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectQuotaValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectQuotaValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectQuotaValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Message

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for Creator

	// no validation rules for Updater

	// no validation rules for Provider

	for idx, item := range m.GetNodeGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProjectQuotaValidationError{
						field:  fmt.Sprintf("NodeGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProjectQuotaValidationError{
						field:  fmt.Sprintf("NodeGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProjectQuotaValidationError{
					field:  fmt.Sprintf("NodeGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return ProjectQuotaMultiError(errors)
	}

	return nil
}

// ProjectQuotaMultiError is an error wrapping multiple validation errors
// returned by ProjectQuota.ValidateAll() if the designated constraints aren't met.
type ProjectQuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectQuotaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectQuotaMultiError) AllErrors() []error { return m }

// ProjectQuotaValidationError is the validation error returned by
// ProjectQuota.Validate if the designated constraints aren't met.
type ProjectQuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectQuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectQuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectQuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectQuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectQuotaValidationError) ErrorName() string { return "ProjectQuotaValidationError" }

// Error satisfies the builtin error interface
func (e ProjectQuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectQuota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectQuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectQuotaValidationError{}

// Validate checks the field values on NodeGroup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupMultiError, or nil
// if none found.
func (m *NodeGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for NodeGroupId

	// no validation rules for QuotaNum

	// no validation rules for QuotaUsed

	if len(errors) > 0 {
		return NodeGroupMultiError(errors)
	}

	return nil
}

// NodeGroupMultiError is an error wrapping multiple validation errors returned
// by NodeGroup.ValidateAll() if the designated constraints aren't met.
type NodeGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupMultiError) AllErrors() []error { return m }

// NodeGroupValidationError is the validation error returned by
// NodeGroup.Validate if the designated constraints aren't met.
type NodeGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupValidationError) ErrorName() string { return "NodeGroupValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupValidationError{}

// Validate checks the field values on QuotaResource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuotaResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuotaResource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuotaResourceMultiError, or
// nil if none found.
func (m *QuotaResource) ValidateAll() error {
	return m.validate(true)
}

func (m *QuotaResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetZoneResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaResourceValidationError{
					field:  "ZoneResources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaResourceValidationError{
					field:  "ZoneResources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetZoneResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaResourceValidationError{
				field:  "ZoneResources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCpu()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaResourceValidationError{
					field:  "Cpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaResourceValidationError{
					field:  "Cpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCpu()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaResourceValidationError{
				field:  "Cpu",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaResourceValidationError{
					field:  "Mem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaResourceValidationError{
					field:  "Mem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaResourceValidationError{
				field:  "Mem",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGpu()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaResourceValidationError{
					field:  "Gpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaResourceValidationError{
					field:  "Gpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGpu()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaResourceValidationError{
				field:  "Gpu",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QuotaResourceMultiError(errors)
	}

	return nil
}

// QuotaResourceMultiError is an error wrapping multiple validation errors
// returned by QuotaResource.ValidateAll() if the designated constraints
// aren't met.
type QuotaResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuotaResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuotaResourceMultiError) AllErrors() []error { return m }

// QuotaResourceValidationError is the validation error returned by
// QuotaResource.Validate if the designated constraints aren't met.
type QuotaResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuotaResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuotaResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuotaResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuotaResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuotaResourceValidationError) ErrorName() string { return "QuotaResourceValidationError" }

// Error satisfies the builtin error interface
func (e QuotaResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuotaResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuotaResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuotaResourceValidationError{}

// Validate checks the field values on QuotaStrategy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuotaStrategy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuotaStrategy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuotaStrategyMultiError, or
// nil if none found.
func (m *QuotaStrategy) ValidateAll() error {
	return m.validate(true)
}

func (m *QuotaStrategy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExpectTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaStrategyValidationError{
					field:  "ExpectTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaStrategyValidationError{
					field:  "ExpectTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpectTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaStrategyValidationError{
				field:  "ExpectTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsUrgencyResource

	if len(errors) > 0 {
		return QuotaStrategyMultiError(errors)
	}

	return nil
}

// QuotaStrategyMultiError is an error wrapping multiple validation errors
// returned by QuotaStrategy.ValidateAll() if the designated constraints
// aren't met.
type QuotaStrategyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuotaStrategyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuotaStrategyMultiError) AllErrors() []error { return m }

// QuotaStrategyValidationError is the validation error returned by
// QuotaStrategy.Validate if the designated constraints aren't met.
type QuotaStrategyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuotaStrategyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuotaStrategyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuotaStrategyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuotaStrategyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuotaStrategyValidationError) ErrorName() string { return "QuotaStrategyValidationError" }

// Error satisfies the builtin error interface
func (e QuotaStrategyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuotaStrategy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuotaStrategyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuotaStrategyValidationError{}

// Validate checks the field values on InstanceTypeConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceTypeConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceTypeConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceTypeConfigMultiError, or nil if none found.
func (m *InstanceTypeConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceTypeConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for InstanceType

	// no validation rules for Cpu

	// no validation rules for Mem

	// no validation rules for Gpu

	// no validation rules for ZoneId

	// no validation rules for ZoneName

	// no validation rules for QuotaNum

	// no validation rules for QuotaUsed

	if all {
		switch v := interface{}(m.GetSystemDisk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceTypeConfigValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceTypeConfigValidationError{
					field:  "SystemDisk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSystemDisk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceTypeConfigValidationError{
				field:  "SystemDisk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDataDisks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTypeConfigValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTypeConfigValidationError{
						field:  fmt.Sprintf("DataDisks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTypeConfigValidationError{
					field:  fmt.Sprintf("DataDisks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InstanceTypeConfigMultiError(errors)
	}

	return nil
}

// InstanceTypeConfigMultiError is an error wrapping multiple validation errors
// returned by InstanceTypeConfig.ValidateAll() if the designated constraints
// aren't met.
type InstanceTypeConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTypeConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTypeConfigMultiError) AllErrors() []error { return m }

// InstanceTypeConfigValidationError is the validation error returned by
// InstanceTypeConfig.Validate if the designated constraints aren't met.
type InstanceTypeConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTypeConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTypeConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTypeConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTypeConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTypeConfigValidationError) ErrorName() string {
	return "InstanceTypeConfigValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceTypeConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceTypeConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTypeConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTypeConfigValidationError{}

// Validate checks the field values on DataDisk with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataDisk) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataDisk with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataDiskMultiError, or nil
// if none found.
func (m *DataDisk) ValidateAll() error {
	return m.validate(true)
}

func (m *DataDisk) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DiskType

	// no validation rules for DiskSize

	if len(errors) > 0 {
		return DataDiskMultiError(errors)
	}

	return nil
}

// DataDiskMultiError is an error wrapping multiple validation errors returned
// by DataDisk.ValidateAll() if the designated constraints aren't met.
type DataDiskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataDiskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataDiskMultiError) AllErrors() []error { return m }

// DataDiskValidationError is the validation error returned by
// DataDisk.Validate if the designated constraints aren't met.
type DataDiskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataDiskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataDiskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataDiskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataDiskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataDiskValidationError) ErrorName() string { return "DataDiskValidationError" }

// Error satisfies the builtin error interface
func (e DataDiskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataDisk.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataDiskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataDiskValidationError{}

// Validate checks the field values on DeviceInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeviceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeviceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeviceInfoMultiError, or
// nil if none found.
func (m *DeviceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DeviceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeviceType

	// no validation rules for DeviceQuota

	// no validation rules for DeviceQuotaUsed

	// no validation rules for Attributes

	if len(errors) > 0 {
		return DeviceInfoMultiError(errors)
	}

	return nil
}

// DeviceInfoMultiError is an error wrapping multiple validation errors
// returned by DeviceInfo.ValidateAll() if the designated constraints aren't met.
type DeviceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeviceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeviceInfoMultiError) AllErrors() []error { return m }

// DeviceInfoValidationError is the validation error returned by
// DeviceInfo.Validate if the designated constraints aren't met.
type DeviceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeviceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeviceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeviceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeviceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeviceInfoValidationError) ErrorName() string { return "DeviceInfoValidationError" }

// Error satisfies the builtin error interface
func (e DeviceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeviceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeviceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeviceInfoValidationError{}

// Validate checks the field values on CreateProjectQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateProjectQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProjectQuotaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProjectQuotaRequestMultiError, or nil if none found.
func (m *CreateProjectQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProjectQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetQuotaName()); l < 1 || l > 10240 {
		err := CreateProjectQuotaRequestValidationError{
			field:  "QuotaName",
			reason: "value length must be between 1 and 10240 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProjectID

	// no validation rules for ProjectCode

	// no validation rules for ClusterId

	// no validation rules for ClusterName

	// no validation rules for NameSpace

	// no validation rules for BusinessID

	// no validation rules for BusinessName

	// no validation rules for Description

	// no validation rules for QuotaType

	// no validation rules for Provider

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateProjectQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateProjectQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateProjectQuotaRequestValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return CreateProjectQuotaRequestMultiError(errors)
	}

	return nil
}

// CreateProjectQuotaRequestMultiError is an error wrapping multiple validation
// errors returned by CreateProjectQuotaRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateProjectQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProjectQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProjectQuotaRequestMultiError) AllErrors() []error { return m }

// CreateProjectQuotaRequestValidationError is the validation error returned by
// CreateProjectQuotaRequest.Validate if the designated constraints aren't met.
type CreateProjectQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProjectQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProjectQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProjectQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProjectQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProjectQuotaRequestValidationError) ErrorName() string {
	return "CreateProjectQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProjectQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProjectQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProjectQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProjectQuotaRequestValidationError{}

// Validate checks the field values on GetProjectQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectQuotaRequestMultiError, or nil if none found.
func (m *GetProjectQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuotaId

	if len(errors) > 0 {
		return GetProjectQuotaRequestMultiError(errors)
	}

	return nil
}

// GetProjectQuotaRequestMultiError is an error wrapping multiple validation
// errors returned by GetProjectQuotaRequest.ValidateAll() if the designated
// constraints aren't met.
type GetProjectQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectQuotaRequestMultiError) AllErrors() []error { return m }

// GetProjectQuotaRequestValidationError is the validation error returned by
// GetProjectQuotaRequest.Validate if the designated constraints aren't met.
type GetProjectQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectQuotaRequestValidationError) ErrorName() string {
	return "GetProjectQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectQuotaRequestValidationError{}

// Validate checks the field values on UpdateProjectQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProjectQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProjectQuotaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProjectQuotaRequestMultiError, or nil if none found.
func (m *UpdateProjectQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProjectQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuotaId

	if utf8.RuneCountInString(m.GetName()) > 64 {
		err := UpdateProjectQuotaRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProjectQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProjectQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProjectQuotaRequestValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Updater

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return UpdateProjectQuotaRequestMultiError(errors)
	}

	return nil
}

// UpdateProjectQuotaRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateProjectQuotaRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateProjectQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProjectQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProjectQuotaRequestMultiError) AllErrors() []error { return m }

// UpdateProjectQuotaRequestValidationError is the validation error returned by
// UpdateProjectQuotaRequest.Validate if the designated constraints aren't met.
type UpdateProjectQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProjectQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProjectQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProjectQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProjectQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProjectQuotaRequestValidationError) ErrorName() string {
	return "UpdateProjectQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProjectQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProjectQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProjectQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProjectQuotaRequestValidationError{}

// Validate checks the field values on UpdateProjectBusinessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProjectBusinessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProjectBusinessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProjectBusinessRequestMultiError, or nil if none found.
func (m *UpdateProjectBusinessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProjectBusinessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) != 32 {
		err := UpdateProjectBusinessRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if !_UpdateProjectBusinessRequest_ProjectID_Pattern.MatchString(m.GetProjectID()) {
		err := UpdateProjectBusinessRequestValidationError{
			field:  "ProjectID",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for BusinessID

	// no validation rules for Updater

	if len(errors) > 0 {
		return UpdateProjectBusinessRequestMultiError(errors)
	}

	return nil
}

// UpdateProjectBusinessRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateProjectBusinessRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateProjectBusinessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProjectBusinessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProjectBusinessRequestMultiError) AllErrors() []error { return m }

// UpdateProjectBusinessRequestValidationError is the validation error returned
// by UpdateProjectBusinessRequest.Validate if the designated constraints
// aren't met.
type UpdateProjectBusinessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProjectBusinessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProjectBusinessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProjectBusinessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProjectBusinessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProjectBusinessRequestValidationError) ErrorName() string {
	return "UpdateProjectBusinessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProjectBusinessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProjectBusinessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProjectBusinessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProjectBusinessRequestValidationError{}

var _UpdateProjectBusinessRequest_ProjectID_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on DeleteProjectQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteProjectQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteProjectQuotaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteProjectQuotaRequestMultiError, or nil if none found.
func (m *DeleteProjectQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteProjectQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQuotaId()) > 128 {
		err := DeleteProjectQuotaRequestValidationError{
			field:  "QuotaId",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteProjectQuotaRequest_QuotaId_Pattern.MatchString(m.GetQuotaId()) {
		err := DeleteProjectQuotaRequestValidationError{
			field:  "QuotaId",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteProjectQuotaRequestMultiError(errors)
	}

	return nil
}

// DeleteProjectQuotaRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteProjectQuotaRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteProjectQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteProjectQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteProjectQuotaRequestMultiError) AllErrors() []error { return m }

// DeleteProjectQuotaRequestValidationError is the validation error returned by
// DeleteProjectQuotaRequest.Validate if the designated constraints aren't met.
type DeleteProjectQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteProjectQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteProjectQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteProjectQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteProjectQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteProjectQuotaRequestValidationError) ErrorName() string {
	return "DeleteProjectQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteProjectQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteProjectQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteProjectQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteProjectQuotaRequestValidationError{}

var _DeleteProjectQuotaRequest_QuotaId_Pattern = regexp.MustCompile("^[0-9a-zA-Z-]+$")

// Validate checks the field values on ProjectQuotaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProjectQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectQuotaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectQuotaResponseMultiError, or nil if none found.
func (m *ProjectQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectQuotaResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectQuotaResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectQuotaResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectQuotaResponseValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectQuotaResponseValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectQuotaResponseValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectQuotaResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProjectQuotaResponseMultiError(errors)
	}

	return nil
}

// ProjectQuotaResponseMultiError is an error wrapping multiple validation
// errors returned by ProjectQuotaResponse.ValidateAll() if the designated
// constraints aren't met.
type ProjectQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectQuotaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectQuotaResponseMultiError) AllErrors() []error { return m }

// ProjectQuotaResponseValidationError is the validation error returned by
// ProjectQuotaResponse.Validate if the designated constraints aren't met.
type ProjectQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectQuotaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectQuotaResponseValidationError) ErrorName() string {
	return "ProjectQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectQuotaResponseValidationError{}

// Validate checks the field values on ListProjectQuotasRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectQuotasRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectQuotasRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectQuotasRequestMultiError, or nil if none found.
func (m *ListProjectQuotasRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectQuotasRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuotaId

	// no validation rules for QuotaName

	// no validation rules for ProjectID

	// no validation rules for ProjectCode

	// no validation rules for BusinessID

	// no validation rules for QuotaType

	// no validation rules for Provider

	if len(errors) > 0 {
		return ListProjectQuotasRequestMultiError(errors)
	}

	return nil
}

// ListProjectQuotasRequestMultiError is an error wrapping multiple validation
// errors returned by ListProjectQuotasRequest.ValidateAll() if the designated
// constraints aren't met.
type ListProjectQuotasRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectQuotasRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectQuotasRequestMultiError) AllErrors() []error { return m }

// ListProjectQuotasRequestValidationError is the validation error returned by
// ListProjectQuotasRequest.Validate if the designated constraints aren't met.
type ListProjectQuotasRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectQuotasRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectQuotasRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectQuotasRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectQuotasRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectQuotasRequestValidationError) ErrorName() string {
	return "ListProjectQuotasRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectQuotasRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectQuotasRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectQuotasRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectQuotasRequestValidationError{}

// Validate checks the field values on ListProjectQuotasData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectQuotasData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectQuotasData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectQuotasDataMultiError, or nil if none found.
func (m *ListProjectQuotasData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectQuotasData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectQuotasDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectQuotasDataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectQuotasDataValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListProjectQuotasDataMultiError(errors)
	}

	return nil
}

// ListProjectQuotasDataMultiError is an error wrapping multiple validation
// errors returned by ListProjectQuotasData.ValidateAll() if the designated
// constraints aren't met.
type ListProjectQuotasDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectQuotasDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectQuotasDataMultiError) AllErrors() []error { return m }

// ListProjectQuotasDataValidationError is the validation error returned by
// ListProjectQuotasData.Validate if the designated constraints aren't met.
type ListProjectQuotasDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectQuotasDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectQuotasDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectQuotasDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectQuotasDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectQuotasDataValidationError) ErrorName() string {
	return "ListProjectQuotasDataValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectQuotasDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectQuotasData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectQuotasDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectQuotasDataValidationError{}

// Validate checks the field values on ListProjectQuotasResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectQuotasResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectQuotasResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectQuotasResponseMultiError, or nil if none found.
func (m *ListProjectQuotasResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectQuotasResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProjectQuotasResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProjectQuotasResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProjectQuotasResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProjectQuotasResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProjectQuotasResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProjectQuotasResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListProjectQuotasResponseMultiError(errors)
	}

	return nil
}

// ListProjectQuotasResponseMultiError is an error wrapping multiple validation
// errors returned by ListProjectQuotasResponse.ValidateAll() if the
// designated constraints aren't met.
type ListProjectQuotasResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectQuotasResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectQuotasResponseMultiError) AllErrors() []error { return m }

// ListProjectQuotasResponseValidationError is the validation error returned by
// ListProjectQuotasResponse.Validate if the designated constraints aren't met.
type ListProjectQuotasResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectQuotasResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectQuotasResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectQuotasResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectQuotasResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectQuotasResponseValidationError) ErrorName() string {
	return "ListProjectQuotasResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectQuotasResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectQuotasResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectQuotasResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectQuotasResponseValidationError{}

// Validate checks the field values on GetProjectQuotasUsageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectQuotasUsageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectQuotasUsageReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectQuotasUsageReqMultiError, or nil if none found.
func (m *GetProjectQuotasUsageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectQuotasUsageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuotaId

	if len(errors) > 0 {
		return GetProjectQuotasUsageReqMultiError(errors)
	}

	return nil
}

// GetProjectQuotasUsageReqMultiError is an error wrapping multiple validation
// errors returned by GetProjectQuotasUsageReq.ValidateAll() if the designated
// constraints aren't met.
type GetProjectQuotasUsageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectQuotasUsageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectQuotasUsageReqMultiError) AllErrors() []error { return m }

// GetProjectQuotasUsageReqValidationError is the validation error returned by
// GetProjectQuotasUsageReq.Validate if the designated constraints aren't met.
type GetProjectQuotasUsageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectQuotasUsageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectQuotasUsageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectQuotasUsageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectQuotasUsageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectQuotasUsageReqValidationError) ErrorName() string {
	return "GetProjectQuotasUsageReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectQuotasUsageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectQuotasUsageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectQuotasUsageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectQuotasUsageReqValidationError{}

// Validate checks the field values on GetProjectQuotasUsageResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectQuotasUsageResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectQuotasUsageResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectQuotasUsageRespMultiError, or nil if none found.
func (m *GetProjectQuotasUsageResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectQuotasUsageResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProjectQuotasUsageRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProjectQuotasUsageRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProjectQuotasUsageRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProjectQuotasUsageRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProjectQuotasUsageRespValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProjectQuotasUsageRespValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetProjectQuotasUsageRespMultiError(errors)
	}

	return nil
}

// GetProjectQuotasUsageRespMultiError is an error wrapping multiple validation
// errors returned by GetProjectQuotasUsageResp.ValidateAll() if the
// designated constraints aren't met.
type GetProjectQuotasUsageRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectQuotasUsageRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectQuotasUsageRespMultiError) AllErrors() []error { return m }

// GetProjectQuotasUsageRespValidationError is the validation error returned by
// GetProjectQuotasUsageResp.Validate if the designated constraints aren't met.
type GetProjectQuotasUsageRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectQuotasUsageRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectQuotasUsageRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectQuotasUsageRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectQuotasUsageRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectQuotasUsageRespValidationError) ErrorName() string {
	return "GetProjectQuotasUsageRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectQuotasUsageRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectQuotasUsageResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectQuotasUsageRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectQuotasUsageRespValidationError{}

// Validate checks the field values on ZoneResourceUsage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ZoneResourceUsage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ZoneResourceUsage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ZoneResourceUsageMultiError, or nil if none found.
func (m *ZoneResourceUsage) ValidateAll() error {
	return m.validate(true)
}

func (m *ZoneResourceUsage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Zone

	// no validation rules for Quota

	// no validation rules for Used

	if len(errors) > 0 {
		return ZoneResourceUsageMultiError(errors)
	}

	return nil
}

// ZoneResourceUsageMultiError is an error wrapping multiple validation errors
// returned by ZoneResourceUsage.ValidateAll() if the designated constraints
// aren't met.
type ZoneResourceUsageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZoneResourceUsageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZoneResourceUsageMultiError) AllErrors() []error { return m }

// ZoneResourceUsageValidationError is the validation error returned by
// ZoneResourceUsage.Validate if the designated constraints aren't met.
type ZoneResourceUsageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZoneResourceUsageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZoneResourceUsageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZoneResourceUsageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZoneResourceUsageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZoneResourceUsageValidationError) ErrorName() string {
	return "ZoneResourceUsageValidationError"
}

// Error satisfies the builtin error interface
func (e ZoneResourceUsageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZoneResourceUsage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZoneResourceUsageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZoneResourceUsageValidationError{}

// Validate checks the field values on GetProjectQuotasUsageData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectQuotasUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectQuotasUsageData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectQuotasUsageDataMultiError, or nil if none found.
func (m *GetProjectQuotasUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectQuotasUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProjectQuotasUsageDataValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProjectQuotasUsageDataValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProjectQuotasUsageDataValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Region

	// no validation rules for InstanceType

	if all {
		switch v := interface{}(m.GetQuotaUsage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProjectQuotasUsageDataValidationError{
					field:  "QuotaUsage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProjectQuotasUsageDataValidationError{
					field:  "QuotaUsage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuotaUsage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProjectQuotasUsageDataValidationError{
				field:  "QuotaUsage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Cpu

	// no validation rules for Mem

	// no validation rules for Gpu

	if len(errors) > 0 {
		return GetProjectQuotasUsageDataMultiError(errors)
	}

	return nil
}

// GetProjectQuotasUsageDataMultiError is an error wrapping multiple validation
// errors returned by GetProjectQuotasUsageData.ValidateAll() if the
// designated constraints aren't met.
type GetProjectQuotasUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectQuotasUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectQuotasUsageDataMultiError) AllErrors() []error { return m }

// GetProjectQuotasUsageDataValidationError is the validation error returned by
// GetProjectQuotasUsageData.Validate if the designated constraints aren't met.
type GetProjectQuotasUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectQuotasUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectQuotasUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectQuotasUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectQuotasUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectQuotasUsageDataValidationError) ErrorName() string {
	return "GetProjectQuotasUsageDataValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectQuotasUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectQuotasUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectQuotasUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectQuotasUsageDataValidationError{}

// Validate checks the field values on ScaleUpProjectQuotaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ScaleUpProjectQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScaleUpProjectQuotaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScaleUpProjectQuotaRequestMultiError, or nil if none found.
func (m *ScaleUpProjectQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ScaleUpProjectQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuotaId

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaleUpProjectQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaleUpProjectQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaleUpProjectQuotaRequestValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Updater

	if len(errors) > 0 {
		return ScaleUpProjectQuotaRequestMultiError(errors)
	}

	return nil
}

// ScaleUpProjectQuotaRequestMultiError is an error wrapping multiple
// validation errors returned by ScaleUpProjectQuotaRequest.ValidateAll() if
// the designated constraints aren't met.
type ScaleUpProjectQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScaleUpProjectQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScaleUpProjectQuotaRequestMultiError) AllErrors() []error { return m }

// ScaleUpProjectQuotaRequestValidationError is the validation error returned
// by ScaleUpProjectQuotaRequest.Validate if the designated constraints aren't met.
type ScaleUpProjectQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScaleUpProjectQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScaleUpProjectQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScaleUpProjectQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScaleUpProjectQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScaleUpProjectQuotaRequestValidationError) ErrorName() string {
	return "ScaleUpProjectQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ScaleUpProjectQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScaleUpProjectQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScaleUpProjectQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScaleUpProjectQuotaRequestValidationError{}

// Validate checks the field values on ScaleUpProjectQuotaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ScaleUpProjectQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScaleUpProjectQuotaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScaleUpProjectQuotaResponseMultiError, or nil if none found.
func (m *ScaleUpProjectQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ScaleUpProjectQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaleUpProjectQuotaResponseValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaleUpProjectQuotaResponseValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaleUpProjectQuotaResponseValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaleUpProjectQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaleUpProjectQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaleUpProjectQuotaResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScaleUpProjectQuotaResponseMultiError(errors)
	}

	return nil
}

// ScaleUpProjectQuotaResponseMultiError is an error wrapping multiple
// validation errors returned by ScaleUpProjectQuotaResponse.ValidateAll() if
// the designated constraints aren't met.
type ScaleUpProjectQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScaleUpProjectQuotaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScaleUpProjectQuotaResponseMultiError) AllErrors() []error { return m }

// ScaleUpProjectQuotaResponseValidationError is the validation error returned
// by ScaleUpProjectQuotaResponse.Validate if the designated constraints
// aren't met.
type ScaleUpProjectQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScaleUpProjectQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScaleUpProjectQuotaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScaleUpProjectQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScaleUpProjectQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScaleUpProjectQuotaResponseValidationError) ErrorName() string {
	return "ScaleUpProjectQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ScaleUpProjectQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScaleUpProjectQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScaleUpProjectQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScaleUpProjectQuotaResponseValidationError{}

// Validate checks the field values on ScaleDownProjectQuotaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ScaleDownProjectQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScaleDownProjectQuotaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScaleDownProjectQuotaRequestMultiError, or nil if none found.
func (m *ScaleDownProjectQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ScaleDownProjectQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuotaId

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaleDownProjectQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaleDownProjectQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaleDownProjectQuotaRequestValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Updater

	if len(errors) > 0 {
		return ScaleDownProjectQuotaRequestMultiError(errors)
	}

	return nil
}

// ScaleDownProjectQuotaRequestMultiError is an error wrapping multiple
// validation errors returned by ScaleDownProjectQuotaRequest.ValidateAll() if
// the designated constraints aren't met.
type ScaleDownProjectQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScaleDownProjectQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScaleDownProjectQuotaRequestMultiError) AllErrors() []error { return m }

// ScaleDownProjectQuotaRequestValidationError is the validation error returned
// by ScaleDownProjectQuotaRequest.Validate if the designated constraints
// aren't met.
type ScaleDownProjectQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScaleDownProjectQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScaleDownProjectQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScaleDownProjectQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScaleDownProjectQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScaleDownProjectQuotaRequestValidationError) ErrorName() string {
	return "ScaleDownProjectQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ScaleDownProjectQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScaleDownProjectQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScaleDownProjectQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScaleDownProjectQuotaRequestValidationError{}

// Validate checks the field values on ScaleDownProjectQuotaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ScaleDownProjectQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScaleDownProjectQuotaResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ScaleDownProjectQuotaResponseMultiError, or nil if none found.
func (m *ScaleDownProjectQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ScaleDownProjectQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaleDownProjectQuotaResponseValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaleDownProjectQuotaResponseValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaleDownProjectQuotaResponseValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestID

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaleDownProjectQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaleDownProjectQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaleDownProjectQuotaResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScaleDownProjectQuotaResponseMultiError(errors)
	}

	return nil
}

// ScaleDownProjectQuotaResponseMultiError is an error wrapping multiple
// validation errors returned by ScaleDownProjectQuotaResponse.ValidateAll()
// if the designated constraints aren't met.
type ScaleDownProjectQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScaleDownProjectQuotaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScaleDownProjectQuotaResponseMultiError) AllErrors() []error { return m }

// ScaleDownProjectQuotaResponseValidationError is the validation error
// returned by ScaleDownProjectQuotaResponse.Validate if the designated
// constraints aren't met.
type ScaleDownProjectQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScaleDownProjectQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScaleDownProjectQuotaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScaleDownProjectQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScaleDownProjectQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScaleDownProjectQuotaResponseValidationError) ErrorName() string {
	return "ScaleDownProjectQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ScaleDownProjectQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScaleDownProjectQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScaleDownProjectQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScaleDownProjectQuotaResponseValidationError{}

// Validate checks the field values on ListProjectsForIAMResp_Project with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectsForIAMResp_Project) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectsForIAMResp_Project with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListProjectsForIAMResp_ProjectMultiError, or nil if none found.
func (m *ListProjectsForIAMResp_Project) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectsForIAMResp_Project) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ProjectID

	// no validation rules for ProjectCode

	// no validation rules for BusinessID

	// no validation rules for Managers

	// no validation rules for BkmSpaceBizID

	// no validation rules for BkmSpaceName

	if len(errors) > 0 {
		return ListProjectsForIAMResp_ProjectMultiError(errors)
	}

	return nil
}

// ListProjectsForIAMResp_ProjectMultiError is an error wrapping multiple
// validation errors returned by ListProjectsForIAMResp_Project.ValidateAll()
// if the designated constraints aren't met.
type ListProjectsForIAMResp_ProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectsForIAMResp_ProjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectsForIAMResp_ProjectMultiError) AllErrors() []error { return m }

// ListProjectsForIAMResp_ProjectValidationError is the validation error
// returned by ListProjectsForIAMResp_Project.Validate if the designated
// constraints aren't met.
type ListProjectsForIAMResp_ProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectsForIAMResp_ProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectsForIAMResp_ProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectsForIAMResp_ProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectsForIAMResp_ProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectsForIAMResp_ProjectValidationError) ErrorName() string {
	return "ListProjectsForIAMResp_ProjectValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectsForIAMResp_ProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectsForIAMResp_Project.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectsForIAMResp_ProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectsForIAMResp_ProjectValidationError{}
